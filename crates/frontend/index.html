<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axur Web - Threat Hunting</title>
    <meta name="description" content="Axur Web - Generador de reportes de inteligencia de amenazas externas">

    <!-- Google Fonts: Outfit (Premium Sans) & Syncopate (Cinematic Display) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700;900&family=Syncopate:wght@400;700&family=Inter:wght@400;600&family=DM+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link data-trunk rel="rust" href="Cargo.toml" />
    <link data-trunk rel="copy-dir" href="assets" />

    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- html2canvas for screenshots -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>


    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Global function for screenshot capture (kept for now as fallback/bridge)
        window.captureScreenshot = async function () {
            if (typeof html2canvas === 'undefined') return null;
            try {
                const canvas = await html2canvas(document.body, {
                    logging: false, useCORS: true, allowTaint: true,
                    ignoreElements: (e) => e.classList.contains('feedback-widget-ignore')
                });
                return canvas.toDataURL('image/jpeg', 0.7);
            } catch (e) { console.error(e); return null; }
        };
    </script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['DM Mono', 'monospace'],
                        display: ['Syncopate', 'Outfit', 'sans-serif'], // Cinematic Headers
                        body: ['Outfit', 'sans-serif'], // Premium Body
                    },
                    colors: {
                        brand: {
                            primary: '#FF671F', // Axur Orange
                            'primary-hover': '#E6500A',
                            secondary: '#EF4043', // Axur Red
                        },
                        surface: {
                            base: '#050505', // Deepest Black
                            layer: '#09090b', // Zinc-950
                            elevated: '#18181b', // Zinc-900
                            highlight: '#27272a', // Zinc-800
                        },
                        content: {
                            primary: '#FFFFFF',
                            secondary: '#a1a1aa', // Zinc-400
                            tertiary: '#52525b', // Zinc-600
                        },
                        status: {
                            success: '#22c55e',
                            warning: '#f59e0b',
                            danger: '#ef4444',
                            info: '#3b82f6',
                        }
                    },
                    backgroundImage: {
                        'cyber-grid': "radial-gradient(circle at 50% 50%, rgba(255, 103, 31, 0.03) 0%, transparent 50%), linear-gradient(0deg, rgba(255,255,255,0.02) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px)",
                        'glass-gradient': "linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.01) 100%)",
                        'glow-orange': "radial-gradient(circle, rgba(255,103,31,0.15) 0%, transparent 70%)",
                    },
                    animation: {
                        'glow-pulse': 'glow-pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                        'scanline': 'scanline 8s linear infinite',
                    },
                    keyframes: {
                        'glow-pulse': {
                            '0%, 100%': { opacity: '0.5', boxShadow: '0 0 20px rgba(255, 103, 31, 0.1)' },
                            '50%': { opacity: '1', boxShadow: '0 0 30px rgba(255, 103, 31, 0.3)' },
                        },
                        'float': {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        'scanline': {
                            '0%': { transform: 'translateY(-100%)' },
                            '100%': { transform: 'translateY(100%)' },
                        }
                    },
                    boxShadow: {
                        'glass': '0 8px 32px 0 rgba(0, 0, 0, 0.37)',
                        'glow': '0 0 15px rgba(255, 103, 31, 0.3)',
                        'glow-sm': '0 0 10px rgba(255, 103, 31, 0.2)',
                    }
                },
            },
        };



        // ==================== PPTX IMPORTER (HYBRID) ====================

        // ==================== PPTX IMPORTER (HYBRID V2 - FIXED) ====================
        // ==================== PPTX IMPORTER REMOVED (Migrated to PptxService) ====================
        // Legacy code removed.


        // Handle PPTX import from file input (called via setTimeout to avoid WASM closure issues)
        window.handlePptxImport = async function () {
            try {
                const input = document.getElementById('pptx-input');
                if (!input.files || input.files.length === 0) return;

                const file = input.files[0];
                console.log('[PPTX] Selected file:', file.name);

                const result = await window.importPPTX(file);
                input.value = '';

                if (result.success && result.slides.length > 0) {
                    console.log('[PPTX] Loading ' + result.slides.length + ' slides with editable elements...');

                    // Use parsed slides directly (editable elements!)
                    const editableSlides = result.slides.map((slide, i) => ({
                        id: 'imported-' + (i + 1),
                        name: 'Slide ' + (i + 1),
                        canvasJson: slide.canvasJson // Keep original parsed JSON
                    }));

                    // Store for navigation
                    window._importedSlides = editableSlides;
                    window._importedFileName = result.fileName.replace('.pptx', '');
                    window._currentImportedSlideIndex = 0;

                    // Load first slide into canvas
                    window.loadCanvasJSON(editableSlides[0].canvasJson);

                    // Show guidance modal (Reusing Editable guide but tailored in function)
                    window.showImportGuideEditable(result.slideCount, result.fileName, function () {
                        console.log('[PPTX] User ready to edit ' + editableSlides.length + ' slides');
                        window.updatePptxIndicator();
                        // Unlock first_import achievement
                        if (window.unlockAchievement) window.unlockAchievement('first_import');
                    });
                } else {
                    alert('‚ùå No se encontraron slides en el archivo');
                }
            } catch (e) {
                console.error('[PPTX] Import error:', e);
                alert('‚ùå Error al importar: ' + e.message);
            }
        };

        // ==================== PPTX IMPORT PROGRESS OVERLAY ====================
        window._pptxOverlay = null;

        window.showPptxProgress = function (stage, detail) {
            if (!window._pptxOverlay) {
                window._pptxOverlay = document.createElement('div');
                window._pptxOverlay.id = 'pptx-progress-overlay';
                window._pptxOverlay.innerHTML = `
                    <div style="position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 9999;">
                        <div style="background: #18181b; border: 1px solid #27272a; border-radius: 16px; padding: 32px; max-width: 400px; width: 90%; color: white; font-family: Inter, sans-serif; text-align: center;">
                            <div style="width: 48px; height: 48px; border: 3px solid #3f3f46; border-top-color: #f97316; border-radius: 50%; margin: 0 auto 20px; animation: pptx-spin 1s linear infinite;"></div>
                            <h3 id="pptx-stage" style="margin: 0 0 8px; font-size: 18px; font-weight: 600;">Importando...</h3>
                            <p id="pptx-detail" style="margin: 0; color: #a1a1aa; font-size: 14px;"></p>
                            <div style="margin-top: 20px; height: 4px; background: #27272a; border-radius: 2px; overflow: hidden;">
                                <div id="pptx-progress-bar" style="height: 100%; background: linear-gradient(90deg, #f97316, #fbbf24); width: 0%; transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    </div>
                    <style>
                        @keyframes pptx-spin { to { transform: rotate(360deg); } }
                    </style>
                `;
                document.body.appendChild(window._pptxOverlay);
            }

            const stageEl = document.getElementById('pptx-stage');
            const detailEl = document.getElementById('pptx-detail');
            const progressBar = document.getElementById('pptx-progress-bar');

            const stages = {
                'uploading': { text: 'üì§ Subiendo archivo...', progress: 20 },
                'processing': { text: '‚öôÔ∏è Procesando slides...', progress: 50 },
                'loading': { text: 'üé® Cargando editor...', progress: 80 },
                'complete': { text: '‚úÖ Completado', progress: 100 }
            };

            const s = stages[stage] || { text: stage, progress: 50 };
            if (stageEl) stageEl.textContent = s.text;
            if (detailEl) detailEl.textContent = detail || '';
            if (progressBar) progressBar.style.width = s.progress + '%';
        };

        window.hidePptxProgress = function () {
            if (window._pptxOverlay) {
                document.body.removeChild(window._pptxOverlay);
                window._pptxOverlay = null;
            }
        };

        // Handle PPTX import from stored global file (works with setTimeout)
        window.handlePptxImportFromGlobal = async function () {
            try {
                const file = window._pendingPptxFile;
                if (!file) {
                    console.warn('[PPTX] No pending file to import');
                    return;
                }

                // Clear the pending file
                window._pendingPptxFile = null;

                // Also clear the input
                const input = document.getElementById('pptx-input');
                if (input) input.value = '';

                console.log('[PPTX] Selected file:', file.name);

                // Show progress overlay
                window.showPptxProgress('uploading', file.name);

                const result = await window.importPPTX(file);

                window.showPptxProgress('loading', result.slides.length + ' slides');

                if (result.success && result.slides.length > 0) {
                    console.log('[PPTX] Loading ' + result.slides.length + ' slides with editable elements...');

                    // Use parsed slides directly (editable elements!)
                    const editableSlides = result.slides.map((slide, i) => ({
                        id: 'imported-' + (i + 1),
                        name: 'Slide ' + (i + 1),
                        canvasJson: slide.canvasJson
                    }));

                    // Store for navigation
                    window._importedSlides = editableSlides;
                    window._importedFileName = result.fileName.replace('.pptx', '');
                    window._currentImportedSlideIndex = 0;

                    // Load first slide into canvas
                    window.loadCanvasJSON(editableSlides[0].canvasJson);

                    // Hide progress and show guidance modal
                    window.hidePptxProgress();
                    window.showImportGuideEditable(result.slideCount, result.fileName, function () {
                        console.log('[PPTX] User ready to edit ' + editableSlides.length + ' slides');
                        window.updatePptxIndicator();
                    });
                } else {
                    window.hidePptxProgress();
                    alert('‚ùå No se encontraron slides en el archivo');
                }
            } catch (e) {
                window.hidePptxProgress();
                console.error('[PPTX] Import error:', e);
                alert('‚ùå Error al importar: ' + e.message);
            }
        };

        // Convert parsed slide to background image for maximum fidelity
        window.convertToBackgroundImage = async function (canvasJson) {
            return new Promise((resolve, reject) => {
                try {
                    // Create temporary canvas
                    const tempCanvasEl = document.createElement('canvas');
                    tempCanvasEl.width = 1280;
                    tempCanvasEl.height = 720;
                    tempCanvasEl.style.display = 'none';
                    document.body.appendChild(tempCanvasEl);

                    // Create temporary Fabric canvas
                    const tempCanvas = new fabric.Canvas(tempCanvasEl, {
                        width: 1280,
                        height: 720,
                        backgroundColor: '#18181b'
                    });

                    // Load the parsed JSON
                    const data = JSON.parse(canvasJson);
                    tempCanvas.loadFromJSON(data, function () {
                        tempCanvas.renderAll();

                        // Export as PNG data URL
                        const dataUrl = tempCanvas.toDataURL({
                            format: 'png',
                            quality: 1,
                            multiplier: 1
                        });

                        // Create new JSON with image as background
                        const backgroundJson = {
                            version: '5.3.0',
                            objects: [{
                                type: 'image',
                                left: 0,
                                top: 0,
                                width: 1280,
                                height: 720,
                                src: dataUrl,
                                selectable: false,
                                evented: false,
                                lockMovementX: true,
                                lockMovementY: true,
                                lockRotation: true,
                                lockScalingX: true,
                                lockScalingY: true,
                                hasControls: false,
                                hasBorders: false,
                                isBackground: true
                            }]
                        };

                        // Cleanup
                        tempCanvas.dispose();
                        document.body.removeChild(tempCanvasEl);

                        resolve(JSON.stringify(backgroundJson));
                    });
                } catch (e) {
                    console.error('[PPTX] Failed to convert to background:', e);
                    reject(e);
                }
            });
        };

        // Show import guidance modal
        window.showImportGuide = function (slideCount, fileName, onContinue) {
            // Retired legacy modal
            if (onContinue) onContinue();
        };

        // Show import guidance modal for EDITABLE elements
        window.showImportGuideEditable = function (slideCount, fileName, onContinue) {
            const modal = document.createElement('div');
            modal.id = 'import-guide-modal';
            modal.innerHTML = `
        <div
            style="position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 9999;">
            <div
                style="background: #18181b; border: 1px solid #27272a; border-radius: 16px; padding: 32px; max-width: 560px; color: white; font-family: Inter, sans-serif;">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 24px;">
                    <span style="font-size: 32px;">‚úÖ</span>
                    <div>
                        <h2 style="margin: 0; font-size: 20px; font-weight: 600;">Importaci√≥n Overlay Exitosa</h2>
                        <p style="margin: 4px 0 0; color: #a1a1aa; font-size: 14px;">${slideCount} slide(s) de
                            "${fileName}"</p>
                    </div>
                </div>

                <div style="background: #27272a; border-radius: 12px; padding: 20px; margin-bottom: 24px;">
                    <h3 style="margin: 0 0 12px; font-size: 16px; color: #22c55e;">‚ú® Modo de Edici√≥n Overlay:</h3>
                    <ul style="margin: 0; padding-left: 20px; color: #d4d4d8; font-size: 14px; line-height: 1.8;">
                        <li>El contenido original es un <strong>Fondo Est√°tico</strong> (100% fidelidad).</li>
                        <li>Agrega <strong>Placeholders</strong> encima usando el men√∫ "üì¶ Placeholders".</li>
                        <li>Al exportar, se inyectar√°n los placeholders en el archivo original.</li>
                    </ul>
                </div>

                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="guide-continue-btn2"
                        style="padding: 12px 24px; background: #22c55e; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; font-size: 14px;">
                        Comenzar a editar ‚Üí
                    </button>
                </div>
            </div>
        </div>
        `;
            document.body.appendChild(modal);

            document.getElementById('guide-continue-btn2').onclick = function () {
                document.body.removeChild(modal);
                if (onContinue) onContinue();
            };
        };

        // Get imported slides for editor panel
        window.getImportedSlides = function () {
            return window._importedSlides || [];
        };

        // Get imported file name
        window.getImportedFileName = function () {
            return window._importedFileName || '';
        };

        // Check if there are imported slides waiting
        window.hasImportedSlides = function () {
            return window._importedSlides && window._importedSlides.length > 0;
        };

        // Clear imported slides after they've been loaded into editor
        window.clearImportedSlides = function () {
            window._importedSlides = null;
            window._importedFileName = '';
        };

        // Sync imported slides to editor panel (updates DOM directly)
        window.syncImportedSlidesToPanel = function () {
            const slides = window._importedSlides;
            if (!slides || slides.length === 0) return;

            // Find the slide panel container
            const slidePanel = document.querySelector('.slide-panel, [data-slide-panel], .space-y-2');
            if (!slidePanel) {
                console.log('[PPTX] Slide panel not found, slides stored in window._importedSlides');
                return;
            }

            // Clear existing slides (except any system slides)
            // Note: Leptos will manage this, we just log for debugging
            console.log('[PPTX] ' + slides.length + ' slides ready in window._importedSlides');
            console.log('[PPTX] Use getImportedSlides() to retrieve them');
        };

        // Make slide navigation easier by exposing current slide index
        window._currentImportedSlideIndex = 0;

        window.navigateImportedSlide = function (index) {
            const slides = window._importedSlides;
            if (!slides || index < 0 || index >= slides.length) return;

            window._currentImportedSlideIndex = index;
            window.loadCanvasJSON(slides[index].canvasJson);

            // Update slide indicator in toolbar
            const indicator = document.getElementById('pptx-slide-indicator');
            if (indicator) {
                indicator.textContent = 'PPTX: ' + (index + 1) + '/' + slides.length;
            }

            console.log('[PPTX] Loaded slide ' + (index + 1) + ' of ' + slides.length);
        };

        // Update indicator when slides are first imported
        window.updatePptxIndicator = function () {
            const slides = window._importedSlides;
            const indicator = document.getElementById('pptx-slide-indicator');
            if (indicator && slides && slides.length > 0) {
                indicator.textContent = 'PPTX: ' + (window._currentImportedSlideIndex + 1) + '/' + slides.length;
            }
            // Also render thumbnails in sidebar
            window.renderPptxThumbnails();
        };

        // Render thumbnails for imported slides in the sidebar
        window.renderPptxThumbnails = function () {
            const slides = window._importedSlides;
            const panel = document.getElementById('pptx-slides-panel');
            const container = document.getElementById('pptx-thumbnails');

            if (!slides || slides.length === 0 || !panel || !container) {
                if (panel) panel.style.display = 'none';
                return;
            }

            // Show panel
            panel.style.display = 'block';

            // Clear existing thumbnails
            container.innerHTML = '';

            // Drag state
            let dragIndex = null;

            // Create thumbnail buttons with real previews and drag-drop
            slides.forEach((slide, idx) => {
                const btn = document.createElement('button');
                btn.className = 'w-full aspect-video rounded cursor-grab border-2 transition overflow-hidden relative ' +
                    (idx === window._currentImportedSlideIndex ? 'border-orange-500' : 'border-zinc-700 hover:border-zinc-500');
                btn.title = 'Slide ' + (idx + 1) + ' - drag to reorder';
                btn.draggable = true;
                btn.dataset.index = idx;

                // Slide number badge
                const badge = document.createElement('span');
                badge.className = 'absolute bottom-1 right-1 bg-black/70 text-orange-400 text-xs px-1 rounded';
                badge.textContent = (idx + 1);
                btn.appendChild(badge);

                // Extract background image URL from canvas JSON and show as thumbnail
                try {
                    const jsonData = typeof slide.canvasJson === 'string' ?
                        JSON.parse(slide.canvasJson) : slide.canvasJson;

                    const bgSrc = jsonData.backgroundImage?.src;
                    if (bgSrc) {
                        // Use simple img element instead of Fabric canvas for thumbnails
                        const thumbImg = document.createElement('img');
                        thumbImg.src = bgSrc;
                        thumbImg.className = 'w-full h-full object-cover';
                        thumbImg.crossOrigin = 'anonymous';
                        thumbImg.style.pointerEvents = 'none';
                        thumbImg.onerror = function () {
                            // Fallback on error
                            thumbImg.remove();
                            btn.style.background = '#27272a';
                        };
                        btn.appendChild(thumbImg);
                    } else {
                        // No background image, show placeholder
                        btn.style.background = '#27272a';
                    }
                } catch (e) {
                    // Fallback: show number if preview fails
                    btn.innerHTML = '<span class="text-orange-400 text-2xl">' + (idx + 1) + '</span>';
                    btn.className += ' bg-zinc-800 flex items-center justify-center';
                }

                // Click to navigate
                btn.onclick = function () {
                    window.navigateImportedSlide(idx);
                    window.renderPptxThumbnails();
                };

                // Drag start
                btn.ondragstart = function (e) {
                    dragIndex = idx;
                    btn.style.opacity = '0.5';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', idx);
                };

                // Drag end
                btn.ondragend = function () {
                    btn.style.opacity = '1';
                    dragIndex = null;
                    // Remove all drag-over styles
                    container.querySelectorAll('.border-orange-400').forEach(el => {
                        el.classList.remove('border-orange-400');
                    });
                };

                // Drag over
                btn.ondragover = function (e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (dragIndex !== null && dragIndex !== idx) {
                        btn.classList.add('border-orange-400');
                    }
                };

                // Drag leave
                btn.ondragleave = function () {
                    btn.classList.remove('border-orange-400');
                };

                // Drop
                btn.ondrop = function (e) {
                    e.preventDefault();
                    btn.classList.remove('border-orange-400');
                    const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                    if (!isNaN(fromIdx) && fromIdx !== idx) {
                        window.reorderSlide(fromIdx, idx);
                    }
                };

                container.appendChild(btn);
            });
        };

        // ============= PPTX Slide Management =============

        // Reorder slides
        window.reorderSlide = function (fromIndex, toIndex) {
            const slides = window._importedSlides;
            if (!slides || fromIndex < 0 || toIndex < 0 || fromIndex >= slides.length || toIndex >= slides.length) {
                console.warn('[PPTX] Invalid reorder indices');
                return false;
            }
            const [slide] = slides.splice(fromIndex, 1);
            slides.splice(toIndex, 0, slide);
            if (window._currentImportedSlideIndex === fromIndex) {
                window._currentImportedSlideIndex = toIndex;
            } else if (fromIndex < window._currentImportedSlideIndex && toIndex >= window._currentImportedSlideIndex) {
                window._currentImportedSlideIndex--;
            } else if (fromIndex > window._currentImportedSlideIndex && toIndex <= window._currentImportedSlideIndex) {
                window._currentImportedSlideIndex++;
            }
            console.log('[PPTX] Reordered slide from ' + (fromIndex + 1) + ' to ' + (toIndex + 1));
            window.updatePptxIndicator();
            return true;
        };

        // Duplicate slide
        window.duplicateSlide = function (index) {
            const slides = window._importedSlides;
            if (!slides) return null;
            const idx = index !== undefined ? index : window._currentImportedSlideIndex;
            if (idx < 0 || idx >= slides.length) return null;
            const original = slides[idx];
            const duplicate = JSON.parse(JSON.stringify(original));
            duplicate.name = original.name + ' (Copy)';
            slides.splice(idx + 1, 0, duplicate);
            console.log('[PPTX] Duplicated slide ' + (idx + 1) + ', now ' + slides.length + ' slides');
            window.updatePptxIndicator();
            return idx + 1;
        };

        // Delete slide
        window.deleteSlide = function (index) {
            const slides = window._importedSlides;
            if (!slides || slides.length <= 1) {
                console.warn('[PPTX] Cannot delete: need at least 1 slide');
                return false;
            }
            const idx = index !== undefined ? index : window._currentImportedSlideIndex;
            if (idx < 0 || idx >= slides.length) return false;
            slides.splice(idx, 1);
            if (window._currentImportedSlideIndex >= slides.length) {
                window._currentImportedSlideIndex = slides.length - 1;
            }
            console.log('[PPTX] Deleted slide ' + (idx + 1) + ', remaining: ' + slides.length);
            window.updatePptxIndicator();
            // Reload current slide if we deleted the active one
            if (idx === window._currentImportedSlideIndex || window._currentImportedSlideIndex === -1) {
                if (window._currentImportedSlideIndex < 0) window._currentImportedSlideIndex = 0;
                window.loadCanvasJSON(slides[window._currentImportedSlideIndex].canvasJson);
            }
            return true;
        };

        // Export current canvas as single PNG
        window.exportCurrentSlide = function () {
            const dataUrl = (window.fabricCanvas) ?
                window.fabricCanvas.toDataURL({ format: 'png', quality: 1.0 }) : null;
            if (dataUrl) {
                const link = document.createElement('a');
                link.download = 'slide_' + (window._currentImportedSlideIndex + 1) + '.png';
                link.href = dataUrl;
                link.click();
                console.log('[PPTX Export] Exported current slide as PNG');
            } else {
                alert('Canvas not available');
            }
        };

        // Local template storage
        window.localTemplates = {
            STORAGE_KEY: 'axur_user_templates',
            save: function (template) {
                const templates = this.loadAll();
                template.id = 'local_' + Date.now();
                template.savedAt = new Date().toISOString();
                templates.push(template);
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(templates));
                console.log('[Templates] Saved locally:', template.id);
                return template.id;
            },
            loadAll: function () {
                try {
                    return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
                } catch (e) {
                    return [];
                }
            },
            load: function (id) {
                return this.loadAll().find(t => t.id === id);
            },
            delete: function (id) {
                const templates = this.loadAll().filter(t => t.id !== id);
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(templates));
                console.log('[Templates] Deleted:', id);
            }
        };

        // ==================== CSAT SYSTEM ====================
        window.csatSystem = {
            show: function () {
                if (document.getElementById('csat-toast')) return;

                const div = document.createElement('div');
                div.id = 'csat-toast';
                div.className = 'fixed bottom-6 left-1/2 -translate-x-1/2 z-50 bg-zinc-800 border border-zinc-700 rounded-full px-4 py-2 shadow-2xl flex items-center gap-3 animate-in slide-in-from-bottom-5 fade-in duration-300';
                div.innerHTML = `
                    <span class="text-sm text-white font-medium">¬øQu√© tal funcion√≥?</span>
                    <div class="flex gap-2">
                        <button onclick="window.csatSystem.vote(5)" class="text-xl hover:scale-125 transition" title="Bien">üòÄ</button>
                        <button onclick="window.csatSystem.vote(3)" class="text-xl hover:scale-125 transition" title="Regular">üòê</button>
                        <button onclick="window.csatSystem.vote(1)" class="text-xl hover:scale-125 transition" title="Mal">‚òπÔ∏è</button>
                    </div>
                    <button onclick="window.csatSystem.close()" class="ml-2 text-zinc-500 hover:text-white text-lg leading-none">&times;</button>
                `;
                document.body.appendChild(div);

                // Auto close after 10s
                setTimeout(() => this.close(), 10000);
            },

            close: function () {
                const el = document.getElementById('csat-toast');
                if (el) {
                    el.classList.add('animate-out', 'fade-out', 'slide-out-to-bottom-5');
                    setTimeout(() => el.remove(), 300);
                }
            },

            vote: async function (score) {
                this.close();

                if (score >= 4) {
                    const toast = document.createElement('div');
                    toast.className = 'fixed bottom-20 left-1/2 -translate-x-1/2 z-50 bg-green-600/90 backdrop-blur text-white px-4 py-1.5 rounded-full text-sm font-medium animate-in fade-in zoom-in duration-300';
                    toast.textContent = '¬°Gracias por tu feedback!';
                    document.body.appendChild(toast);
                    setTimeout(() => {
                        toast.classList.add('animate-out', 'fade-out');
                        setTimeout(() => toast.remove(), 300);
                    }, 2000);
                } else if (score <= 3) {
                    // Encourage detailed feedback
                    const toast = document.createElement('div');
                    toast.className = 'fixed bottom-20 left-1/2 -translate-x-1/2 z-50 bg-zinc-800 text-zinc-300 px-4 py-1.5 rounded-full text-sm font-medium border border-zinc-600';
                    toast.innerHTML = '¬øAlgo sali√≥ mal? <button onclick="document.querySelector(\'[title=\\\'Enviar Feedback\\\']\').click()" class="text-orange-400 font-bold hover:underline ml-1">Rep√≥rtalo aqu√≠</button>';
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                }

                try {
                    const apiBase = window.API_BASE_URL || '';
                    await fetch(`${apiBase}/api/feedback`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: `[CSAT Vote] Score: ${score}/5`,
                            url: window.location.href,
                            user_agent: navigator.userAgent
                        })
                    });
                } catch (e) { console.error('[CSAT] Failed to log:', e); }
            }
        };

        // Expose globally for simpler Rust binding
        window.showCsat = function () { if (window.csatSystem) window.csatSystem.show(); };

        // ==================== CLOUD AUTO-SAVE ====================
        window.cloudAutoSave = {
            INTERVAL_MS: 30000, // 30 seconds
            _intervalId: null,
            _lastContent: null,
            _templateName: null,
            _isSaving: false,

            // Start auto-save (call after importing PPTX or loading template)
            start: function (templateName) {
                this._templateName = templateName || 'Untitled Template';
                if (this._intervalId) clearInterval(this._intervalId);
                this._intervalId = setInterval(() => this.save(), this.INTERVAL_MS);
                console.log('[CloudAutoSave] Started with name:', this._templateName);
            },

            stop: function () {
                if (this._intervalId) {
                    clearInterval(this._intervalId);
                    this._intervalId = null;
                }
                console.log('[CloudAutoSave] Stopped');
            },

            // Save current slides to cloud (if changed)
            save: async function () {
                if (this._isSaving) return;

                const slides = window._importedSlides;
                if (!slides || slides.length === 0) return;

                // Sync current canvas to slide first
                if (window.fabricCanvas && slides[window._currentImportedSlideIndex]) {
                    slides[window._currentImportedSlideIndex].canvasJson =
                        JSON.stringify(window.fabricCanvas.toJSON(['placeholderKey']));
                }

                // Check if content changed
                const currentContent = JSON.stringify(slides);
                if (currentContent === this._lastContent) {
                    console.log('[CloudAutoSave] No changes, skipping');
                    return;
                }

                this._isSaving = true;
                this._updateIndicator('saving');

                try {
                    const apiBase = window.API_BASE_URL || '';
                    const response = await fetch(`${apiBase}/api/templates/quick-save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            name: this._templateName,
                            description: 'Auto-saved template',
                            slides: slides.map((s, i) => ({
                                id: s.id || `slide-${i + 1}`,
                                name: s.name || `Slide ${i + 1}`,
                                canvas_json: s.canvasJson
                            }))
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this._lastContent = currentContent;
                        this._updateIndicator('saved');
                        console.log('[CloudAutoSave] Saved:', result.id, result.saved_at);
                    } else {
                        console.error('[CloudAutoSave] Failed:', result.message);
                        this._updateIndicator('error');
                    }
                } catch (e) {
                    console.error('[CloudAutoSave] Error:', e);
                    this._updateIndicator('error');
                }

                this._isSaving = false;
            },

            // Update save indicator in UI
            _updateIndicator: function (status) {
                const indicator = document.getElementById('autosave-indicator');
                if (!indicator) return;

                switch (status) {
                    case 'saving':
                        indicator.textContent = '‚òÅÔ∏è Guardando...';
                        indicator.className = 'text-yellow-400 text-xs';
                        break;
                    case 'saved':
                        indicator.textContent = '‚òÅÔ∏è Guardado';
                        indicator.className = 'text-green-400 text-xs';
                        setTimeout(() => {
                            if (indicator.textContent === '‚òÅÔ∏è Guardado') {
                                indicator.textContent = '';
                            }
                        }, 3000);
                        break;
                    case 'error':
                        indicator.textContent = '‚ö†Ô∏è Error';
                        indicator.className = 'text-red-400 text-xs';
                        break;
                }
            }
        };

        // Auto-start when PPTX is imported
        const originalImport = window.importPptxFile;
        if (originalImport) {
            window.importPptxFile = async function (file) {
                window.cloudAutoSave.start(file.name.replace('.pptx', ''));
            }
            return result;
        };
        }
    </script>
    <style>
        /* Scrollbar aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #09090b;
        }

        ::-webkit-scrollbar-thumb {
            background: #27272a;
            border-radius: 4px;
            border: 2px solid #09090b;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3f3f46;
        }

        /* Selection */
        ::selection {
            background: rgba(255, 103, 31, 0.3);
            color: white;
        }

        /* Base Body */
        body {
            background-color: #050505;
            background-image:
                radial-gradient(circle at 15% 50%, rgba(255, 103, 31, 0.08), transparent 25%),
                radial-gradient(circle at 85% 30%, rgba(239, 64, 67, 0.05), transparent 25%);
            background-attachment: fixed;
            color: #ffffff;
            font-feature-settings: "cv02", "cv03", "cv04", "cv11";
        }

        /* Glass Utility */
        .glass-panel {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        /* Utility for text-balance */
        .text-balance {
            text-wrap: balance;
        }
    </style>

    <!-- Fabric.js for canvas editing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script>
        // FIX: Patch Fabric.js 5.3.1 for Chrome 130+ textBaseline issue
        if (typeof fabric !== 'undefined') {
            if (fabric.Text) fabric.Text.prototype.textBaseline = 'alphabetic';
            if (fabric.IText) fabric.IText.prototype.textBaseline = 'alphabetic';
        }
    </script>
    <script>
        // Global canvas instance
        let fabricCanvas = null;

        // Undo/Redo history
        let canvasHistory = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Save canvas state to history
        window.saveCanvasState = function () {
            if (!fabricCanvas) return;
            if (historyIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, historyIndex + 1);
            }
            const json = JSON.stringify(fabricCanvas.toJSON(['placeholderKey', 'id'])); // Include ID via option?
            // Ideally fabricCanvas.toJSON() captures most props. We need ID for hybrid sync.
            // Fabric by default includes 'id' if property exists.
            canvasHistory.push(json);
            historyIndex = canvasHistory.length - 1;
            if (canvasHistory.length > MAX_HISTORY) {
                canvasHistory.shift();
                historyIndex--;
            }
        };

        // Undo last action
        window.undoCanvas = function () {
            if (!fabricCanvas || historyIndex <= 0) return false;
            historyIndex--;
            fabricCanvas.loadFromJSON(JSON.parse(canvasHistory[historyIndex]), function () {
                fabricCanvas.renderAll();
            });
            return true;
        };

        // Redo last undone action
        window.redoCanvas = function () {
            if (!fabricCanvas || historyIndex >= canvasHistory.length - 1) return false;
            historyIndex++;
            fabricCanvas.loadFromJSON(JSON.parse(canvasHistory[historyIndex]), function () {
                fabricCanvas.renderAll();
            });
            return true;
        };

        window.canUndo = function () { return historyIndex > 0; };
        window.canRedo = function () { return historyIndex < canvasHistory.length - 1; };

        // ==================== KEYBOARD UX ACTIONS ====================
        window._clipboard = null;

        window.copyObject = function () {
            if (!fabricCanvas) return;
            const activeObj = fabricCanvas.getActiveObject();
            if (activeObj) {
                activeObj.clone(function (cloned) {
                    window._clipboard = cloned;
                });
                console.log('[Editor] Copied object');
            }
        };

        window.pasteObject = function () {
            if (!fabricCanvas || !window._clipboard) return;
            window._clipboard.clone(function (clonedObj) {
                fabricCanvas.discardActiveObject();
                clonedObj.set({
                    left: clonedObj.left + 20,
                    top: clonedObj.top + 20,
                    evented: true,
                });
                if (clonedObj.type === 'activeSelection') {
                    // special handling for multiple objects
                    clonedObj.canvas = fabricCanvas;
                    clonedObj.forEachObject(function (obj) {
                        fabricCanvas.add(obj);
                    });
                    clonedObj.setCoords();
                } else {
                    fabricCanvas.add(clonedObj);
                }
                window._clipboard = clonedObj; // Enable multiple pastes "staircase" effect
                fabricCanvas.setActiveObject(clonedObj);
                fabricCanvas.requestRenderAll();
                window.saveCanvasState();
                console.log('[Editor] Pasted object');
            });
        };

        window.duplicateObject = function () {
            if (!fabricCanvas) return;
            const activeObj = fabricCanvas.getActiveObject();
            if (activeObj) {
                activeObj.clone(function (clonedObj) {
                    fabricCanvas.discardActiveObject();
                    clonedObj.set({
                        left: activeObj.left + 20,
                        top: activeObj.top + 20,
                        evented: true,
                    });
                    if (clonedObj.type === 'activeSelection') {
                        clonedObj.canvas = fabricCanvas;
                        clonedObj.forEachObject(function (obj) {
                            fabricCanvas.add(obj);
                        });
                        clonedObj.setCoords();
                    } else {
                        fabricCanvas.add(clonedObj);
                    }
                    fabricCanvas.setActiveObject(clonedObj);
                    fabricCanvas.requestRenderAll();
                    window.saveCanvasState();
                    console.log('[Editor] Duplicated object');
                });
            }
        };

        // Keyboard Shortcuts Listener
        document.addEventListener('keydown', function (e) {
            // Ignorar si estamos escribiendo en un input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

            // Ctrl+Z (Undo)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                window.undoCanvas();
            }
            // Ctrl+Shift+Z or Ctrl+Y (Redo)
            if ((e.ctrlKey || e.metaKey) && ((e.shiftKey && e.key === 'z') || e.key === 'y')) {
                e.preventDefault();
                window.redoCanvas();
            }
            // Ctrl+C (Copy)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                window.copyObject();
            }
            // Ctrl+V (Paste)
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                window.pasteObject();
            }
            // Ctrl+D (Duplicate)
            if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                e.preventDefault();
                window.duplicateObject();
            }
            // Delete / Backspace
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (fabricCanvas && fabricCanvas.getActiveObject()) {
                    e.preventDefault();
                    const activeObjects = fabricCanvas.getActiveObjects();
                    if (activeObjects.length) {
                        fabricCanvas.discardActiveObject();
                        // Iterate reversed copy to avoid index issues
                        activeObjects.forEach(function (obj) {
                            fabricCanvas.remove(obj);
                        });
                    } else {
                        fabricCanvas.remove(fabricCanvas.getActiveObject());
                    }
                    window.saveCanvasState();
                }
            }
        });

        // Initialize Fabric.js canvas
        window.initFabricCanvas = function (canvasId) {
            console.log('[Fabric] Initializing canvas:', canvasId);
            const el = document.getElementById(canvasId);
            if (!el) {
                console.error('[Fabric] Canvas element not found:', canvasId);
                return null;
            }
            fabricCanvas = new fabric.Canvas(canvasId, {
                backgroundColor: '#1e293b',
                selection: true,
            });

            canvasHistory = [];
            historyIndex = -1;
            window.saveCanvasState();

            fabricCanvas.on('object:modified', window.saveCanvasState);
            fabricCanvas.on('object:added', window.saveCanvasState);
            fabricCanvas.on('object:removed', window.saveCanvasState);

            // HYBRID SYNC: Update XML on change
            fabricCanvas.on('object:modified', function (e) {
                const obj = e.target;
                if (obj.id && window.PPTXImporter && window.PPTXImporter.patchSlideXML) {
                    const slideNum = (window._currentImportedSlideIndex || 0) + 1;
                    window.PPTXImporter.patchSlideXML(slideNum, [{
                        id: obj.id,
                        left: obj.left,
                        top: obj.top
                    }]);
                }
            });

            // Add grid overlay for visual guidance
            window.toggleCanvasGrid(window._gridEnabled !== false); // Default ON

            console.log('[Fabric] Canvas initialized with history, hybrid sync, and grid');
            return fabricCanvas;
        };

        // Grid state
        window._gridEnabled = true;
        window._gridLines = [];

        // Toggle canvas grid on/off
        window.toggleCanvasGrid = function (enabled) {
            if (!fabricCanvas) return;
            window._gridEnabled = enabled;

            // Remove existing grid lines
            window._gridLines.forEach(line => fabricCanvas.remove(line));
            window._gridLines = [];

            if (!enabled) {
                fabricCanvas.renderAll();
                return;
            }

            const gridSize = 60; // 60px grid cells
            const canvasWidth = fabricCanvas.width || 960;
            const canvasHeight = fabricCanvas.height || 540;
            const gridColor = 'rgba(255,255,255,0.05)';

            // Vertical lines
            for (let x = gridSize; x < canvasWidth; x += gridSize) {
                const line = new fabric.Line([x, 0, x, canvasHeight], {
                    stroke: gridColor,
                    selectable: false,
                    evented: false,
                    strokeWidth: 1,
                    excludeFromExport: true
                });
                window._gridLines.push(line);
                fabricCanvas.add(line);
                fabricCanvas.sendToBack(line);
            }

            // Horizontal lines
            for (let y = gridSize; y < canvasHeight; y += gridSize) {
                const line = new fabric.Line([0, y, canvasWidth, y], {
                    stroke: gridColor,
                    selectable: false,
                    evented: false,
                    strokeWidth: 1,
                    excludeFromExport: true
                });
                window._gridLines.push(line);
                fabricCanvas.add(line);
                fabricCanvas.sendToBack(line);
            }

            // Center lines (slightly more visible)
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const centerColor = 'rgba(99,102,241,0.15)'; // Indigo tint

            const centerVLine = new fabric.Line([centerX, 0, centerX, canvasHeight], {
                stroke: centerColor,
                selectable: false,
                evented: false,
                strokeWidth: 1,
                excludeFromExport: true
            });
            window._gridLines.push(centerVLine);
            fabricCanvas.add(centerVLine);
            fabricCanvas.sendToBack(centerVLine);

            const centerHLine = new fabric.Line([0, centerY, canvasWidth, centerY], {
                stroke: centerColor,
                selectable: false,
                evented: false,
                strokeWidth: 1,
                excludeFromExport: true
            });
            window._gridLines.push(centerHLine);
            fabricCanvas.add(centerHLine);
            fabricCanvas.sendToBack(centerHLine);

            fabricCanvas.renderAll();
            console.log('[Fabric] Grid ' + (enabled ? 'enabled' : 'disabled'));
        };
        // ==================== KEYBOARD SHORTCUTS ====================
        document.addEventListener('keydown', function (e) {
            if (!fabricCanvas) return;

            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Ctrl+Z = Undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                window.undoCanvas();
            }
            // Ctrl+Y or Ctrl+Shift+Z = Redo
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                window.redoCanvas();
            }
            // Delete = Remove selected
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const active = fabricCanvas.getActiveObjects();
                if (active.length > 0) {
                    e.preventDefault();
                    active.forEach(obj => fabricCanvas.remove(obj));
                    fabricCanvas.discardActiveObject();
                    fabricCanvas.renderAll();
                }
            }
            // Ctrl+D = Duplicate selected
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                window.duplicateSelected();
            }
            // Ctrl+A = Select all
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                fabricCanvas.discardActiveObject();
                const sel = new fabric.ActiveSelection(fabricCanvas.getObjects(), { canvas: fabricCanvas });
                fabricCanvas.setActiveObject(sel);
                fabricCanvas.renderAll();
            }
        });

        // ==================== ZOOM CONTROLS ====================
        let currentZoom = 1;

        window.setCanvasZoom = function (zoom) {
            if (!fabricCanvas) return;
            currentZoom = Math.max(0.25, Math.min(2, zoom));
            fabricCanvas.setZoom(currentZoom);
            fabricCanvas.renderAll();
            return currentZoom;
        };

        window.zoomIn = function () { return window.setCanvasZoom(currentZoom + 0.1); };
        window.zoomOut = function () { return window.setCanvasZoom(currentZoom - 0.1); };
        window.zoomReset = function () { return window.setCanvasZoom(1); };
        window.getZoom = function () { return currentZoom; };

        // ==================== ALIGNMENT TOOLS ====================
        window.alignSelected = function (direction) {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObjects();
            if (active.length < 2) return;

            const bounds = fabricCanvas.getActiveObject().getBoundingRect();

            active.forEach(obj => {
                switch (direction) {
                    case 'left': obj.set('left', bounds.left); break;
                    case 'center': obj.set('left', bounds.left + (bounds.width - obj.width * obj.scaleX) / 2); break;
                    case 'right': obj.set('left', bounds.left + bounds.width - obj.width * obj.scaleX); break;
                    case 'top': obj.set('top', bounds.top); break;
                    case 'middle': obj.set('top', bounds.top + (bounds.height - obj.height * obj.scaleY) / 2); break;
                    case 'bottom': obj.set('top', bounds.top + bounds.height - obj.height * obj.scaleY); break;
                }
                obj.setCoords();
            });
            fabricCanvas.renderAll();
        };

        // ==================== LAYER CONTROLS ====================
        window.bringToFront = function () {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObject();
            if (active) {
                fabricCanvas.bringToFront(active);
                fabricCanvas.renderAll();
            }
        };

        window.sendToBack = function () {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObject();
            if (active) {
                fabricCanvas.sendToBack(active);
                fabricCanvas.renderAll();
            }
        };

        window.bringForward = function () {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObject();
            if (active) {
                fabricCanvas.bringForward(active);
                fabricCanvas.renderAll();
            }
        };

        window.sendBackward = function () {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObject();
            if (active) {
                fabricCanvas.sendBackwards(active);
                fabricCanvas.renderAll();
            }
        };

        // ==================== DELETE & DUPLICATE ====================
        window.deleteSelected = function () {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObjects();
            active.forEach(obj => fabricCanvas.remove(obj));
            fabricCanvas.discardActiveObject();
            fabricCanvas.renderAll();
        };

        window.duplicateSelected = function () {
            if (!fabricCanvas) return;
            const active = fabricCanvas.getActiveObject();
            if (!active) return;

            active.clone(function (cloned) {
                cloned.set({
                    left: cloned.left + 20,
                    top: cloned.top + 20,
                });
                fabricCanvas.add(cloned);
                fabricCanvas.setActiveObject(cloned);
                fabricCanvas.renderAll();
            });
        };

        // ==================== GET OBJECTS LIST (for layers panel) ====================
        window.getCanvasObjects = function () {
            if (!fabricCanvas) return '[]';
            const objects = fabricCanvas.getObjects().map((obj, idx) => ({
                index: idx,
                type: obj.type,
                name: obj.placeholderKey || obj.text || obj.type,
                visible: obj.visible !== false,
                locked: obj.lockMovementX && obj.lockMovementY
            }));
            return JSON.stringify(objects);
        };

        window.selectObjectByIndex = function (idx) {
            if (!fabricCanvas) return;
            const objects = fabricCanvas.getObjects();
            if (idx >= 0 && idx < objects.length) {
                fabricCanvas.setActiveObject(objects[idx]);
                fabricCanvas.renderAll();
            }
        };

        // Add text element
        window.addTextToCanvas = function (text) {
            if (!fabricCanvas) return;
            const textObj = new fabric.IText(text, {
                left: 100,
                top: 100,
                fill: '#f8fafc',
                fontSize: 24,
                fontFamily: 'Inter, sans-serif',
            });
            fabricCanvas.add(textObj);
            fabricCanvas.setActiveObject(textObj);
            fabricCanvas.renderAll();
        };

        // Add placeholder (as group with border)
        window.addPlaceholderToCanvas = function (key, html) {
            if (!fabricCanvas) return;
            // Create placeholder as a styled rect with label
            const rect = new fabric.Rect({
                width: 200,
                height: 80,
                fill: 'rgba(99, 102, 241, 0.2)',
                stroke: '#6366f1',
                strokeWidth: 2,
                strokeDashArray: [5, 5],
                rx: 8,
                ry: 8,
            });
            const label = new fabric.Text('{{' + key + '}}', {
                fontSize: 14,
                fill: '#6366f1',
                fontFamily: 'DM Mono, monospace',
            });
            // Center label in rect
            label.set({
                left: (rect.width - label.width) / 2,
                top: (rect.height - label.height) / 2,
            });
            const group = new fabric.Group([rect, label], {
                left: 150,
                top: 150,
            });
            group.set('placeholderKey', key);
            fabricCanvas.add(group);
            fabricCanvas.setActiveObject(group);
            fabricCanvas.renderAll();
        };

        // === Preview Mode (Real-time placeholder rendering) ===
        window.previewModeEnabled = false;

        // Mock data for placeholders (sample values for preview)
        window.placeholderMockData = {
            // General
            'company_name': 'Acme Corporation',
            'date_range': 'Ene 2026 - Dic 2026',
            'tlp_level': 'TLP:AMBER',
            // Metrics
            'total_tickets': '1,247',
            'total_threats': '892',
            'hours_saved': '156h',
            // Threats
            'top_threat_1_name': 'Phishing',
            'top_threat_1_count': '234',
            'threats_by_type': 'üéØ Phishing 45% | üîê Creds 30%',
            // Credentials
            'credentials_total': '3,456',
            'credentials_critical': '127',
            'stealer_log_count': '89',
            // Takedowns
            'takedown_total': '284',
            'takedown_success_rate': '94.2%',
            'takedown_resolved': '267',
            // Risk
            'risk_score_value': '72',
            'risk_score_label': 'Moderado',
        };

        // Toggle preview mode on all placeholders
        window.togglePreviewMode = function (enabled) {
            if (!fabricCanvas) return false;
            window.previewModeEnabled = enabled;

            fabricCanvas.getObjects().forEach(function (obj) {
                const key = obj.get('placeholderKey');
                if (!key) return;

                // Groups contain rect + text
                if (obj._objects && obj._objects.length > 1) {
                    const textObj = obj._objects.find(o => o.type === 'text');
                    if (textObj) {
                        if (enabled) {
                            // Store original and show mock
                            // Check if this is a conditional placeholder
                            let mockValue;
                            if (window.conditionalPlaceholders && window.conditionalPlaceholders[key]) {
                                mockValue = window.evaluateConditional(key);
                            } else {
                                mockValue = window.placeholderMockData[key] || '(sin datos)';
                            }
                            textObj.set('originalText', textObj.text);
                            textObj.set('text', mockValue);
                            // Use cyan for conditional, green for regular
                            const isConditional = window.conditionalPlaceholders && window.conditionalPlaceholders[key];
                            textObj.set('fill', isConditional ? '#06b6d4' : '#22c55e');
                        } else {
                            // Restore original placeholder
                            const original = textObj.get('originalText') || '{{' + key + '}}';
                            textObj.set('text', original);
                            textObj.set('fill', '#6366f1'); // Indigo for placeholder
                        }
                    }
                }
            });

            fabricCanvas.renderAll();
            console.log('[Preview] Mode:', enabled ? 'ON' : 'OFF');
            return enabled;
        };

        // Get current preview mode state
        window.getPreviewMode = function () {
            return window.previewModeEnabled;
        };

        // === Smart Templates: Placeholder Categories ===

        // Map placeholder keys to data categories
        window.placeholderCategories = {
            // General
            'company_name': 'General',
            'date_range': 'General',
            'tlp_level': 'General',
            // Metrics
            'total_tickets': 'Metrics',
            'total_threats': 'Metrics',
            'hours_saved': 'Metrics',
            // Threats
            'top_threat_1_name': 'Threats',
            'top_threat_1_count': 'Threats',
            'top_threat_2_name': 'Threats',
            'top_threat_3_name': 'Threats',
            'threats_by_type': 'Threats',
            // Credentials
            'credentials_total': 'Credentials',
            'credentials_critical': 'Credentials',
            'stealer_log_count': 'Credentials',
            // Takedowns
            'takedown_total': 'Takedowns',
            'takedown_success_rate': 'Takedowns',
            'takedown_resolved': 'Takedowns',
            // Risk
            'risk_score_value': 'Risk',
            'risk_score_label': 'Risk',
        };

        // All possible categories with descriptions
        window.dataCategories = {
            'General': { icon: 'üìã', name: 'Informaci√≥n General', color: '#6366f1' },
            'Metrics': { icon: 'üìä', name: 'M√©tricas', color: '#f97316' },
            'Threats': { icon: 'üéØ', name: 'Amenazas', color: '#ef4444' },
            'Credentials': { icon: 'üîê', name: 'Credenciales', color: '#a855f7' },
            'Takedowns': { icon: '‚úÖ', name: 'Takedowns', color: '#22c55e' },
            'Risk': { icon: '‚ö†Ô∏è', name: 'Risk Score', color: '#f59e0b' },
            'Condicional': { icon: 'üîÄ', name: 'Condicionales', color: '#06b6d4' },
        };

        // === Smart Placeholders: Conditional Logic ===

        // Pre-defined conditional placeholders
        window.conditionalPlaceholders = {
            'risk_status': {
                label: 'Estado de Riesgo',
                condition: 'risk_score_value',
                rules: [
                    { op: '>', value: 70, result: 'üî¥ CR√çTICO: Acci√≥n inmediata requerida' },
                    { op: '>', value: 40, result: 'üü° ALERTA: Monitorear situaci√≥n' },
                    { op: '>=', value: 0, result: 'üü¢ Estado normal' }
                ]
            },
            'threat_level': {
                label: 'Nivel de Amenazas',
                condition: 'total_threats',
                rules: [
                    { op: '>', value: 500, result: '‚ö†Ô∏è Nivel Alto - Requiere atenci√≥n prioritaria' },
                    { op: '>', value: 100, result: '‚ö° Nivel Medio - Monitoreo continuo' },
                    { op: '>=', value: 0, result: '‚úÖ Nivel Bajo - Bajo control' }
                ]
            },
            'credential_alert': {
                label: 'Alerta Credenciales',
                condition: 'credentials_critical',
                rules: [
                    { op: '>', value: 100, result: 'üö® ALERTA CR√çTICA: +100 credenciales expuestas' },
                    { op: '>', value: 50, result: '‚ö†Ô∏è Alerta: M√°s de 50 credenciales cr√≠ticas' },
                    { op: '>=', value: 0, result: '‚ÑπÔ∏è Credenciales bajo control' }
                ]
            },
            'takedown_efficiency': {
                label: 'Eficiencia Takedowns',
                condition: 'takedown_success_rate',
                rules: [
                    { op: '>=', value: 90, result: 'üèÜ Excelente: Eficiencia superior al 90%' },
                    { op: '>=', value: 70, result: 'üëç Buena: Eficiencia sobre 70%' },
                    { op: '>=', value: 0, result: 'üìà Oportunidad de mejora' }
                ]
            }
        };

        // Evaluate a conditional placeholder
        window.evaluateConditional = function (placeholderKey) {
            const config = window.conditionalPlaceholders[placeholderKey];
            if (!config) return `{{${placeholderKey}}}`;

            // Get the value of the condition variable
            const conditionVar = config.condition;
            let rawValue = window.placeholderMockData[conditionVar] || '0';
            // Parse numeric value (remove % and other non-numeric chars)
            let numValue = parseFloat(rawValue.replace(/[^0-9.-]/g, ''));
            if (isNaN(numValue)) numValue = 0;

            // Evaluate rules in order
            for (const rule of config.rules) {
                let match = false;
                switch (rule.op) {
                    case '>': match = numValue > rule.value; break;
                    case '<': match = numValue < rule.value; break;
                    case '>=': match = numValue >= rule.value; break;
                    case '<=': match = numValue <= rule.value; break;
                    case '==': match = numValue === rule.value; break;
                    case '!=': match = numValue !== rule.value; break;
                }
                if (match) return rule.result;
            }
            return config.rules[config.rules.length - 1]?.result || '';
        };

        // Add conditional placeholder category mappings
        window.placeholderCategories['risk_status'] = 'Condicional';
        window.placeholderCategories['threat_level'] = 'Condicional';
        window.placeholderCategories['credential_alert'] = 'Condicional';
        window.placeholderCategories['takedown_efficiency'] = 'Condicional';

        // Analyze template to find which categories are used
        // If slidesJsonArray is provided, also parse those (for full project analysis)
        window.analyzeTemplateData = function (slidesJsonArray) {
            const usedCategories = new Set();
            const usedPlaceholders = [];

            // 1. Analyze current canvas
            if (fabricCanvas) {
                fabricCanvas.getObjects().forEach(function (obj) {
                    const key = obj.get('placeholderKey');
                    if (key) {
                        usedPlaceholders.push(key);
                        const category = window.placeholderCategories[key];
                        if (category) {
                            usedCategories.add(category);
                        }
                    }
                });
            }

            // 2. Analyze all slides from stored JSON (if provided)
            if (slidesJsonArray && Array.isArray(slidesJsonArray)) {
                slidesJsonArray.forEach(function (jsonStr) {
                    try {
                        const canvasData = JSON.parse(jsonStr);
                        if (canvasData.objects && Array.isArray(canvasData.objects)) {
                            canvasData.objects.forEach(function (obj) {
                                // Check for placeholderKey in object properties
                                const key = obj.placeholderKey;
                                if (key && !usedPlaceholders.includes(key)) {
                                    usedPlaceholders.push(key);
                                    const category = window.placeholderCategories[key];
                                    if (category) {
                                        usedCategories.add(category);
                                    }
                                }
                                // Also check in group objects
                                if (obj.objects && Array.isArray(obj.objects)) {
                                    obj.objects.forEach(function (child) {
                                        const childKey = child.placeholderKey;
                                        if (childKey && !usedPlaceholders.includes(childKey)) {
                                            usedPlaceholders.push(childKey);
                                            const cat = window.placeholderCategories[childKey];
                                            if (cat) usedCategories.add(cat);
                                        }
                                    });
                                }
                            });
                        }
                    } catch (e) {
                        console.warn('[SmartTemplates] Failed to parse slide JSON:', e);
                    }
                });
            }

            const allCategories = Object.keys(window.dataCategories);
            const used = allCategories.filter(c => usedCategories.has(c));
            const unused = allCategories.filter(c => !usedCategories.has(c));

            console.log('[SmartTemplates] Full Project Analysis:', {
                slides: slidesJsonArray ? slidesJsonArray.length : 0,
                placeholders: usedPlaceholders.length,
                usedCategories: used.length,
                unusedCategories: unused.length
            });

            return {
                used: used,
                unused: unused,
                placeholders: usedPlaceholders
            };
        };

        // Get category details for UI
        window.getCategoryDetails = function () {
            return window.dataCategories;
        };

        // Add shape
        window.addShapeToCanvas = function (shapeType) {
            if (!fabricCanvas) return;
            let shape;
            if (shapeType === 'rectangle') {
                shape = new fabric.Rect({
                    left: 100,
                    top: 100,
                    width: 150,
                    height: 100,
                    fill: '#3f3f46',
                    stroke: '#52525b',
                    strokeWidth: 1,
                    rx: 4,
                    ry: 4,
                });
            } else if (shapeType === 'circle') {
                shape = new fabric.Circle({
                    left: 100,
                    top: 100,
                    radius: 50,
                    fill: '#3f3f46',
                    stroke: '#52525b',
                    strokeWidth: 1,
                });
            }
            if (shape) {
                fabricCanvas.add(shape);
                fabricCanvas.setActiveObject(shape);
                fabricCanvas.renderAll();
            }
        };

        // Get canvas JSON (with error handling for styles)
        window.getCanvasJSON = function () {
            if (!fabricCanvas) return '{}';
            try {
                // Ensure all text objects have styles property to avoid stylesToArray error
                fabricCanvas.getObjects().forEach(function (obj) {
                    if (obj.type === 'text' || obj.type === 'i-text' || obj.type === 'textbox') {
                        if (!obj.styles) obj.styles = {};
                    }
                });
                return JSON.stringify(fabricCanvas.toJSON(['placeholderKey']));
            } catch (e) {
                console.error('[Fabric] Error serializing canvas:', e);
                return '{}';
            }
        };

        // Load canvas JSON
        window.loadCanvasJSON = function (json) {
            if (!fabricCanvas) return;
            try {
                const data = JSON.parse(json);
                // Initialize styles property for all text objects in the data
                if (data.objects) {
                    data.objects.forEach(function (obj) {
                        if (obj.type === 'text' || obj.type === 'i-text' || obj.type === 'textbox') {
                            if (!obj.styles) obj.styles = {};
                        }
                    });
                }
                fabricCanvas.loadFromJSON(data, function () {
                    // Ensure styles after loading too
                    fabricCanvas.getObjects().forEach(function (obj) {
                        if (obj.type === 'text' || obj.type === 'i-text' || obj.type === 'textbox') {
                            if (!obj.styles) obj.styles = {};
                        }
                    });

                    // Scale background image to fit canvas if needed
                    const bgImg = fabricCanvas.backgroundImage;
                    if (bgImg && bgImg.width && bgImg.height) {
                        const canvasW = fabricCanvas.width;
                        const canvasH = fabricCanvas.height;
                        const imgW = bgImg.width;
                        const imgH = bgImg.height;

                        // Calculate scale to FIT canvas (show entire image, maintain aspect ratio)
                        const scaleX = canvasW / imgW;
                        const scaleY = canvasH / imgH;
                        const scale = Math.min(scaleX, scaleY); // Use min to show entire image

                        bgImg.scaleX = scale;
                        bgImg.scaleY = scale;
                        bgImg.set({ left: 0, top: 0, originX: 'left', originY: 'top' });

                        console.log('[Fabric] Background scaled from ' + imgW + 'x' + imgH + ' to fit canvas');
                    }

                    fabricCanvas.renderAll();
                    console.log('[Fabric] Canvas loaded successfully');
                });
            } catch (e) {
                console.error('[Fabric] Failed to load JSON:', e);
            }
        };

        // Clear canvas
        window.clearCanvas = function () {
            if (!fabricCanvas) return;
            fabricCanvas.clear();
            fabricCanvas.backgroundColor = '#1e293b';
            fabricCanvas.renderAll();
        };

        // Add image to canvas
        window.addImageToCanvas = function (dataUrl) {
            if (!fabricCanvas) return;
            fabric.Image.fromURL(dataUrl, function (img) {
                // Scale image to fit canvas if too large
                const maxWidth = fabricCanvas.width * 0.8;
                const maxHeight = fabricCanvas.height * 0.8;
                if (img.width > maxWidth || img.height > maxHeight) {
                    const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                    img.scale(scale);
                }
                img.set({
                    left: 50,
                    top: 50,
                });
                fabricCanvas.add(img);
                fabricCanvas.setActiveObject(img);
                fabricCanvas.renderAll();
            });
        };

        // Get canvas thumbnail as base64
        window.getCanvasThumbnail = function () {
            if (!fabricCanvas) return '';
            try {
                return fabricCanvas.toDataURL({
                    format: 'png',
                    quality: 0.5,
                    multiplier: 0.25  // 1/4 size thumbnail
                });
            } catch (e) {
                console.error('[Fabric] Failed to get thumbnail:', e);
                return '';
            }
        };

        // Trigger image file picker
        window.triggerImageUpload = function () {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        window.addImageToCanvas(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        };

        // Setup drag and drop for canvas
        window.setupCanvasDragDrop = function () {
            const canvasContainer = document.querySelector('.canvas-drop-zone');
            if (!canvasContainer) {
                console.log('[DragDrop] Canvas container not found, using body');
                return;
            }

            canvasContainer.addEventListener('dragover', function (e) {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.add('drag-over');
            });

            canvasContainer.addEventListener('dragleave', function (e) {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.remove('drag-over');
            });

            canvasContainer.addEventListener('drop', function (e) {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.remove('drag-over');

                // Check for text/plain data first (placeholder drops from modal)
                const textData = e.dataTransfer.getData('text/plain');
                if (textData && textData.startsWith('PLACEHOLDER:')) {
                    // Format: PLACEHOLDER:key:html
                    const parts = textData.split(':');
                    if (parts.length >= 3) {
                        const key = parts[1];
                        const html = parts.slice(2).join(':'); // Rejoin in case HTML had colons
                        console.log('[DragDrop] Placeholder dropped:', key);
                        if (window.addPlaceholderToCanvas) {
                            window.addPlaceholderToCanvas(key, html);
                        }
                    }
                    return; // Handled placeholder drop
                }

                // Otherwise handle file drops (images, PPTX)
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = function (event) {
                            window.addImageToCanvas(event.target.result);
                        };
                        reader.readAsDataURL(file);
                    } else if (file.name.endsWith('.pptx')) {
                        window.handlePptxImport(file);
                    }
                }
            });

            console.log('[DragDrop] Canvas drag & drop enabled (files + placeholders)');
        };

        // Trigger PPTX file picker
        window.triggerPptxUpload = function () {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pptx,.ppt';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) window.handlePptxImport(file);
            };
            input.click();
        };
    </script>
</head>

<body class="bg-zinc-950 text-zinc-100">
    <!-- Loading indicator while WASM loads -->
    <div id="loading-indicator" class="min-h-screen flex items-center justify-center">
        <div class="text-center">
            <div class="inline-flex items-center gap-2 mb-6">
                <span class="text-orange-500 text-4xl font-black italic">///</span>
                <span class="text-white text-3xl font-bold tracking-widest">AXUR</span>
            </div>
            <div class="flex items-center justify-center gap-2 text-zinc-400">
                <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
                <span>Cargando aplicaci√≥n...</span>
            </div>
        </div>
    </div>

    <!-- WASM will be mounted here by Trunk -->
</body>

</html><!-- Rebuild Trigger -->