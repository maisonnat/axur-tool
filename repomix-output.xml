<repomix><file_summary>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).<purpose>This file contains a packed representation of a subset of the repository&apos;s contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: crates/core/**/*.rs
- Files matching these patterns are excluded: **/*.lock, **/target/**, **/node_modules/**, **/dist/**, **/.git/**, **/*.png, **/*.jpg, **/*.ico, **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
- Git diffs from the worktree and staged changes are included</notes></file_summary><user_provided_header>Antigravity Project Context - Generated by Repomix</user_provided_header><directory_structure>crates/core/examples/generate_neuro_report.rs
crates/core/examples/mock_report.rs
crates/core/examples/probe_creds.rs
crates/core/examples/probe_th.rs
crates/core/src/api/mod.rs
crates/core/src/api/report.rs
crates/core/src/api/retry.rs
crates/core/src/build_error_temp.rs
crates/core/src/editor/mod.rs
crates/core/src/editor/placeholders.rs
crates/core/src/editor/storage.rs
crates/core/src/editor/types.rs
crates/core/src/error_codes.rs
crates/core/src/errors.rs
crates/core/src/i18n/compat.rs
crates/core/src/i18n/legacy.rs
crates/core/src/i18n/loader.rs
crates/core/src/i18n/mod.rs
crates/core/src/lib.rs
crates/core/src/plugins/builtin/ai_intent.rs
crates/core/src/plugins/builtin/closing.rs
crates/core/src/plugins/builtin/comparative.rs
crates/core/src/plugins/builtin/cover.rs
crates/core/src/plugins/builtin/credentials.rs
crates/core/src/plugins/builtin/data_exposure.rs
crates/core/src/plugins/builtin/examples.rs
crates/core/src/plugins/builtin/geospatial.rs
crates/core/src/plugins/builtin/google_slides.rs
crates/core/src/plugins/builtin/heatmap.rs
crates/core/src/plugins/builtin/helpers.rs
crates/core/src/plugins/builtin/incidents.rs
crates/core/src/plugins/builtin/insights.rs
crates/core/src/plugins/builtin/intro.rs
crates/core/src/plugins/builtin/kill_chain.rs
crates/core/src/plugins/builtin/metrics.rs
crates/core/src/plugins/builtin/mod.rs
crates/core/src/plugins/builtin/poc_data.rs
crates/core/src/plugins/builtin/radar.rs
crates/core/src/plugins/builtin/roi.rs
crates/core/src/plugins/builtin/solutions.rs
crates/core/src/plugins/builtin/style_showcase.rs
crates/core/src/plugins/builtin/takedowns.rs
crates/core/src/plugins/builtin/theme.rs
crates/core/src/plugins/builtin/threat_intel.rs
crates/core/src/plugins/builtin/threats.rs
crates/core/src/plugins/builtin/timeline.rs
crates/core/src/plugins/builtin/toc.rs
crates/core/src/plugins/builtin/velocity.rs
crates/core/src/plugins/builtin/virality.rs
crates/core/src/plugins/mod.rs
crates/core/src/plugins/registry.rs
crates/core/src/plugins/traits.rs
crates/core/src/pptx_mapper.rs
crates/core/src/report/html.rs
crates/core/src/report/language_switcher.rs
crates/core/src/report/mod.rs
crates/core/src/report/render_data_exposure_slide_snippet.rs
crates/core/src/report/template_renderer.rs
crates/core/src/templates/mod.rs</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="crates/core/src/api/mod.rs">pub mod report;
pub mod retry;
⋮----
pub fn create_client() -&gt; anyhow::Result&lt;reqwest::Client&gt; {
Ok(reqwest::Client::builder()
.timeout(std::time::Duration::from_secs(60))
.build()?)</file><file path="crates/core/examples/generate_neuro_report.rs">use axur_core::api::report::PocReportData;
use axur_core::i18n::Translations;
use axur_core::report::html::generate_report_with_plugins;
use std::fs;
⋮----
fn main() {
println!(&quot;Generating Neuro-Design Mock Report...&quot;);
⋮----
let translations = Translations::load(&quot;es&quot;).expect(&quot;Failed to load translations&quot;);
⋮----
let html = generate_report_with_plugins(&amp;data, &amp;translations, None, None);
⋮----
fs::write(output_path, html).expect(&quot;Unable to write file&quot;);
⋮----
println!(&quot;Success! Report generated at: {}&quot;, output_path);
⋮----
println!(&quot;Absolute path: {:?}&quot;, abs_path);</file><file path="crates/core/examples/mock_report.rs">use axur_core::api::report::PocReportData;
use axur_core::i18n::Translations;
use axur_core::report::html::generate_report_with_plugins;
use std::fs::File;
use std::io::Write;
⋮----
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
println!(&quot;Context: Generating Axur Mock Report for verification...&quot;);
⋮----
println!(
⋮----
disabled_plugins: vec![],
⋮----
Translations::load(&quot;es&quot;).expect(&quot;Failed to load Spanish translations (es.json)&quot;);
println!(&quot;Translations: Loaded &apos;es&apos; locale.&quot;);
⋮----
let html = generate_report_with_plugins(&amp;data, &amp;translations, None, None);
⋮----
file.write_all(html.as_bytes())?;
⋮----
println!(&quot;Success: Report saved to &apos;{}&apos;&quot;, path);
println!(&quot;You can open this file in your browser to inspect the visual changes.&quot;);
Ok(())</file><file path="crates/core/examples/probe_creds.rs">use dotenv::dotenv;
use reqwest::Client;
use std::env;
use std::time::Duration;
use tokio::time::sleep;
⋮----
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
dotenv().ok();
⋮----
let token = env::var(&quot;AXUR_TOKEN&quot;).expect(&quot;AXUR_TOKEN must be set&quot;);
let customer_env = env::var(&quot;AXUR_CUSTOMER&quot;).ok();
⋮----
println!(&quot;Probing Threat Hunting API (Universal) for Credentials:&quot;);
println!(&quot;Token: {}...&quot;, &amp;token[0..10]);
⋮----
println!(&quot;Customer: {}&quot;, c);
⋮----
println!(&quot;Customer: NONE (Using token default)&quot;);
⋮----
let queries = vec![
⋮----
println!(&quot;\n--- Testing query: &apos;{}&apos; Source: {} ---&quot;, q, source);
⋮----
body.as_object_mut()
.unwrap()
.insert(&quot;customer&quot;.to_string(), serde_json::json!(c));
⋮----
println!(&quot;Request Body: {}&quot;, body);
⋮----
.post(url)
.header(&quot;Authorization&quot;, format!(&quot;Bearer {}&quot;, token))
.json(&amp;body)
.send()
⋮----
let status = resp.status();
println!(&quot;Status: {}&quot;, status);
let text = resp.text().await?;
println!(&quot;Response: {}&quot;, text);
⋮----
if !status.is_success() {
⋮----
if let Some(id) = json.get(&quot;searchId&quot;).and_then(|v| v.as_str()) {
println!(&quot;Got searchId: {}. Polling...&quot;, id);
⋮----
let poll_url = format!(&quot;{}/{}&quot;, url, id);
⋮----
sleep(Duration::from_secs(2)).await;
⋮----
.get(&amp;poll_url)
⋮----
let poll_text = poll_resp.text().await?;
println!(&quot;Poll {}: {}&quot;, i, poll_text);
⋮----
if poll_text.contains(&quot;\&quot;totalResults\&quot;:0&quot;)
&amp;&amp; (poll_text.contains(&quot;completed&quot;) || poll_text.contains(&quot;SUCCESSFUL&quot;))
⋮----
println!(&quot;Search completed with 0 results.&quot;);
⋮----
if poll_text.contains(&quot;completed&quot;)
|| poll_text.contains(&quot;SUCCESSFUL&quot;)
|| poll_text.contains(&quot;created&quot;)
⋮----
if poll_text.contains(&quot;\&quot;totalResults\&quot;:&quot;)
&amp;&amp; !poll_text.contains(&quot;\&quot;totalResults\&quot;:0&quot;)
⋮----
println!(&quot;!!! SUCCESS: Got results! !!!&quot;);
⋮----
Ok(())</file><file path="crates/core/examples/probe_th.rs">use serde::Deserialize;
use serde_json::json;
use std::env;
⋮----
struct AxurAuthResponse {
⋮----
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
⋮----
println!(&quot;Current Dir: {:?}&quot;, env::current_dir());
⋮----
Ok(path) =&gt; println!(&quot;Loaded .env from {:?}&quot;, path),
⋮----
println!(&quot;dotenv failed for .env: {}&quot;, e);
⋮----
Ok(path) =&gt; println!(&quot;Loaded ../.env from {:?}&quot;, path),
Err(e) =&gt; println!(&quot;dotenv failed for ../.env too: {}&quot;, e),
⋮----
let client = reqwest::Client::builder().build()?;
⋮----
let token_bypass = env::var(&quot;AXUR_TOKEN&quot;).ok();
⋮----
println!(&quot;Using provided AXUR_TOKEN, skipping login flow.&quot;);
⋮----
println!(&quot;No AXUR_TOKEN found, attempting normal login...&quot;);
perform_login(&amp;client).await?
⋮----
println!(&quot;Master Token acquired: {}...&quot;, &amp;master_token[..10]);
⋮----
let tenant_id = env::var(&quot;AXUR_TENANT_ID&quot;).unwrap_or_default();
if tenant_id.is_empty() {
println!(&quot;AXUR_TENANT_ID not set, fetching tenants to find one...&quot;);
⋮----
.get(format!(&quot;{}/customers/customers&quot;, API_URL))
.header(&quot;Authorization&quot;, format!(&quot;Bearer {}&quot;, master_token))
.send()
⋮----
println!(&quot;Tenants Response Status: {}&quot;, tenants_resp.status());
let body = tenants_resp.text().await?;
println!(&quot;{}&quot;, body);
return Ok(());
⋮----
println!(&quot;Probing Threat Hunting for Tenant: {}&quot;, tenant_id);
⋮----
let query = format!(&quot;domain=\&quot;{}\&quot;&quot;, &quot;example.com&quot;);
⋮----
println!(&quot;Starting search on {} with query: {}&quot;, source, query);
⋮----
let search_req = json!({
⋮----
let start_url = format!(&quot;{}/threat-hunting-api/external-search&quot;, API_URL);
⋮----
.post(&amp;start_url)
⋮----
.json(&amp;search_req)
⋮----
println!(&quot;POST Response Status: {}&quot;, start_resp.status());
let start_body = start_resp.text().await?;
println!(&quot;POST Response Body: {}&quot;, start_body);
⋮----
let start_json: serde_json::Value = serde_json::from_str(&amp;start_body).unwrap_or(json!({}));
⋮----
.as_str()
.or(start_json[&quot;id&quot;].as_str());
⋮----
println!(&quot;Got Search ID: {}&quot;, id);
⋮----
let poll_url = format!(
⋮----
println!(&quot;Polling GET: {}&quot;, poll_url);
⋮----
.get(&amp;poll_url)
⋮----
println!(&quot;GET Response Status: {}&quot;, poll_resp.status());
let poll_body = poll_resp.text().await?;
println!(&quot;GET Response Body: {}&quot;, poll_body);
⋮----
println!(&quot;Failed to get Search ID from response.&quot;);
⋮----
Ok(())
⋮----
async fn perform_login(client: &amp;reqwest::Client) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
let email_set = env::var(&quot;AXUR_EMAIL&quot;).is_ok();
let pass_set = env::var(&quot;AXUR_PASSWORD&quot;).is_ok();
println!(&quot;Env Check: EMAIL={}, PASSWORD={}&quot;, email_set, pass_set);
⋮----
return Err(&quot;Missing credentials in .env&quot;.into());
⋮----
let email = env::var(&quot;AXUR_EMAIL&quot;).unwrap();
let password = env::var(&quot;AXUR_PASSWORD&quot;).unwrap();
⋮----
println!(&quot;Authenticating as {}...&quot;, email);
⋮----
.post(format!(&quot;{}/identity/session&quot;, API_URL))
.json(&amp;json!({
⋮----
if !resp.status().is_success() {
eprintln!(&quot;Login failed: {}&quot;, resp.status());
let dry = resp.text().await?;
eprintln!(&quot;{}&quot;, dry);
return Err(&quot;Login failed&quot;.into());
⋮----
let auth_data: AxurAuthResponse = resp.json().await?;
let token = auth_data.token.unwrap();
let correlation = auth_data.correlation.unwrap();
⋮----
println!(
⋮----
print!(&quot;Enter 2FA Code: &quot;);
io::stdout().flush()?;
⋮----
io::stdin().read_line(&amp;mut code_input)?;
let code = code_input.trim();
⋮----
.post(format!(&quot;{}/identity/session/tfa&quot;, API_URL))
.header(&quot;Authorization&quot;, format!(&quot;Bearer {}&quot;, token))
.header(&quot;oxref-token&quot;, &amp;correlation)
.json(&amp;json!({ &quot;code&quot;: code }))
⋮----
eprintln!(&quot;2FA failed: {}&quot;, resp.text().await?);
return Err(&quot;2FA failed&quot;.into());
⋮----
let device_id = auth_data.device_id.unwrap();
⋮----
println!(&quot;Step 2 success. Device ID: {}&quot;, device_id);
⋮----
.header(&quot;Device-Id&quot;, &amp;device_id)
⋮----
eprintln!(&quot;Finalize failed: {}&quot;, resp.text().await?);
return Err(&quot;Finalize failed&quot;.into());
⋮----
let master_token = auth_data.token.ok_or(&quot;No master token&quot;)?;
⋮----
Ok(master_token)</file><file path="crates/core/src/api/retry.rs">use std::future::Future;
use std::time::Duration;
⋮----
pub type RetryCallback = Option&lt;Box&lt;dyn Fn(&amp;str) + Send + Sync&gt;&gt;;
⋮----
pub async fn with_retry&lt;F, Fut, T, E&gt;(
⋮----
with_retry_callback(operation, max_retries, operation_name, None).await
⋮----
pub async fn with_retry_callback&lt;F, Fut, T, E&gt;(
⋮----
match operation().await {
Ok(result) =&gt; return Ok(result),
⋮----
let delay_ms = DEFAULT_BASE_DELAY_MS * 2u64.pow(attempt);
⋮----
let msg = format!(
⋮----
cb(&amp;msg);
⋮----
return Err(e);
⋮----
pub async fn retry_api_call&lt;F, Fut, T&gt;(operation: F, operation_name: &amp;str) -&gt; anyhow::Result&lt;T&gt;
⋮----
with_retry(operation, DEFAULT_MAX_RETRIES, operation_name).await</file><file path="crates/core/src/build_error_temp.rs">922 |                     name: &quot;Phishing&quot;.into(),
⋮----
927 |                     name: &quot;Malware&quot;.into(),
⋮----
932 |                     name: &quot;Infostealer&quot;.into(),
⋮----
954 |                 top_sources: vec![],
⋮----
error: could not compile `axur-core` (lib) due to 10 previous errors</file><file path="crates/core/src/editor/mod.rs">mod placeholders;
mod storage;
mod types;</file><file path="crates/core/src/editor/placeholders.rs">pub struct PlaceholderDefinition {
⋮----
pub enum PlaceholderCategory {
⋮----
impl PlaceholderCategory {
pub fn display_name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
/// Get all available placeholder definitions with mock data
pub fn get_all_placeholders() -&gt; Vec&lt;PlaceholderDefinition&gt; {
⋮----
pub fn get_all_placeholders() -&gt; Vec&lt;PlaceholderDefinition&gt; {
vec![
// ==================
// DYNAMIC TEXT
⋮----
// DATA VISUALIZATIONS
⋮----
// TABLES
⋮----
// GEOSPATIAL
⋮----
// MEDIA
⋮----
// AI ANALYSIS
⋮----
/// Get placeholders by category
pub fn get_placeholders_by_category(category: PlaceholderCategory) -&gt; Vec&lt;PlaceholderDefinition&gt; {
⋮----
pub fn get_placeholders_by_category(category: PlaceholderCategory) -&gt; Vec&lt;PlaceholderDefinition&gt; {
get_all_placeholders()
.into_iter()
.filter(|p| p.category == category)
.collect()
⋮----
/// Get a single placeholder by key
pub fn get_placeholder(key: &amp;str) -&gt; Option&lt;PlaceholderDefinition&gt; {
⋮----
pub fn get_placeholder(key: &amp;str) -&gt; Option&lt;PlaceholderDefinition&gt; {
get_all_placeholders().into_iter().find(|p| p.key == key)
⋮----
mod tests {
⋮----
fn test_all_placeholders_have_mock() {
let placeholders = get_all_placeholders();
assert!(!placeholders.is_empty());
⋮----
assert!(
⋮----
fn test_get_by_category() {
let text_placeholders = get_placeholders_by_category(PlaceholderCategory::DynamicText);
assert!(text_placeholders.len() &gt;= 3);
⋮----
assert_eq!(p.category, PlaceholderCategory::DynamicText);
⋮----
fn test_get_single_placeholder() {
let risk = get_placeholder(&quot;risk_score_gauge&quot;);
assert!(risk.is_some());
assert_eq!(</file><file path="crates/core/src/editor/storage.rs">pub struct TemplateMetadata {
⋮----
pub fn get_user_template_path(tenant_id: &amp;str, template_id: &amp;str) -&gt; String {
format!(&quot;{}/{}/{}.json&quot;, USER_TEMPLATES_PATH, tenant_id, template_id)
⋮----
pub fn get_official_template_path(template_name: &amp;str) -&gt; String {
format!(&quot;{}/{}.json&quot;, OFFICIAL_TEMPLATES_PATH, template_name)
⋮----
pub fn get_marketplace_template_path(template_id: &amp;str) -&gt; String {
format!(&quot;{}/{}.json&quot;, MARKETPLACE_TEMPLATES_PATH, template_id)
⋮----
mod tests {
⋮----
fn test_user_template_path() {
let path = get_user_template_path(&quot;tenant-123&quot;, &quot;abc-def-ghi&quot;);
assert_eq!(path, &quot;templates/users/tenant-123/abc-def-ghi.json&quot;);
⋮----
fn test_official_template_path() {
let path = get_official_template_path(&quot;default&quot;);
assert_eq!(path, &quot;templates/official/default.json&quot;);
⋮----
fn test_marketplace_template_path() {
let path = get_marketplace_template_path(&quot;template-456&quot;);
assert_eq!(path, &quot;templates/marketplace/template-456.json&quot;);</file><file path="crates/core/src/editor/types.rs">use uuid::Uuid;
⋮----
pub struct PresentationTemplate {
⋮----
impl Default for PresentationTemplate {
fn default() -&gt; Self {
⋮----
name: &quot;Untitled Template&quot;.to_string(),
⋮----
version: &quot;1.0.0&quot;.to_string(),
⋮----
pub struct SlideDefinition {
⋮----
impl Default for SlideDefinition {
⋮----
name: &quot;New Slide&quot;.to_string(),
⋮----
pub enum LayoutType {
⋮----
pub enum Element {
⋮----
pub struct Position {
⋮----
pub struct Size {
⋮----
impl Default for Size {
⋮----
pub struct TextStyle {
⋮----
impl Default for TextStyle {
⋮----
font_family: &quot;Inter&quot;.to_string(),
⋮----
font_weight: &quot;normal&quot;.to_string(),
color: &quot;#333333&quot;.to_string(),
⋮----
pub enum TextAlign {
⋮----
pub struct Theme {
⋮----
impl Default for Theme {
⋮----
primary_color: &quot;#6366F1&quot;.to_string(),
secondary_color: &quot;#EC4899&quot;.to_string(),
background_color: &quot;#0F172A&quot;.to_string(),
text_color: &quot;#F8FAFC&quot;.to_string(),
⋮----
heading_font: &quot;Inter&quot;.to_string(),
⋮----
pub enum Background {
⋮----
impl Default for Background {
⋮----
color: &quot;#0F172A&quot;.to_string(),
⋮----
pub enum GradientDirection {
⋮----
pub enum ImageSource {
⋮----
pub enum ShapeType {
⋮----
pub struct ShapeStyle {
⋮----
impl Default for ShapeStyle {
⋮----
fill_color: &quot;#6366F1&quot;.to_string(),
stroke_color: &quot;#4F46E5&quot;.to_string(),
⋮----
pub enum ChartType {
⋮----
pub struct ChartStyle {
⋮----
impl Default for ChartStyle {
⋮----
colors: vec![
⋮----
mod tests {
⋮----
fn test_template_serialization() {
⋮----
let json = serde_json::to_string_pretty(&amp;template).unwrap();
let parsed: PresentationTemplate = serde_json::from_str(&amp;json).unwrap();
assert_eq!(template.name, parsed.name);
⋮----
fn test_slide_with_elements() {
⋮----
name: &quot;Test Slide&quot;.to_string(),
⋮----
elements: vec![
⋮----
let json = serde_json::to_string_pretty(&amp;slide).unwrap();
let parsed: SlideDefinition = serde_json::from_str(&amp;json).unwrap();
assert_eq!(slide.elements.len(), parsed.elements.len());
⋮----
fn test_element_variants() {
⋮----
content: &quot;Test&quot;.to_string(),
⋮----
let json = serde_json::to_string(&amp;text).unwrap();
assert!(json.contains(&quot;\&quot;type\&quot;:\&quot;text\&quot;&quot;));</file><file path="crates/core/src/error_codes.rs">pub enum ErrorModule {
⋮----
impl ErrorModule {
pub fn prefix(&amp;self) -&gt; &amp;&apos;static str {
⋮----
/// Structured error code with module and number
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorCode {
⋮----
/// Internal context (not shown to user, for dev debugging)
    #[serde(skip_serializing_if = &quot;Option::is_none&quot;)]
⋮----
impl ErrorCode {
pub fn new(module: ErrorModule, number: u16) -&gt; Self {
⋮----
pub fn with_context(mut self, ctx: impl Into&lt;String&gt;) -&gt; Self {
self.context = Some(ctx.into());
⋮----
/// Returns the formatted code (e.g., &quot;AUTH-001&quot;)
    pub fn code(&amp;self) -&gt; String {
⋮----
pub fn code(&amp;self) -&gt; String {
format!(&quot;{}-{:03}&quot;, self.module.prefix(), self.number)
⋮----
fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&apos;_&gt;) -&gt; std::fmt::Result {
write!(f, &quot;{}&quot;, self.code())
⋮----
pub mod auth {
⋮----
pub fn invalid_credentials() -&gt; ErrorCode {
⋮----
pub fn invalid_2fa() -&gt; ErrorCode {
⋮----
pub fn session_expired() -&gt; ErrorCode {
⋮----
pub fn missing_token() -&gt; ErrorCode {
⋮----
pub mod api {
⋮----
pub fn token_expired() -&gt; ErrorCode {
⋮----
pub fn tenant_not_found() -&gt; ErrorCode {
⋮----
pub fn rate_limited() -&gt; ErrorCode {
⋮----
pub fn invalid_response() -&gt; ErrorCode {
⋮----
pub fn endpoint_unavailable() -&gt; ErrorCode {
⋮----
pub mod report {
⋮----
pub fn no_data_in_period() -&gt; ErrorCode {
⋮----
pub fn no_incidents_for_evidence() -&gt; ErrorCode {
⋮----
pub fn slide_render_failed() -&gt; ErrorCode {
⋮----
pub fn invalid_date_range() -&gt; ErrorCode {
⋮----
pub mod threat_intel {
⋮----
pub fn dark_web_timeout() -&gt; ErrorCode {
⋮----
pub fn hunting_api_unavailable() -&gt; ErrorCode {
⋮----
pub fn no_credentials_found() -&gt; ErrorCode {
⋮----
pub fn search_cancelled() -&gt; ErrorCode {
⋮----
pub mod network {
⋮----
pub fn cors_blocked() -&gt; ErrorCode {
⋮----
pub fn connection_timeout() -&gt; ErrorCode {
⋮----
pub fn dns_failed() -&gt; ErrorCode {
⋮----
pub fn ssl_error() -&gt; ErrorCode {
⋮----
pub mod system {
⋮----
pub fn internal_error() -&gt; ErrorCode {
⋮----
pub fn config_error() -&gt; ErrorCode {
⋮----
pub fn resource_exhausted() -&gt; ErrorCode {
⋮----
pub enum ReportStep {
⋮----
impl ReportStep {
⋮----
pub fn progress(&amp;self, include_threat_intel: bool) -&gt; u8 {
⋮----
pub fn i18n_key(&amp;self) -&gt; &amp;&apos;static str {
⋮----
pub enum ProgressEvent {
⋮----
mod tests {
⋮----
fn test_error_code_format() {
⋮----
assert_eq!(code.code(), &quot;AUTH-001&quot;);
⋮----
assert_eq!(code.code(), &quot;TI-001&quot;);
⋮----
fn test_error_with_context() {
let code = api::token_expired().with_context(&quot;Token TTL exceeded by 300s&quot;);
assert_eq!(code.code(), &quot;API-001&quot;);
assert!(code.context.is_some());
⋮----
fn test_progress_percentage() {
assert_eq!(ReportStep::Connecting.progress(true), 10);
assert_eq!(ReportStep::SearchingDarkWeb.progress(true), 50);
assert_eq!(ReportStep::Complete.progress(true), 100);</file><file path="crates/core/src/errors.rs">use thiserror::Error;
⋮----
pub enum CliError {
⋮----
fn from(err: reqwest::Error) -&gt; Self {
if err.is_timeout() {
CliError::NetworkError(&quot;Request timed out&quot;.to_string())
} else if err.is_connect() {
CliError::NetworkError(&quot;Could not connect to server&quot;.to_string())
} else if let Some(status) = err.status() {
match status.as_u16() {
⋮----
_ =&gt; CliError::ApiError(format!(&quot;HTTP {}&quot;, status)),
⋮----
CliError::NetworkError(err.to_string())</file><file path="crates/core/src/i18n/compat.rs">use crate::i18n::legacy::Dictionary;
use crate::i18n::loader::Translations;
⋮----
pub struct TranslationCompat&lt;&apos;a&gt; {
/// New JSON-based translations (primary)
    translations: &amp;&apos;a Translations,
⋮----
/// Create a new compatibility wrapper
    pub fn new(translations: &amp;&apos;a Translations, dictionary: &amp;&apos;a dyn Dictionary) -&gt; Self {
⋮----
pub fn new(translations: &amp;&apos;a Translations, dictionary: &amp;&apos;a dyn Dictionary) -&gt; Self {
⋮----
/// Get a translation by key
    ///
⋮----
///
    /// Tries the new JSON system first, falls back to legacy if not found
⋮----
/// Tries the new JSON system first, falls back to legacy if not found
    pub fn get(&amp;self, key: &amp;str) -&gt; String {
⋮----
pub fn get(&amp;self, key: &amp;str) -&gt; String {
// Try new system first
let value = self.translations.get(key);
⋮----
// If we got a placeholder back (key not found), try legacy
if value.starts_with(&apos;[&apos;) &amp;&amp; value.ends_with(&apos;]&apos;) {
self.get_legacy(key)
⋮----
/// Get a translation with parameters
    pub fn format(&amp;self, key: &amp;str, params: &amp;[(&amp;str, &amp;str)]) -&gt; String {
⋮----
pub fn format(&amp;self, key: &amp;str, params: &amp;[(&amp;str, &amp;str)]) -&gt; String {
⋮----
let value = self.translations.format(key, params);
⋮----
// If we got a placeholder back, try legacy
⋮----
// Legacy doesn&apos;t support format, use as-is
⋮----
fn get_legacy(&amp;self, key: &amp;str) -&gt; String {
⋮----
&quot;label_tlp&quot; =&gt; self.dictionary.label_tlp(),
&quot;label_tlp_desc&quot; =&gt; self.dictionary.label_tlp_desc(),
&quot;label_company&quot; =&gt; self.dictionary.label_company(),
&quot;label_partner&quot; =&gt; self.dictionary.label_partner(),
&quot;cover_title_dynamic&quot; =&gt; self.dictionary.cover_title_dynamic(),
&quot;cover_title_static&quot; =&gt; self.dictionary.cover_title_static(),
&quot;intro_title&quot; =&gt; self.dictionary.intro_title(),
&quot;intro_text_dynamic&quot; =&gt; self.dictionary.intro_text_dynamic(),
&quot;intro_text_static&quot; =&gt; self.dictionary.intro_text_static(),
&quot;intro_text_closing&quot; =&gt; self.dictionary.intro_text_closing(),
⋮----
&quot;solutions_title&quot; =&gt; self.dictionary.solutions_title(),
&quot;solutions_subtitle_1&quot; =&gt; self.dictionary.solutions_subtitle_1(),
&quot;solutions_subtitle_2&quot; =&gt; self.dictionary.solutions_subtitle_2(),
&quot;solutions_subtitle_3&quot; =&gt; self.dictionary.solutions_subtitle_3(),
&quot;solution_takedown&quot; =&gt; self.dictionary.solution_takedown(),
&quot;solution_brand_protection&quot; =&gt; self.dictionary.solution_brand_protection(),
&quot;solution_threat_intel&quot; =&gt; self.dictionary.solution_threat_intel(),
⋮----
&quot;toc_title&quot; =&gt; self.dictionary.toc_title(),
⋮----
&quot;metrics_title&quot; =&gt; self.dictionary.metrics_title(),
&quot;metrics_total_tickets&quot; =&gt; self.dictionary.metrics_total_tickets(),
&quot;metrics_desc_tickets&quot; =&gt; self.dictionary.metrics_desc_tickets(),
&quot;eff_title&quot; =&gt; self.dictionary.eff_title(),
&quot;eff_text_speed&quot; =&gt; self.dictionary.eff_text_speed(),
⋮----
&quot;takedowns_title&quot; =&gt; self.dictionary.takedowns_title(),
&quot;takedowns_requested&quot; =&gt; self.dictionary.takedowns_requested(),
&quot;takedowns_success_rate&quot; =&gt; self.dictionary.takedowns_success_rate(),
&quot;takedowns_median_notify&quot; =&gt; self.dictionary.takedowns_median_notify(),
&quot;takedowns_median_uptime&quot; =&gt; self.dictionary.takedowns_median_uptime(),
&quot;takedowns_status_title&quot; =&gt; self.dictionary.takedowns_status_title(),
&quot;takedowns_solved&quot; =&gt; self.dictionary.takedowns_solved(),
&quot;takedowns_in_progress&quot; =&gt; self.dictionary.takedowns_in_progress(),
&quot;takedowns_interrupted&quot; =&gt; self.dictionary.takedowns_interrupted(),
&quot;takedowns_not_solved&quot; =&gt; self.dictionary.takedowns_not_solved(),
⋮----
&quot;op_badge&quot; =&gt; self.dictionary.op_badge(),
&quot;roi_title&quot; =&gt; self.dictionary.roi_title(),
&quot;op_time_saved_title&quot; =&gt; self.dictionary.op_time_saved_title(),
&quot;op_time_saved_desc&quot; =&gt; self.dictionary.op_time_saved_desc(),
&quot;op_capacity_title&quot; =&gt; self.dictionary.op_capacity_title(),
&quot;op_capacity_desc&quot; =&gt; self.dictionary.op_capacity_desc(),
&quot;op_response_title&quot; =&gt; self.dictionary.op_response_title(),
&quot;op_response_desc&quot; =&gt; self.dictionary.op_response_desc(),
&quot;op_unit_person_days&quot; =&gt; self.dictionary.op_unit_person_days(),
&quot;op_unit_hours&quot; =&gt; self.dictionary.op_unit_hours(),
⋮----
&quot;footer_text&quot; =&gt; self.dictionary.footer_text(),
⋮----
&quot;closing_title&quot; =&gt; self.dictionary.closing_title(),
&quot;closing_subtitle&quot; =&gt; self.dictionary.closing_subtitle(),
⋮----
_ =&gt; format!(&quot;[{}]&quot;, key),
⋮----
mod tests {
⋮----
use crate::i18n::legacy::English;
⋮----
fn test_compat_prefers_json() {
let translations = Translations::load(&quot;en&quot;).unwrap();
⋮----
let result = compat.get(&quot;footer_text&quot;);
assert!(!result.is_empty());
assert!(!result.starts_with(&apos;[&apos;));
⋮----
fn test_compat_falls_back_to_legacy() {
⋮----
let result = compat.get(&quot;solutions_title&quot;);</file><file path="crates/core/src/i18n/loader.rs">use serde::Deserialize;
use std::collections::HashMap;
⋮----
pub struct Translations {
⋮----
impl Translations {
⋮----
pub fn load(lang: &amp;str) -&gt; Result&lt;Self, TranslationError&gt; {
⋮----
&quot;en&quot; =&gt; include_str!(&quot;../../translations/en.json&quot;),
&quot;es&quot; =&gt; include_str!(&quot;../../translations/es.json&quot;),
&quot;pt-br&quot; =&gt; include_str!(&quot;../../translations/pt-br.json&quot;),
_ =&gt; return Err(TranslationError::UnknownLanguage(lang.to_string())),
⋮----
serde_json::from_str(json).map_err(TranslationError::ParseError)
⋮----
pub fn get(&amp;self, key: &amp;str) -&gt; String {
⋮----
.get(key)
.and_then(|v| v.as_str())
.map(|s| s.to_string())
.unwrap_or_else(|| format!(&quot;[MISSING: {}]&quot;, key))
⋮----
pub fn get_optional(&amp;self, key: &amp;str) -&gt; Option&lt;String&gt; {
⋮----
pub fn format(&amp;self, key: &amp;str, args: &amp;[(&amp;str, &amp;str)]) -&gt; String {
let mut result = self.get(key);
⋮----
result = result.replace(&amp;format!(&quot;{{{}}}&quot;, k), v);
⋮----
pub fn has_key(&amp;self, key: &amp;str) -&gt; bool {
self.data.contains_key(key)
⋮----
pub enum TranslationError {
⋮----
fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&apos;_&gt;) -&gt; std::fmt::Result {
⋮----
Self::UnknownLanguage(lang) =&gt; write!(f, &quot;Unknown language: {}&quot;, lang),
Self::ParseError(e) =&gt; write!(f, &quot;Failed to parse translations: {}&quot;, e),
⋮----
mod tests {
⋮----
fn test_load_english() {
let trans = Translations::load(&quot;en&quot;).expect(&quot;Failed to load English translations&quot;);
assert!(!trans.get(&quot;welcome_message&quot;).starts_with(&quot;[MISSING&quot;));
⋮----
fn test_get_existing_key() {
let trans = Translations::load(&quot;en&quot;).unwrap();
let msg = trans.get(&quot;welcome_message&quot;);
assert_eq!(msg, &quot;Welcome to Axur CLI&quot;);
⋮----
fn test_get_missing_key() {
⋮----
let msg = trans.get(&quot;nonexistent_key&quot;);
assert!(msg.starts_with(&quot;[MISSING:&quot;));
⋮----
fn test_get_optional() {
⋮----
assert!(trans.get_optional(&quot;welcome_message&quot;).is_some());
assert!(trans.get_optional(&quot;nonexistent_key&quot;).is_none());
⋮----
fn test_unknown_language() {
⋮----
assert!(result.is_err());</file><file path="crates/core/src/i18n/mod.rs">pub mod compat;
mod legacy;
mod loader;
⋮----
pub use compat::TranslationCompat;</file><file path="crates/core/src/plugins/builtin/google_slides.rs">use std::sync::Arc;
⋮----
pub struct SlideContent {
⋮----
pub enum SlideLayout {
⋮----
impl SlideLayout {
⋮----
pub fn to_google_layout(&amp;self) -&gt; &amp;&apos;static str {
⋮----
impl Default for SlideContent {
fn default() -&gt; Self {
⋮----
background_color: &quot;#0A0A0A&quot;.to_string(), // Axur dark
text_color: &quot;#FFFFFF&quot;.to_string(),       // White
⋮----
/// Service interface for Google API operations
/// Implemented by backend&apos;s GoogleServices
⋮----
/// Implemented by backend&apos;s GoogleServices
pub trait GoogleSlidesService: Send + Sync {
⋮----
pub trait GoogleSlidesService: Send + Sync {
⋮----
pub struct GoogleSlidesExportPlugin {
⋮----
impl GoogleSlidesExportPlugin {
⋮----
pub fn new() -&gt; Self {
⋮----
pub fn with_service(service: Arc&lt;dyn GoogleSlidesService&gt;) -&gt; Self {
⋮----
service: Some(service),
⋮----
pub fn parse_slide_html(slide: &amp;SlideOutput) -&gt; SlideContent {
⋮----
let (bg, text) = if html.contains(&quot;bg-black&quot;) || html.contains(&quot;bg-zinc&quot;) {
(&quot;#0A0A0A&quot;.to_string(), &quot;#FFFFFF&quot;.to_string())
⋮----
(&quot;#FFFFFF&quot;.to_string(), &quot;#18181B&quot;.to_string())
⋮----
fn extract_title(html: &amp;str) -&gt; String {
⋮----
let open = format!(&quot;&lt;{}&quot;, tag);
let close = format!(&quot;&lt;/{}&gt;&quot;, tag);
⋮----
if let Some(start) = html.find(&amp;open) {
if let Some(tag_end) = html[start..].find(&apos;&gt;&apos;) {
⋮----
if let Some(end) = html[content_start..].find(&amp;close) {
⋮----
fn extract_body_text(html: &amp;str) -&gt; Vec&lt;String&gt; {
⋮----
while let Some(p_start) = html[search_start..].find(&quot;&lt;p&quot;) {
⋮----
if let Some(tag_end) = html[abs_start..].find(&apos;&gt;&apos;) {
⋮----
if let Some(p_end) = html[content_start..].find(&quot;&lt;/p&gt;&quot;) {
⋮----
let text = Self::strip_html_tags(raw).trim().to_string();
if !text.is_empty() &amp;&amp; text.len() &gt; 10 {
paragraphs.push(text);
⋮----
paragraphs.truncate(5);
⋮----
fn strip_html_tags(html: &amp;str) -&gt; String {
⋮----
for c in html.chars() {
⋮----
_ if !in_tag =&gt; result.push(c),
⋮----
.replace(&quot;&amp;nbsp;&quot;, &quot; &quot;)
.replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;)
.replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;)
.replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;)
.replace(&quot;&amp;quot;&quot;, &quot;\&quot;&quot;)
⋮----
fn determine_layout(slide_id: &amp;str) -&gt; SlideLayout {
⋮----
impl Default for GoogleSlidesExportPlugin {
⋮----
impl CloudExportPlugin for GoogleSlidesExportPlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn provider(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn display_name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn export(&amp;self, slides: &amp;[SlideOutput], title: &amp;str) -&gt; Result&lt;CloudExportOutput, String&gt; {
⋮----
.as_ref()
.ok_or(&quot;Google Slides service not configured. Please check Google API credentials.&quot;)?;
⋮----
let presentation_id = service.create_presentation(title)?;
⋮----
let slide_contents: Vec&lt;SlideContent&gt; = slides.iter().map(Self::parse_slide_html).collect();
⋮----
service.add_slides(&amp;presentation_id, &amp;slide_contents)?;
⋮----
let url = service.get_presentation_url(&amp;presentation_id);
⋮----
Ok(CloudExportOutput {
⋮----
provider: &quot;google_slides&quot;.to_string(),
⋮----
slides_count: slides.len(),
⋮----
mod tests {
⋮----
fn test_extract_title() {
⋮----
assert_eq!(title, &quot;My Title&quot;);
⋮----
fn test_extract_body() {
⋮----
assert_eq!(body.len(), 2); // Short one should be filtered
⋮----
fn test_strip_tags() {
⋮----
assert_eq!(text, &quot;Hello World&quot;);
⋮----
fn test_layout_mapping() {
assert_eq!(SlideLayout::Title.to_google_layout(), &quot;TITLE&quot;);
assert_eq!(</file><file path="crates/core/src/plugins/builtin/kill_chain.rs">use super::helpers::footer_dark;
⋮----
pub struct KillChainSlidePlugin;
⋮----
impl SlidePlugin for KillChainSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
.iter()
.any(|td| td.request_date.is_some() &amp;&amp; td.resolution_date.is_some())
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
.filter(|td| td.request_date.is_some() &amp;&amp; td.resolution_date.is_some())
.map(|td| {
⋮----
td.request_date.is_some(),
td.resolution_date.is_some(),
!td.host.is_empty(),
!td.ticket_type.is_empty(),
⋮----
.filter(|&amp;&amp;x| x)
.count();
⋮----
.collect();
⋮----
candidates.sort_by(|a, b| b.1.cmp(&amp;a.1));
⋮----
let cases: Vec&lt;_&gt; = candidates.into_iter().take(2).map(|(td, _)| td).collect();
⋮----
let cases_html: String = cases.iter().enumerate().map(|(idx, td)| {
let threat_label = match td.ticket_type.as_str() {
⋮----
let threat_color = match td.ticket_type.as_str() {
⋮----
d.as_ref()
.map(|s| {
⋮----
if s.len() &gt;= 10 { s[..10].to_string() } else { s.clone() }
⋮----
.unwrap_or_else(|| &quot;—&quot;.to_string())
⋮----
let request_date = fmt_date(&amp;td.request_date);
let resolution_date = fmt_date(&amp;td.resolution_date);
⋮----
compute_duration_label(req, res)
⋮----
&quot;—&quot;.to_string()
⋮----
let host_display = if td.host.len() &gt; 35 {
format!(&quot;{}...&quot;, &amp;td.host[..32])
} else if td.host.is_empty() {
⋮----
td.host.clone()
⋮----
format!(
⋮----
}).collect();
⋮----
// ─── Summary stats ───
let total_resolved = data.resolved_takedowns.len();
⋮----
Some(&quot;Seguimiento completo de casos reales: cada fase del proceso de takedown documentada.&quot;),
⋮----
let html = format!(
⋮----
vec![SlideOutput {
⋮----
fn compute_duration_label(start: &amp;str, end: &amp;str) -&gt; String {
⋮----
let date_part = if s.len() &gt;= 10 { &amp;s[..10] } else { s };
chrono::NaiveDate::parse_from_str(date_part, &quot;%Y-%m-%d&quot;).ok()
⋮----
if let (Some(start_d), Some(end_d)) = (parse_date(start), parse_date(end)) {
let days = (end_d - start_d).num_days();
⋮----
&quot;&lt; 24h&quot;.to_string()
⋮----
&quot;1 día&quot;.to_string()
⋮----
format!(&quot;{} días&quot;, days)
⋮----
format!(&quot;{} semanas&quot;, days / 7)
⋮----
format!(&quot;{} meses&quot;, days / 30)</file><file path="crates/core/src/plugins/builtin/solutions.rs">pub struct SolutionsSlidePlugin;
⋮----
impl SlidePlugin for SolutionsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let html = format!(
⋮----
vec![SlideOutput {
⋮----
impl SolutionsSlidePlugin {
fn footer_dark(page: u32, footer_text: &amp;str) -&gt; String {
format!(</file><file path="crates/core/src/plugins/builtin/threat_intel.rs">pub struct ThreatIntelSlidePlugin;
⋮----
impl SlidePlugin for ThreatIntelSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
.iter()
.take(5)
.map(|s| format!(r#&quot;&lt;li class=&quot;text-zinc-300 text-sm&quot;&gt;{}&lt;/li&gt;&quot;#, s))
.collect();
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/velocity.rs">use super::helpers::footer_dark;
⋮----
pub struct VelocitySlidePlugin;
⋮----
impl SlidePlugin for VelocitySlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
if let Some(hours) = compute_hours_between(req, res) {
⋮----
total.saturating_sub(bucket_lt1h + bucket_1_6h + bucket_6_24h + bucket_1_3d);
⋮----
let total_dist = with_dates.max(1);
⋮----
let under_24h_pct = pct(bucket_lt1h) + pct(bucket_1_6h) + pct(bucket_6_24h);
⋮----
(&quot;&lt; 1 hora&quot;, bucket_lt1h, pct(bucket_lt1h), &quot;emerald&quot;),
(&quot;1 — 6 horas&quot;, bucket_1_6h, pct(bucket_1_6h), &quot;emerald&quot;),
(&quot;6 — 24 horas&quot;, bucket_6_24h, pct(bucket_6_24h), &quot;blue&quot;),
(&quot;1 — 3 días&quot;, bucket_1_3d, pct(bucket_1_3d), &quot;orange&quot;),
(&quot;&gt; 3 días&quot;, bucket_gt3d, pct(bucket_gt3d), &quot;red&quot;),
⋮----
let dist_html: String = dist_bars.iter().map(|(label, count, pct, color)| {
format!(
⋮----
}).collect();
⋮----
// ─── Hero metrics ───
⋮----
Some(&quot;Distribución del tiempo de vida de las amenazas eliminadas y métricas de velocidad operativa.&quot;),
⋮----
let html = format!(
⋮----
vec![SlideOutput {
⋮----
fn compute_hours_between(start: &amp;str, end: &amp;str) -&gt; Option&lt;f64&gt; {
⋮----
let date_part = if s.len() &gt;= 10 { &amp;s[..10] } else { s };
chrono::NaiveDate::parse_from_str(date_part, &quot;%Y-%m-%d&quot;).ok()
⋮----
if let (Some(start_d), Some(end_d)) = (parse_date(start), parse_date(end)) {
let days = (end_d - start_d).num_days();
Some(days as f64 * 24.0)</file><file path="crates/core/src/pptx_mapper.rs">use crate::api::report::PocReportData;
use std::collections::HashMap;
⋮----
fn format_number(n: u64) -&gt; String {
let s = n.to_string();
⋮----
for (i, c) in s.chars().rev().enumerate() {
⋮----
result.push(&apos;,&apos;);
⋮----
result.push(c);
⋮----
result.chars().rev().collect()
⋮----
pub fn map_placeholders(data: &amp;PocReportData) -&gt; HashMap&lt;String, String&gt; {
⋮----
map.insert(&quot;company_name&quot;.into(), data.company_name.clone());
map.insert(
&quot;partner_name&quot;.into(),
data.partner_name.clone().unwrap_or_default(),
⋮----
map.insert(&quot;tlp_level&quot;.into(), data.tlp_level.clone());
⋮----
&quot;date_range&quot;.into(),
format!(&quot;{} - {}&quot;, data.start_date, data.end_date),
⋮----
map.insert(&quot;start_date&quot;.into(), data.start_date.clone());
map.insert(&quot;end_date&quot;.into(), data.end_date.clone());
⋮----
map.insert(&quot;total_tickets&quot;.into(), format_number(data.total_tickets));
map.insert(&quot;total_threats&quot;.into(), format_number(data.total_threats));
⋮----
map.insert(&quot;hours_saved&quot;.into(), format!(&quot;{}&quot;, hours_saved));
map.insert(&quot;analysts_equivalent&quot;.into(), format!(&quot;{:.1}&quot;, analysts));
⋮----
&quot;validation_hours&quot;.into(),
format!(&quot;{:.1}h&quot;, data.validation_hours),
⋮----
if let Some(t1) = data.threats_by_type.first() {
map.insert(&quot;top_threat_1_name&quot;.into(), t1.threat_type.clone());
map.insert(&quot;top_threat_1_count&quot;.into(), format_number(t1.count));
⋮----
if let Some(t2) = data.threats_by_type.get(1) {
map.insert(&quot;top_threat_2_name&quot;.into(), t2.threat_type.clone());
map.insert(&quot;top_threat_2_count&quot;.into(), format_number(t2.count));
⋮----
if let Some(t3) = data.threats_by_type.get(2) {
map.insert(&quot;top_threat_3_name&quot;.into(), t3.threat_type.clone());
map.insert(&quot;top_threat_3_count&quot;.into(), format_number(t3.count));
⋮----
.iter()
.take(5)
.map(|t| format!(&quot;{}: {}&quot;, t.threat_type, format_number(t.count)))
⋮----
.join(&quot;\n&quot;);
map.insert(&quot;threats_by_type&quot;.into(), threats_list);
⋮----
&quot;credentials_total&quot;.into(),
format_number(data.credentials_total),
⋮----
&quot;credentials_critical&quot;.into(),
format!(&quot;{}&quot;, data.critical_credentials.len()),
⋮----
&quot;stealer_log_count&quot;.into(),
format_number(data.threat_intelligence.stealer_log_count),
⋮----
&quot;stealer_log_percent&quot;.into(),
format!(&quot;{:.1}%&quot;, data.threat_intelligence.stealer_log_percent),
⋮----
&quot;plain_password_count&quot;.into(),
format_number(data.threat_intelligence.plain_password_count),
⋮----
&quot;plain_password_percent&quot;.into(),
format!(&quot;{:.1}%&quot;, data.threat_intelligence.plain_password_percent),
⋮----
map.insert(&quot;unique_hosts&quot;.into(), format_number(data.unique_hosts));
⋮----
&quot;high_risk_users&quot;.into(),
format_number(data.high_risk_users),
⋮----
map.insert(&quot;takedown_total&quot;.into(), format_number(takedown_total));
⋮----
&quot;takedown_resolved&quot;.into(),
format_number(data.takedown_resolved),
⋮----
&quot;takedown_pending&quot;.into(),
format_number(data.takedown_pending),
⋮----
&quot;takedown_aborted&quot;.into(),
format_number(data.takedown_aborted),
⋮----
&quot;takedown_unresolved&quot;.into(),
format_number(data.takedown_unresolved),
⋮----
&quot;takedown_success_rate&quot;.into(),
format!(&quot;{:.1}%&quot;, data.takedown_success_rate),
⋮----
&quot;takedown_median_notify&quot;.into(),
data.takedown_median_time_to_notify.clone(),
⋮----
&quot;takedown_median_uptime&quot;.into(),
data.takedown_median_uptime.clone(),
⋮----
&quot;roi_hours_total&quot;.into(),
format!(&quot;{:.0}&quot;, data.roi_metrics.hours_saved_total),
⋮----
&quot;roi_person_days&quot;.into(),
format!(&quot;{:.0}&quot;, data.roi_metrics.person_days_saved),
⋮----
&quot;roi_hours_validation&quot;.into(),
format!(&quot;{:.0}h&quot;, data.roi_metrics.hours_saved_validation),
⋮----
&quot;roi_hours_monitoring&quot;.into(),
format!(&quot;{:.0}h&quot;, data.roi_metrics.hours_saved_credentials),
⋮----
&quot;roi_hours_takedowns&quot;.into(),
format!(&quot;{:.0}h&quot;, data.roi_metrics.hours_saved_takedowns),
⋮----
&quot;roi_analysts_monthly&quot;.into(),
format!(&quot;{:.1}&quot;, data.roi_metrics.analysts_equivalent_monthly),
⋮----
&quot;risk_score_value&quot;.into(),
format!(&quot;{:.0}&quot;, data.risk_score.current),
⋮----
map.insert(&quot;risk_score_label&quot;.into(), data.risk_score.label.clone());
⋮----
map.insert(&quot;secrets_total&quot;.into(), format_number(data.secrets_total));
map.insert(&quot;unique_repos&quot;.into(), format_number(data.unique_repos));
⋮----
&quot;production_secrets&quot;.into(),
format_number(data.production_secrets),
⋮----
&quot;dark_web_mentions&quot;.into(),
format_number(data.threat_intelligence.dark_web_mentions),
⋮----
&quot;chat_group_shares&quot;.into(),
format_number(data.threat_intelligence.chat_group_shares),
⋮----
&quot;social_media_mentions&quot;.into(),
format_number(data.threat_intelligence.social_media_mentions),
⋮----
&quot;paid_ads_detected&quot;.into(),
format_number(data.threat_intelligence.paid_ads_detected),
⋮----
mod tests {
⋮----
fn test_format_number() {
assert_eq!(format_number(0), &quot;0&quot;);
assert_eq!(format_number(100), &quot;100&quot;);
assert_eq!(format_number(1234), &quot;1,234&quot;);
assert_eq!(format_number(1234567), &quot;1,234,567&quot;);</file><file path="crates/core/src/report/render_data_exposure_slide_snippet.rs">fn render_data_exposure_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
let critical_html = if !data.critical_credentials.is_empty() {
let count = data.critical_credentials.len();
let examples: String = data.critical_credentials.iter().take(3).map(|c| {
let user = c.user.as_deref().unwrap_or(&quot;unknown&quot;);
let pass = c.password.as_deref().unwrap_or(&quot;***&quot;);
let masked_pass = if pass.len() &gt; 4 {
format!(&quot;{}...{}&quot;, &amp;pass[..2], &amp;pass[pass.len()-2..])
⋮----
&quot;***&quot;.to_string()
⋮----
format!(
⋮----
}).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;&quot;);</file><file path="crates/core/src/plugins/builtin/ai_intent.rs">use super::helpers::footer_dark;
⋮----
use std::collections::HashMap;
⋮----
pub struct AiIntentSlidePlugin;
⋮----
impl SlidePlugin for AiIntentSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.threats_by_type.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let cat = match threat.threat_type.as_str() {
⋮----
*intents.entry(cat).or_insert(0) += threat.count;
⋮----
let total: u64 = intents.values().sum();
⋮----
.iter()
.max_by_key(|(_, c)| *c)
.map(|(k, v)| (*k, *v))
.unwrap_or((&quot;other&quot;, 0));
⋮----
&quot;trust&quot; =&gt; t.get(&quot;intent_cat_trust&quot;),
&quot;compromised&quot; =&gt; t.get(&quot;intent_cat_compromised&quot;),
&quot;data_leak&quot; =&gt; t.get(&quot;intent_cat_data_leak&quot;),
_ =&gt; t.get(&quot;intent_cat_other&quot;),
⋮----
let bars_html: String = intents.iter().map(|(cat, count)| {
⋮----
&quot;trust&quot; =&gt; (t.get(&quot;intent_cat_trust&quot;), &quot;#f97316&quot;, &quot;rgba(249, 115, 22, 0.15)&quot;),
&quot;compromised&quot; =&gt; (t.get(&quot;intent_cat_compromised&quot;), &quot;#ef4444&quot;, &quot;rgba(239, 68, 68, 0.15)&quot;),
&quot;data_leak&quot; =&gt; (t.get(&quot;intent_cat_data_leak&quot;), &quot;#eab308&quot;, &quot;rgba(234, 179, 8, 0.15)&quot;),
_ =&gt; (t.get(&quot;intent_cat_other&quot;), &quot;#6b7280&quot;, &quot;rgba(107, 114, 128, 0.15)&quot;),
⋮----
format!(
⋮----
}).collect();
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/style_showcase.rs">pub struct StyleShowcasePlugin;
⋮----
impl SlidePlugin for StyleShowcasePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
fn generate_slides(&amp;self, _ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/mod.rs">mod registry;
mod traits;
⋮----
pub mod builtin;</file><file path="crates/core/src/plugins/traits.rs">use crate::api::report::PocReportData;
use crate::i18n::Translations;
⋮----
pub struct SlideOutput {
⋮----
pub struct PluginContext&lt;&apos;a&gt; {
/// Report data from API
    pub data: &amp;&apos;a PocReportData,
⋮----
/// Tenant name for customization
    pub tenant_name: &amp;&apos;a str,
⋮----
pub enum ThemeMode {
⋮----
pub struct PluginConfig {
⋮----
impl PluginConfig {
⋮----
pub fn new() -&gt; Self {
⋮----
pub fn with_theme(mut self, theme: ThemeMode) -&gt; Self {
⋮----
pub fn disable_plugins(mut self, plugins: Vec&lt;String&gt;) -&gt; Self {
⋮----
pub fn is_plugin_enabled(&amp;self, plugin_id: &amp;str) -&gt; bool {
!self.disabled_plugins.contains(&amp;plugin_id.to_string())
⋮----
pub trait SlidePlugin: Send + Sync {
⋮----
/// Human-readable name
    fn name(&amp;self) -&gt; &amp;&apos;static str;
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, _ctx: &amp;PluginContext) -&gt; bool {
⋮----
pub trait DataPlugin: Send + Sync {
⋮----
/// Transform/enrich the report data
    fn transform(&amp;self, data: &amp;mut PocReportData);
⋮----
/// Priority (higher = runs first)
    fn priority(&amp;self) -&gt; i32 {
⋮----
/// Plugin that provides custom export formats
pub trait ExportPlugin: Send + Sync {
⋮----
pub trait ExportPlugin: Send + Sync {
/// Unique identifier
    fn id(&amp;self) -&gt; &amp;&apos;static str;
⋮----
/// Export slides to bytes
    fn export(&amp;self, slides: &amp;[SlideOutput]) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt;;
⋮----
// =====================================================
// CLOUD EXPORT PLUGINS
⋮----
/// Output from a cloud export plugin
#[derive(Debug, Clone)]
pub struct CloudExportOutput {
/// Public URL to the exported presentation
    pub url: String,
/// Cloud provider identifier (e.g., &quot;google_slides&quot;, &quot;onedrive&quot;)
    pub provider: String,
/// Provider&apos;s resource ID (e.g., Google Slides presentation ID)
    pub resource_id: String,
⋮----
pub trait CloudExportPlugin: Send + Sync {
⋮----
/// Cloud provider name (e.g., &quot;google_slides&quot;, &quot;onedrive&quot;)
    fn provider(&amp;self) -&gt; &amp;&apos;static str;</file><file path="crates/core/src/report/language_switcher.rs">pub fn embed_translations_json() -&gt; String {
let en_json = include_str!(&quot;../../translations/en.json&quot;);
let es_json = include_str!(&quot;../../translations/es.json&quot;);
let pt_json = include_str!(&quot;../../translations/pt-br.json&quot;);
⋮----
format!(
⋮----
/// Generates the floating language selector UI with inline onclick handlers
pub fn language_selector_ui(current_lang: &amp;str) -&gt; String {
⋮----
pub fn language_selector_ui(current_lang: &amp;str) -&gt; String {
⋮----
.iter()
.map(|(code, label)| {
⋮----
.collect();
⋮----
/// Generates the JavaScript code for language switching
/// Uses a self-executing pattern that works even with innerHTML insertion
⋮----
/// Uses a self-executing pattern that works even with innerHTML insertion
pub fn language_switcher_script() -&gt; String {
⋮----
pub fn language_switcher_script() -&gt; String {
// This script uses setTimeout(0) to defer execution and ensure it runs
// even when inserted via innerHTML. The logic is all self-contained.
⋮----
&lt;/script&gt;&quot;#.to_string()
⋮----
/// Generates the complete language switching components for HTML reports
///
⋮----
///
/// Returns a tuple of (head_content, body_start_content, body_end_content)
⋮----
/// Returns a tuple of (head_content, body_start_content, body_end_content)
pub fn generate_language_switching_components(current_lang: &amp;str) -&gt; (String, String, String) {
⋮----
pub fn generate_language_switching_components(current_lang: &amp;str) -&gt; (String, String, String) {
let head = &quot;&quot;.to_string(); // No head content needed
let body_start = language_selector_ui(current_lang);
let body_end = format!(</file><file path="crates/core/src/templates/mod.rs">use crate::plugins::ThemeMode;
⋮----
pub enum IndustryTemplate {
⋮----
impl IndustryTemplate {
⋮----
pub fn from_str(s: &amp;str) -&gt; Self {
match s.to_lowercase().as_str() {
⋮----
pub fn display_name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
/// Default plugins to ENABLE for this template
    /// (all others will be disabled)
⋮----
/// (all others will be disabled)
    pub fn enabled_plugins(&amp;self) -&gt; Vec&lt;&amp;&apos;static str&gt; {
⋮----
pub fn enabled_plugins(&amp;self) -&gt; Vec&lt;&amp;&apos;static str&gt; {
⋮----
Self::General =&gt; vec![
⋮----
Self::Fintech =&gt; vec![
⋮----
Self::Retail =&gt; vec![
⋮----
Self::Healthcare =&gt; vec![
⋮----
pub fn disabled_plugins(&amp;self) -&gt; Vec&lt;String&gt; {
let all_plugins = vec![
⋮----
let enabled = self.enabled_plugins();
⋮----
.into_iter()
.filter(|p| !enabled.contains(p))
.map(|s| s.to_string())
.collect()
⋮----
pub fn theme(&amp;self) -&gt; ThemeMode {
⋮----
pub fn accent_color(&amp;self) -&gt; &amp;&apos;static str {
⋮----
Self::General =&gt; &quot;#FF671F&quot;,    // Axur orange
Self::Fintech =&gt; &quot;#10B981&quot;,    // Emerald green (trust/money)
Self::Retail =&gt; &quot;#8B5CF6&quot;,     // Purple (brand)
Self::Healthcare =&gt; &quot;#0EA5E9&quot;, // Blue (medical)
⋮----
/// Description for UI tooltip
    pub fn description(&amp;self) -&gt; &amp;&apos;static str {
⋮----
pub fn description(&amp;self) -&gt; &amp;&apos;static str {
⋮----
mod tests {
⋮----
fn test_from_str() {
assert_eq!(
⋮----
fn test_disabled_plugins() {
⋮----
let disabled = fintech.disabled_plugins();
assert!(disabled.contains(&amp;&quot;builtin.geospatial&quot;.to_string()));
assert!(!disabled.contains(&amp;&quot;builtin.exposure&quot;.to_string()));</file><file path="crates/core/src/plugins/builtin/comparative.rs">pub struct ComparativeSlidePlugin;
⋮----
impl SlidePlugin for ComparativeSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
ctx.data.comparison.is_some() &amp;&amp; ctx.config.is_plugin_enabled(self.id())
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let prev = data.comparison.as_ref();
⋮----
let tickets_delta = calc_delta(current_tickets, prev_tickets);
let takedowns_delta = calc_delta(current_takedowns, prev_takedowns);
let credentials_delta = calc_delta(current_credentials, prev_credentials);
⋮----
let efficiency_delta = calc_delta(hours_current, hours_prev);
⋮----
let title = t.get(&quot;comparative_title&quot;);
⋮----
Some(&quot;Evolución de indicadores clave respecto al periodo anterior.&quot;),
⋮----
let html = format!(
⋮----
vec![SlideOutput {
⋮----
struct Delta {
⋮----
fn calc_delta(current: u64, previous: u64) -&gt; Delta {
⋮----
percent: percent.abs(),
⋮----
fn calc_bar_width(current: u64, previous: u64) -&gt; u32 {
let max = current.max(previous);
⋮----
((current as f64 / max as f64) * 100.0).min(100.0) as u32
⋮----
fn delta_badge(delta: &amp;Delta) -&gt; String {
⋮----
format!(
⋮----
fn delta_badge_inverted(delta: &amp;Delta) -&gt; String {
// For credentials, increase is BAD
⋮----
fn generate_summary(tickets: &amp;Delta, takedowns: &amp;Delta, credentials: &amp;Delta) -&gt; String {
⋮----
parts.push(format!(
⋮----
parts.push(format!(&quot;Las amenazas disminuyeron {:.0}%&quot;, tickets.percent));
⋮----
parts.push(format!(&quot;Los takedowns mejoraron {:.0}%&quot;, takedowns.percent));
⋮----
parts.push(&quot;se recomienda revisar fuentes de filtración&quot;.to_string());
⋮----
parts.join(&quot;. &quot;) + &quot;.&quot;
⋮----
mod tests {
⋮----
fn test_calc_delta() {
let delta = calc_delta(110, 100);
assert!(delta.is_increase);
assert!((delta.percent - 10.0).abs() &lt; 0.1);
⋮----
let delta = calc_delta(90, 100);
assert!(!delta.is_increase);
⋮----
fn test_plugin_metadata() {
⋮----
assert_eq!(plugin.id(), &quot;builtin.comparative&quot;);
assert_eq!(plugin.priority(), 85);</file><file path="crates/core/src/plugins/builtin/credentials.rs">pub struct CredentialsSlidePlugin;
⋮----
impl SlidePlugin for CredentialsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.credential_exposures.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let total = data.credential_exposures.len();
let critical = data.critical_credentials.len();
⋮----
let examples_html: String = data.credential_exposures.iter().take(5).map(|cred| {
let user = cred.user.as_deref().unwrap_or(&quot;unknown&quot;);
let chars: Vec&lt;char&gt; = user.chars().collect();
let masked_user = if chars.len() &gt; 6 {
let first: String = chars[..3].iter().collect();
let last: String = chars[chars.len()-2..].iter().collect();
format!(&quot;{}...{}&quot;, first, last)
⋮----
user.to_string()
⋮----
let source = cred.leak_name.as_deref().unwrap_or(&quot;unknown&quot;);
format!(
⋮----
}).collect();
⋮----
.iter()
.filter(|c| {
⋮----
.as_deref()
.map(|n| n.to_lowercase().contains(&quot;stealer&quot;))
.unwrap_or(false)
⋮----
.count() as u64
⋮----
&amp;t.get(&quot;cred_title&quot;),
Some(&quot;Credenciales de su organización detectadas en filtraciones y logs de malware stealer.&quot;)
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/helpers.rs">pub fn format_number(n: u64) -&gt; String {
let s = n.to_string();
let chars: Vec&lt;char&gt; = s.chars().rev().collect();
⋮----
for (i, c) in chars.iter().enumerate() {
⋮----
result.push(&apos;,&apos;);
⋮----
result.push(*c);
⋮----
result.chars().rev().collect()
⋮----
pub fn footer_dark(page: usize, footer_text: &amp;str) -&gt; String {
format!(
⋮----
/// Light footer (for light backgrounds)
pub fn footer_light(page: u32, footer_text: &amp;str) -&gt; String {
⋮----
pub fn footer_light(page: u32, footer_text: &amp;str) -&gt; String {
⋮----
/// Axur logo SVG
pub fn axur_logo() -&gt; &amp;&apos;static str {
⋮----
pub fn axur_logo() -&gt; &amp;&apos;static str {
⋮----
/// Cover pattern: Portal-style gradient with Axur signature elements
/// Uses the /// slash motif and cyber gradient aesthetic
⋮----
/// Uses the /// slash motif and cyber gradient aesthetic
pub fn cover_pattern() -&gt; &amp;&apos;static str {
⋮----
pub fn cover_pattern() -&gt; &amp;&apos;static str {
⋮----
/// Format a chrono DateTime to a display string
pub fn format_date(date: &amp;Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;) -&gt; String {
⋮----
pub fn format_date(date: &amp;Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;) -&gt; String {
date.map(|d| d.format(&quot;%Y-%m-%d&quot;).to_string())
.unwrap_or_else(|| &quot;N/A&quot;.to_string())</file><file path="crates/core/src/plugins/builtin/poc_data.rs">pub struct PocDataSlidePlugin;
⋮----
impl SlidePlugin for PocDataSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
struct AssetGroup {
⋮----
.iter()
.map(|a| {
format!(
⋮----
.collect();
⋮----
// ─── Brand Nodes (Orbit 1) ───
// Position top 3 brands in a triangle layout around the core
⋮----
.take(3)
.enumerate()
.map(|(i, brand)| {
// Calculate position on a circle (radius 160px)
// -90deg is top (0), then 30 (1), 150 (2) for 3 items
⋮----
let angle_rad = angle_deg.to_radians();
⋮----
let x = radius * angle_rad.cos();
let y = radius * angle_rad.sin();
⋮----
angle = angle_deg + 180.0 // Line points inward
⋮----
// ─── Radar Scan SVG ───
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/report/template_renderer.rs">use std::collections::HashMap;
⋮----
pub fn resolve_placeholders(template_json: &amp;str, values: &amp;HashMap&lt;String, String&gt;) -&gt; String {
let mut result = template_json.to_string();
⋮----
let pattern = format!(&quot;{{{{{}}}}}&quot;, key);
result = result.replace(&amp;pattern, value);
⋮----
pub fn get_mock_placeholder_values() -&gt; HashMap&lt;String, String&gt; {
⋮----
values.insert(&quot;company_name&quot;.to_string(), &quot;ACME Corporation&quot;.to_string());
values.insert(
&quot;report_date_range&quot;.to_string(),
&quot;Dec 1 - Dec 31, 2024&quot;.to_string(),
⋮----
&quot;total_incidents&quot;.to_string(),
r#&quot;&lt;span style=&quot;font-size:48px;font-weight:bold;color:#6366F1;&quot;&gt;247&lt;/span&gt;&quot;#.to_string(),
⋮----
&quot;total_takedowns&quot;.to_string(),
r#&quot;&lt;span style=&quot;font-size:48px;font-weight:bold;color:#10B981;&quot;&gt;189&lt;/span&gt;&quot;#.to_string(),
⋮----
&quot;avg_takedown_time&quot;.to_string(),
r#&quot;&lt;span style=&quot;font-size:36px;color:#F59E0B;&quot;&gt;4.2h&lt;/span&gt;&quot;#.to_string(),
⋮----
values.insert(&quot;risk_score_gauge&quot;.to_string(), r#&quot;&lt;div style=&quot;text-align:center;padding:20px;&quot;&gt;
⋮----
&lt;/div&gt;&quot;#.to_string());
⋮----
values.insert(&quot;incidents_chart&quot;.to_string(), r#&quot;&lt;div style=&quot;padding:20px;background:#1E293B;border-radius:8px;text-align:center;&quot;&gt;
⋮----
values.insert(&quot;threat_distribution_pie&quot;.to_string(), r#&quot;&lt;div style=&quot;padding:20px;text-align:center;&quot;&gt;
⋮----
values.insert(&quot;top_threats_table&quot;.to_string(), r#&quot;&lt;table style=&quot;width:100%;border-collapse:collapse;font-size:14px;&quot;&gt;
⋮----
&lt;/table&gt;&quot;#.to_string());
⋮----
values.insert(&quot;takedowns_table&quot;.to_string(), r#&quot;&lt;table style=&quot;width:100%;border-collapse:collapse;font-size:14px;&quot;&gt;
⋮----
&quot;geospatial_map&quot;.to_string(),
⋮----
.to_string(),
⋮----
values.insert(&quot;evidence_gallery&quot;.to_string(), r#&quot;&lt;div style=&quot;display:grid;grid-template-columns:repeat(3,1fr);gap:10px;&quot;&gt;
⋮----
values.insert(&quot;ai_executive_summary&quot;.to_string(), r#&quot;&lt;div style=&quot;padding:20px;background:linear-gradient(135deg,#6366F120,#EC489920);border-radius:8px;border-left:3px solid #6366F1;&quot;&gt;
⋮----
values.insert(&quot;campaign_summary&quot;.to_string(), r#&quot;&lt;div style=&quot;padding:15px;background:#1E293B;border-radius:8px;&quot;&gt;
⋮----
mod tests {
⋮----
fn test_resolve_placeholders() {
⋮----
values.insert(&quot;company_name&quot;.to_string(), &quot;Test Corp&quot;.to_string());
values.insert(&quot;total_incidents&quot;.to_string(), &quot;100&quot;.to_string());
⋮----
let result = resolve_placeholders(template, &amp;values);
assert!(result.contains(&quot;Test Corp&quot;));
assert!(result.contains(&quot;100&quot;));</file><file path="crates/core/src/i18n/legacy.rs">use std::fmt;
use std::str::FromStr;
⋮----
pub enum Language {
⋮----
fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&apos;_&gt;) -&gt; fmt::Result {
⋮----
Language::En =&gt; write!(f, &quot;English&quot;),
Language::Es =&gt; write!(f, &quot;Español&quot;),
Language::PtBr =&gt; write!(f, &quot;Português (Brasil)&quot;),
⋮----
impl FromStr for Language {
type Err = ();
⋮----
fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
match s.to_lowercase().as_str() {
&quot;en&quot; | &quot;english&quot; =&gt; Ok(Language::En),
&quot;es&quot; | &quot;spanish&quot; | &quot;espanol&quot; =&gt; Ok(Language::Es),
&quot;pt&quot; | &quot;pt-br&quot; | &quot;portuguese&quot; | &quot;portugues&quot; =&gt; Ok(Language::PtBr),
_ =&gt; Err(()),
⋮----
pub trait Dictionary: Send + Sync {
// General
⋮----
// Labels common
⋮----
// Cover
⋮----
// Intro
⋮----
// Solutions
⋮----
// ... skipping individual solution descriptions for brevity, using generic names if needed, but let&apos;s be specific for key headers
⋮----
pub struct English;
pub struct Spanish;
pub struct Portuguese;
⋮----
impl Dictionary for English {
fn welcome_message(&amp;self) -&gt; String {
&quot;Welcome to Axur CLI&quot;.to_string()
⋮----
fn login_prompt_email(&amp;self) -&gt; String {
&quot;Email&quot;.to_string()
⋮----
fn footer_text(&amp;self) -&gt; String {
&quot;Axur. Digital experiences made safe. All rights reserved.&quot;.to_string()
⋮----
fn label_partner(&amp;self) -&gt; String {
&quot;PARTNER&quot;.to_string()
⋮----
fn label_company(&amp;self) -&gt; String {
&quot;COMPANY&quot;.to_string()
⋮----
fn label_tlp(&amp;self) -&gt; String {
&quot;TLP:&quot;.to_string()
⋮----
fn label_tlp_desc(&amp;self) -&gt; String {
⋮----
.to_string()
⋮----
fn cover_title_dynamic(&amp;self) -&gt; String {
&quot;Digital Monitoring&lt;br&gt;Report&lt;br&gt;&quot;.to_string()
⋮----
fn cover_title_static(&amp;self) -&gt; String {
&quot;Proof of Concept&lt;br&gt;Results Report&lt;br&gt;&quot;.to_string()
⋮----
fn intro_title(&amp;self) -&gt; String {
&quot;Digital Protection: From Detection to Resolution&quot;.to_string()
⋮----
fn intro_text_dynamic(&amp;self) -&gt; String {
&quot;This report details the results of continuous monitoring for your brand, demonstrating Axur&apos;s capability to provide complete visibility and effective response to digital risks.&quot;.to_string()
⋮----
fn intro_text_static(&amp;self) -&gt; String {
&quot;This report details the results of our Proof of Concept (PoC), demonstrating Axur&apos;s capability to provide complete visibility and effective response to digital risks.&quot;.to_string()
⋮----
fn intro_text_closing(&amp;self) -&gt; String {
&quot;The following pages present a detailed analysis of detected threats, actions taken, and the tangible value our platform brings to your brand&apos;s security and integrity.&quot;.to_string()
⋮----
fn solutions_title(&amp;self) -&gt; String {
&quot;Complete Platform for Your Digital Protection&quot;.to_string()
⋮----
fn solutions_subtitle_1(&amp;self) -&gt; String {
&quot;Axur offers a complete solution for managing your digital risks.&quot;.to_string()
⋮----
fn solutions_subtitle_2(&amp;self) -&gt; String {
⋮----
fn solutions_subtitle_3(&amp;self) -&gt; String {
&quot;From detection to takedown, our platform automates the entire process.&quot;.to_string()
⋮----
fn solution_takedown(&amp;self) -&gt; String {
&quot;Takedown&quot;.to_string()
⋮----
fn solution_brand_protection(&amp;self) -&gt; String {
&quot;Brand Protection&quot;.to_string()
⋮----
fn solution_threat_intel(&amp;self) -&gt; String {
&quot;Threat Intelligence&quot;.to_string()
⋮----
fn toc_title(&amp;self) -&gt; String {
&quot;Table of Contents&quot;.to_string()
⋮----
fn toc_items(&amp;self) -&gt; Vec&lt;String&gt; {
vec![
⋮----
fn poc_scope_title(&amp;self) -&gt; String {
&quot;Monitoring Scope&quot;.to_string()
⋮----
fn poc_assets_title(&amp;self) -&gt; String {
&quot;Monitored Assets&quot;.to_string()
⋮----
fn poc_label_brands(&amp;self) -&gt; String {
&quot;Monitored Brand(s)&quot;.to_string()
⋮----
fn poc_label_executives(&amp;self) -&gt; String {
&quot;Executives&quot;.to_string()
⋮----
fn poc_label_ips(&amp;self) -&gt; String {
&quot;IPs / Ranges&quot;.to_string()
⋮----
fn poc_label_bins(&amp;self) -&gt; String {
&quot;BINs&quot;.to_string()
⋮----
fn poc_label_domains(&amp;self) -&gt; String {
&quot;Domains&quot;.to_string()
⋮----
fn poc_period_dynamic_title(&amp;self) -&gt; String {
&quot;Analysis Period&quot;.to_string()
⋮----
fn poc_period_dynamic_text(&amp;self) -&gt; String {
&quot;Last days until today&quot;.to_string()
⋮----
fn poc_period_static_title(&amp;self) -&gt; String {
&quot;PoC Duration&quot;.to_string()
⋮----
fn poc_period_start(&amp;self) -&gt; String {
&quot;Start&quot;.to_string()
⋮----
fn poc_period_end(&amp;self) -&gt; String {
&quot;End&quot;.to_string()
⋮----
fn metrics_title(&amp;self) -&gt; String {
&quot;General Metrics&quot;.to_string()
⋮----
fn metrics_total_tickets(&amp;self) -&gt; String {
&quot;Total Tickets (Raw Detections)&quot;.to_string()
⋮----
fn metrics_threats_detected(&amp;self) -&gt; String {
&quot;Detected Threats&quot;.to_string()
⋮----
fn metrics_time_saved(&amp;self) -&gt; String {
&quot;Time Saved in Validation&quot;.to_string()
⋮----
fn metrics_desc_tickets(&amp;self) -&gt; String {
&quot;Total number of signals collected by the platform.&quot;.to_string()
⋮----
fn metrics_desc_threats(&amp;self) -&gt; String {
&quot;Signals confirmed as real risks after analysis and validation.&quot;.to_string()
⋮----
fn metrics_desc_time(&amp;self) -&gt; String {
&quot;Estimated time your team would have spent manually collecting and validating these threats.&quot;.to_string()
⋮----
fn threats_title(&amp;self) -&gt; String {
&quot;Potential Threats&quot;.to_string()
⋮----
fn threats_desc(&amp;self, total: u64) -&gt; String {
format!(&quot;A total of &lt;strong&gt;{}&lt;/strong&gt; threats were detected. The chart shows main categories, highlighting the most frequent attack vectors.&quot;, total)
⋮----
fn stealer_title(&amp;self) -&gt; String {
&quot;Risk Landscape: Infostealer Credentials&quot;.to_string()
⋮----
fn stealer_subtitle(&amp;self, count: u64) -&gt; String {
format!(&quot;Analysis of {} detected credentials&quot;, count)
⋮----
fn stealer_box_creds(&amp;self) -&gt; String {
&quot;Total Credentials&quot;.to_string()
⋮----
fn stealer_box_hosts(&amp;self) -&gt; String {
&quot;Unique Hosts Compromised&quot;.to_string()
⋮----
fn stealer_box_high_risk(&amp;self) -&gt; String {
&quot;High Risk Users&quot;.to_string()
⋮----
fn stealer_action(&amp;self) -&gt; String {
&quot;Immediate Action: Force password reset for exposed users and prioritize isolating infected hosts.&quot;.to_string()
⋮----
fn stealer_critical_title(&amp;self) -&gt; String {
&quot;CRITICAL: Corporate Pattern Detected&quot;.to_string()
⋮----
fn stealer_critical_desc(&amp;self, count: usize) -&gt; String {
format!(&quot;Found &lt;span class=\&quot;text-white font-bold\&quot;&gt;{}&lt;/span&gt; identities using variations of the company name in their passwords.&quot;, count)
⋮----
fn code_leak_title(&amp;self) -&gt; String {
&quot;Risk Landscape: Code Credential Leaks&quot;.to_string()
⋮----
fn code_leak_subtitle(&amp;self, count: u64) -&gt; String {
format!(&quot;Analysis of {} public secrets exposed&quot;, count)
⋮----
fn code_leak_box_secrets(&amp;self) -&gt; String {
&quot;Total Secrets Exposed&quot;.to_string()
⋮----
fn code_leak_box_repos(&amp;self) -&gt; String {
&quot;Unique Public Repos&quot;.to_string()
⋮----
fn code_leak_box_prod(&amp;self) -&gt; String {
&quot;Production Secrets&quot;.to_string()
⋮----
fn code_leak_action(&amp;self) -&gt; String {
&quot;Immediate Action: Rotate Production keys and API Keys immediately. Implement secret scanning in CI/CD pipeline.&quot;.to_string()
⋮----
fn incidents_title(&amp;self) -&gt; String {
&quot;Incidents by Type&quot;.to_string()
⋮----
fn incidents_desc(&amp;self, total: u64) -&gt; String {
format!(&quot;A total of &lt;strong&gt;{}&lt;/strong&gt; incidents were created. This chart details the relationship between raw detections and confirmed incidents.&quot;, total)
⋮----
fn takedowns_title(&amp;self) -&gt; String {
&quot;Takedowns&quot;.to_string()
⋮----
fn takedowns_requested(&amp;self) -&gt; String {
&quot;takedowns requested&quot;.to_string()
⋮----
fn takedowns_success_rate(&amp;self) -&gt; String {
&quot;success rate&quot;.to_string()
⋮----
fn takedowns_median_notify(&amp;self) -&gt; String {
&quot;median time for&lt;br&gt;1st notification&quot;.to_string()
⋮----
fn takedowns_median_uptime(&amp;self) -&gt; String {
&quot;uptime median&quot;.to_string()
⋮----
fn takedowns_status_title(&amp;self) -&gt; String {
&quot;Takedown status&quot;.to_string()
⋮----
fn takedowns_solved(&amp;self) -&gt; String {
&quot;Solved&quot;.to_string()
⋮----
fn takedowns_in_progress(&amp;self) -&gt; String {
&quot;In progress&quot;.to_string()
⋮----
fn takedowns_interrupted(&amp;self) -&gt; String {
&quot;Interrupted&quot;.to_string()
⋮----
fn takedowns_not_solved(&amp;self) -&gt; String {
&quot;Not solved&quot;.to_string()
⋮----
fn roi_title(&amp;self) -&gt; String {
&quot;Impact &amp; ROI&quot;.to_string()
⋮----
fn roi_efficiency_title(&amp;self) -&gt; String {
&quot;Operational Efficiency&quot;.to_string()
⋮----
fn roi_efficiency_label(&amp;self) -&gt; String {
&quot;FTEs Saved&quot;.to_string()
⋮----
fn roi_efficiency_desc(&amp;self, hours: u64) -&gt; String {
format!(
⋮----
fn roi_risk_title(&amp;self) -&gt; String {
&quot;Risk Reduction&quot;.to_string()
⋮----
fn roi_risk_label(&amp;self) -&gt; String {
&quot;vs Industry Avg&quot;.to_string()
⋮----
fn roi_risk_desc(&amp;self, notify_time: &amp;str) -&gt; String {
⋮----
fn roi_intel_title(&amp;self) -&gt; String {
&quot;Critical Intelligence&quot;.to_string()
⋮----
fn roi_intel_desc(&amp;self, count: u64) -&gt; String {
⋮----
fn roi_intel_stealer(&amp;self) -&gt; String {
&quot;Malware (Stealer Logs)&quot;.to_string()
⋮----
fn roi_intel_plaintext(&amp;self) -&gt; String {
&quot;Plaintext Passwords&quot;.to_string()
⋮----
fn exposure_title(&amp;self) -&gt; String {
&quot;Sensitive Data Exposure&quot;.to_string()
⋮----
fn exposure_sub_code(&amp;self) -&gt; String {
&quot;Source Code Leaks&quot;.to_string()
⋮----
fn exposure_sub_stealer(&amp;self) -&gt; String {
&quot;Infostealer Credentials&quot;.to_string()
⋮----
fn op_badge(&amp;self) -&gt; String {
&quot;OPERATIONAL IMPACT&quot;.to_string()
⋮----
fn op_time_saved_title(&amp;self) -&gt; String {
&quot;Time Saved&quot;.to_string()
⋮----
fn op_time_saved_desc(&amp;self) -&gt; String {
⋮----
fn op_unit_person_days(&amp;self) -&gt; String {
&quot;person-days&quot;.to_string()
⋮----
fn op_unit_hours(&amp;self) -&gt; String {
&quot;hours&quot;.to_string()
⋮----
fn op_breakdown_validation(&amp;self) -&gt; String {
&quot;Validation&quot;.to_string()
⋮----
fn op_breakdown_monitoring(&amp;self) -&gt; String {
&quot;Monitoring&quot;.to_string()
⋮----
fn op_breakdown_takedowns(&amp;self) -&gt; String {
⋮----
fn op_capacity_title(&amp;self) -&gt; String {
&quot;Freed Capacity&quot;.to_string()
⋮----
fn op_capacity_desc(&amp;self) -&gt; String {
&quot;Equivalent capacity of security analysts that Axur frees for strategic tasks.&quot;.to_string()
⋮----
fn op_tickets_processed(&amp;self) -&gt; String {
&quot;tickets processed&quot;.to_string()
⋮----
fn op_credentials_monitored(&amp;self) -&gt; String {
&quot;credentials monitored&quot;.to_string()
⋮----
fn op_response_title(&amp;self) -&gt; String {
&quot;Response Time&quot;.to_string()
⋮----
fn op_response_desc(&amp;self) -&gt; String {
&quot;Median time from detection to first provider notification.&quot;.to_string()
⋮----
fn op_success_rate(&amp;self) -&gt; String {
&quot;Success rate&quot;.to_string()
⋮----
fn op_takedowns_completed(&amp;self) -&gt; String {
&quot;Takedowns completed&quot;.to_string()
⋮----
fn examples_takedowns_title(&amp;self) -&gt; String {
&quot;Resolved Takedowns: Examples&quot;.to_string()
⋮----
fn examples_poc_title(&amp;self) -&gt; String {
&quot;Examples of Detected Threats&quot;.to_string()
⋮----
fn example_label_type(&amp;self) -&gt; String {
&quot;Type:&quot;.to_string()
⋮----
fn example_label_date(&amp;self) -&gt; String {
&quot;Date:&quot;.to_string()
⋮----
fn example_label_url(&amp;self) -&gt; String {
&quot;URL:&quot;.to_string()
⋮----
fn example_no_image(&amp;self) -&gt; String {
&quot;No Image Available&quot;.to_string()
⋮----
fn example_no_data(&amp;self) -&gt; String {
&quot;No evidence examples found in the selected period.&quot;.to_string()
⋮----
fn closing_title(&amp;self) -&gt; String {
&quot;Protect What Matters Most&quot;.to_string()
⋮----
fn closing_subtitle(&amp;self) -&gt; String {
&quot;You&apos;ve seen the risks. Now turn these results into continuous, 24/7 protection for your brand and customers.&quot;.to_string()
⋮----
fn closing_cta_activate(&amp;self) -&gt; String {
&quot;Activate Production Environment&quot;.to_string()
⋮----
fn closing_cta_activate_desc(&amp;self) -&gt; String {
&quot;Seamless transition from PoC to full protection.&quot;.to_string()
⋮----
fn closing_cta_meet(&amp;self) -&gt; String {
&quot;Meet your Customer Success Manager&quot;.to_string()
⋮----
fn closing_cta_meet_desc(&amp;self) -&gt; String {
&quot;Personalized onboarding and strategic planning.&quot;.to_string()
⋮----
fn deep_analytics_title(&amp;self) -&gt; String {
&quot;🔍 Executive Threat Summary&quot;.to_string()
⋮----
fn deep_analytics_subtitle(&amp;self) -&gt; String {
&quot;Advanced insights computed from your threat data&quot;.to_string()
⋮----
fn deep_analytics_code_leak_title(&amp;self) -&gt; String {
&quot;Code Leak Insights&quot;.to_string()
⋮----
fn deep_analytics_code_leak_subtitle(&amp;self, count: u64) -&gt; String {
format!(&quot;{} unique repositories analyzed&quot;, count)
⋮----
fn deep_analytics_credential_title(&amp;self) -&gt; String {
&quot;Credential Insights&quot;.to_string()
⋮----
fn deep_analytics_credential_subtitle(&amp;self, count: u64) -&gt; String {
format!(&quot;{} credentials analyzed&quot;, count)
⋮----
fn deep_analytics_takedown_title(&amp;self) -&gt; String {
&quot;Takedown Efficiency&quot;.to_string()
⋮----
fn deep_analytics_takedown_subtitle(&amp;self, count: usize) -&gt; String {
format!(&quot;{} takedowns by platform&quot;, count)
⋮----
fn story_title(&amp;self) -&gt; String {
&quot;Incident Story&quot;.to_string()
⋮----
fn story_subtitle(&amp;self, count: usize) -&gt; String {
format!(&quot;Timeline of {} related incidents&quot;, count)
⋮----
fn ctx_risk_title(&amp;self) -&gt; String {
&quot;The Digital Risk Landscape&quot;.to_string()
⋮----
fn ctx_risk_text(&amp;self) -&gt; String {
&quot;Digital risk monitoring is essential in today&apos;s interconnected world. This section provides an overview of the threats detected across the open, deep, and dark web. By identifying these risks early, we enable proactive mitigation strategies to protect your brand reputation and digital assets.&quot;.to_string()
⋮----
fn eff_title(&amp;self) -&gt; String {
⋮----
fn eff_text_hours(&amp;self, hours: u64, analysts: f64) -&gt; String {
format!(&quot;To manually analyze the threats processed by Axur, your team would have needed &lt;strong&gt;{} hours&lt;/strong&gt;. This is equivalent to &lt;strong&gt;{:.1} full-time analysts&lt;/strong&gt; dedicated solely to detection.&quot;, hours, analysts)
⋮----
fn eff_text_speed(&amp;self) -&gt; String {
&quot;Threat management with Axur was &lt;strong&gt;180x faster&lt;/strong&gt; than the industry average. While a human takes ~30 mins per alert, our AI correlates threats in seconds.&quot;.to_string()
⋮----
fn narrative_phishing_title(&amp;self) -&gt; String {
&quot;Phishing &amp; Brand Abuse&quot;.to_string()
⋮----
fn narrative_phishing_pain(&amp;self) -&gt; String {
&quot;Modern phishing evades traditional filters. Attempting to cover the volume of 40 million new URLs daily is humanly impossible.&quot;.to_string()
⋮----
fn narrative_phishing_solution(&amp;self) -&gt; String {
&quot;Our AI visually inspects every site (Computer Vision), detecting fraud even without explicit brand mentions. We don&apos;t just detect; we take down in under 4 minutes.&quot;.to_string()
⋮----
fn narrative_stealer_title(&amp;self) -&gt; String {
&quot;Understanding Infostealers&quot;.to_string()
⋮----
fn narrative_stealer_pain(&amp;self) -&gt; String {
&quot;Stolen credentials from infected devices (Infostealers) allow attackers to bypass MFA by mimicking the user&apos;s digital fingerprint.&quot;.to_string()
⋮----
fn narrative_stealer_solution(&amp;self) -&gt; String {
&quot;Manually searching the Deep Web is inefficient. Axur scans 42 billion credentials to find only those that pose a real risk to your active sessions.&quot;.to_string()
⋮----
fn narrative_takedown_title(&amp;self) -&gt; String {
&quot;The Takedown Process&quot;.to_string()
⋮----
fn narrative_takedown_pain(&amp;self) -&gt; String {
&quot;Managing takedowns across different platforms requires handling endless bureaucracy and forms for each provider.&quot;.to_string()
⋮----
fn narrative_takedown_solution(&amp;self) -&gt; String {
&quot;Axur has trusted integrations with these platforms. What takes a lawyer days, we request en masse with a 98.9% success rate.&quot;.to_string()
⋮----
fn narrative_timeline_title(&amp;self) -&gt; String {
&quot;Attack Timeline vs. Human Capacity&quot;.to_string()
⋮----
fn narrative_timeline_text(&amp;self, percent: u64) -&gt; String {
format!(&quot;Cybercriminals don&apos;t respect office hours. &lt;strong&gt;{}%&lt;/strong&gt; of critical threats were detected outside business hours. Without 24/7 automation, these would remain active for days.&quot;, percent)
⋮----
fn closing_value_title(&amp;self) -&gt; String {
&quot;Your New Extended Team&quot;.to_string()
⋮----
fn closing_value_intro(&amp;self) -&gt; String {
&quot;Acquiring Axur isn&apos;t just buying software; it&apos;s adding an army of virtual analysts to your SOC.&quot;.to_string()
⋮----
fn closing_value_item_1_title(&amp;self) -&gt; String {
&quot;Fatigue Reduction&quot;.to_string()
⋮----
fn closing_value_item_1_desc(&amp;self) -&gt; String {
&quot;We eliminate noise so your analysts only see what matters.&quot;.to_string()
⋮----
fn closing_value_item_2_title(&amp;self) -&gt; String {
&quot;Reaction Speed&quot;.to_string()
⋮----
fn closing_value_item_2_desc(&amp;self) -&gt; String {
&quot;From days to minutes. We drastically minimize exposure time.&quot;.to_string()
⋮----
fn closing_value_item_3_title(&amp;self) -&gt; String {
&quot;Total Visibility&quot;.to_string()
⋮----
fn closing_value_item_3_desc(&amp;self) -&gt; String {
&quot;We provide full context: &apos;Who, How, and Methodology&apos;, eliminating false positives so your team focuses only on real threats.&quot;.to_string()
⋮----
fn narrative_virality_title(&amp;self) -&gt; String {
&quot;DEEP WEB &amp; VIRALITY&quot;.to_string()
⋮----
fn narrative_virality_pain_primary(
⋮----
format!(&quot;Your brand was shared **{} times** in {} different fraud communities, including high-activity groups like &apos;**{}**&apos;. This &apos;chatter&apos; often precedes a massive wave of attacks.&quot;, share_count, source_count, top_source)
⋮----
fn narrative_virality_solution_primary(&amp;self) -&gt; String {
&quot;Axur has infiltrated these invite-only channels (Telegram, Discord, Dark Web). We detect the threat at the *planning* stage, before it reaches your customers.&quot;.to_string()
⋮----
fn narrative_virality_pain_fallback(&amp;self) -&gt; String {
&quot;Attacks often incubate silently in closed groups on Telegram and the Dark Web, completely invisible to standard perimeter defenses.&quot;.to_string()
⋮----
fn narrative_virality_solution_fallback(&amp;self) -&gt; String {
&quot;Our Deep Web surveillance is active 24/7. In this period, **no critical viral campaigns** were detected, validating that your brand is currently not a &apos;trending topic&apos; for fraudsters.&quot;.to_string()
⋮----
fn roi_precise_title(&amp;self) -&gt; String {
&quot;Velocity Wins&quot;.to_string()
⋮----
fn roi_precise_text_primary(&amp;self, median_minutes: i64) -&gt; String {
format!(&quot;Real Data: Your median takedown time was **{} minutes**. This speed neutralizes phishing campaigns before they can claim victims.&quot;, median_minutes)
⋮----
fn roi_precise_text_fallback(&amp;self) -&gt; String {
&quot;Managing threats with Axur is **180x faster** than industry average. AI correlation happens in seconds, replacing 30-minute manual triage per alert.&quot;.to_string()
⋮----
fn intent_title(&amp;self) -&gt; String {
&quot;AI Intent Analysis&quot;.to_string()
⋮----
fn intent_fmt_primary(&amp;self, top_intent: &amp;str, percent: u64) -&gt; String {
format!(&quot;Our AI Classifiers reveal that **{}%** of attacks aim for **{}**, indicating a specific campaign against your customer base.&quot;, percent, top_intent)
⋮----
fn intent_fmt_fallback(&amp;self) -&gt; String {
&quot;Attacks are categorized by technical vector. Phishing remains the dominant method for initiating fraud.&quot;.to_string()
⋮----
fn intent_cat_credentials(&amp;self) -&gt; String {
&quot;Credential Theft&quot;.to_string()
⋮----
fn intent_cat_infection(&amp;self) -&gt; String {
&quot;Infection &amp; Access&quot;.to_string()
⋮----
fn intent_cat_fraud(&amp;self) -&gt; String {
&quot;Fraud &amp; Reputation&quot;.to_string()
⋮----
fn intent_cat_trust(&amp;self) -&gt; String {
&quot;Brand Trust &amp; Phishing&quot;.to_string()
⋮----
fn intent_cat_chat(&amp;self) -&gt; String {
&quot;Chat Intelligence&quot;.to_string()
⋮----
fn intent_cat_compromised(&amp;self) -&gt; String {
&quot;Compromised Devices&quot;.to_string()
⋮----
fn intent_cat_data_leak(&amp;self) -&gt; String {
&quot;Data Leakage&quot;.to_string()
⋮----
fn intent_cat_vip(&amp;self) -&gt; String {
&quot;VIP Protection&quot;.to_string()
⋮----
fn intent_cat_dark_web(&amp;self) -&gt; String {
&quot;Deep &amp; Dark Web&quot;.to_string()
⋮----
fn geo_title(&amp;self) -&gt; String {
&quot;Global Attack Origins&quot;.to_string()
⋮----
fn geo_fmt_primary(&amp;self, count: usize, top_country: &amp;str) -&gt; String {
format!(&quot;We detected attacks originating from **{} countries**. The primary source of hostile infrastructure is **{}**.&quot;, count, top_country)
⋮----
fn geo_fmt_fallback(&amp;self) -&gt; String {
&quot;Geographic attribution reveals jurisdiction overlaps. Monitoring international infrastructure helps predict future campaigns.&quot;.to_string()
⋮----
fn geo_lbl_countries(&amp;self) -&gt; String {
&quot;Top Origin Countries&quot;.to_string()
⋮----
fn geo_lbl_isps(&amp;self) -&gt; String {
&quot;Top ISPs (Networks)&quot;.to_string()
⋮----
fn geo_why_important_title(&amp;self) -&gt; String {
&quot;Why is this important?&quot;.to_string()
⋮----
fn geo_why_important_text(&amp;self) -&gt; String {
&quot;The geographic origin of attacks helps identify global infrastructure used by cybercriminals. This data enables strategic geo-blocking and aids in attribution, allowing for more effective defensive measures against specific regional threats.&quot;.to_string()
⋮----
fn ctx_stealer_title(&amp;self) -&gt; String {
⋮----
fn ctx_stealer_text(&amp;self) -&gt; String {
&quot;Infostealers are malware designed to harvest sensitive information from infected devices. They collect login credentials, cookies, and system details, often sold on dark web marketplaces. Detecting these logs allows us to identify compromised employee or customer accounts before they are used for unauthorized access.&quot;.to_string()
⋮----
fn ctx_leak_title(&amp;self) -&gt; String {
&quot;The Danger of Exposed Secrets&quot;.to_string()
⋮----
fn ctx_leak_text(&amp;self) -&gt; String {
&quot;Developers sometimes inadvertently commit sensitive keys, tokens, or credentials to public repositories. These &apos;secrets&apos; can grant attackers access to cloud infrastructure, databases, or internal services. Continuous monitoring of public code repositories is crucial to detect and revoke these keys immediately.&quot;.to_string()
⋮----
fn ctx_takedown_title(&amp;self) -&gt; String {
⋮----
fn ctx_takedown_text(&amp;self) -&gt; String {
&quot;Takedown is the process of removing malicious or infringing content from the internet. When a threat is confirmed, our automated systems and legal team interact with hosting providers, registrars, and social media platforms to enforce removal, neutralizing the threat at its source.&quot;.to_string()
⋮----
impl Dictionary for Spanish {
⋮----
&quot;Bienvenido a Axur CLI&quot;.to_string()
⋮----
&quot;Correo Electrónico&quot;.to_string()
⋮----
&quot;Axur. Digital experiences made safe. Todos los derechos reservados.&quot;.to_string()
⋮----
&quot;EMPRESA&quot;.to_string()
⋮----
&quot;Informe de&lt;br&gt;Monitoreo Digital&lt;br&gt;&quot;.to_string()
⋮----
&quot;Informe de Resultados&lt;br&gt;Prueba de Concepto&lt;br&gt;&quot;.to_string()
⋮----
&quot;Protección Digital: De la Detección a la Resolución&quot;.to_string()
⋮----
&quot;Este informe detalla los resultados del monitoreo continuo de su marca, demostrando la capacidad de Axur para ofrecer visibilidad completa y respuesta eficaz ante los riesgos digitales.&quot;.to_string()
⋮----
&quot;Este informe detalla los resultados de nuestra Prueba de Concepto (PoC), demostrando la capacidad de Axur para ofrecer visibilidad completa y respuesta eficaz ante los riesgos digitales.&quot;.to_string()
⋮----
&quot;Las siguientes páginas presentan un análisis detallado de las amenazas detectadas, las acciones tomadas y el valor tangible que nuestra plataforma aporta a la seguridad e integridad de su marca.&quot;.to_string()
⋮----
&quot;Plataforma Completa para su Protección Digital&quot;.to_string()
⋮----
&quot;Axur ofrece una solución completa para la gestión de sus riesgos digitales.&quot;.to_string()
⋮----
&quot;Protegemos su marca, sus clientes y su negocio de fraudes y amenazas en línea.&quot;.to_string()
⋮----
&quot;Protección de Marca&quot;.to_string()
⋮----
&quot;Inteligencia de Amenazas&quot;.to_string()
⋮----
&quot;Índice de Contenidos&quot;.to_string()
⋮----
&quot;Alcance del Monitoreo&quot;.to_string()
⋮----
&quot;Activos Monitoreados&quot;.to_string()
⋮----
&quot;Marcas Monitoreadas&quot;.to_string()
⋮----
&quot;Ejecutivos&quot;.to_string()
⋮----
&quot;IPs / Rangos&quot;.to_string()
⋮----
&quot;Dominios&quot;.to_string()
⋮----
&quot;Período de Análisis&quot;.to_string()
⋮----
&quot;Últimos días hasta hoy&quot;.to_string()
⋮----
&quot;Duración de la PoC&quot;.to_string()
⋮----
&quot;Inicio&quot;.to_string()
⋮----
&quot;Fin&quot;.to_string()
⋮----
&quot;Métricas Generales&quot;.to_string()
⋮----
&quot;Total de Tickets (Detecciones Crudas)&quot;.to_string()
⋮----
&quot;Amenazas Detectadas&quot;.to_string()
⋮----
&quot;Ahorro de Tiempo en Validación&quot;.to_string()
⋮----
&quot;El número total de señales que la plataforma ha recopilado.&quot;.to_string()
⋮----
&quot;Tiempo estimado que su equipo habría dedicado a recolectar, analizar y validar manualmente estas mismas amenazas.&quot;.to_string()
⋮----
&quot;Amenazas Potenciales&quot;.to_string()
⋮----
format!(&quot;Se detectaron un total de &lt;strong&gt;{}&lt;/strong&gt; amenazas. El gráfico muestra las principales categorías, destacando los vectores de ataque más frecuentes contra su marca.&quot;, total)
⋮----
&quot;Panorama de Riesgo: Credenciales por Infostealer&quot;.to_string()
⋮----
format!(&quot;Análisis de {} credenciales detectadas&quot;, count)
⋮----
&quot;Credenciales Totales&quot;.to_string()
⋮----
&quot;Hosts Únicos Comprometidos&quot;.to_string()
⋮----
&quot;Usuarios de Alto Riesgo&quot;.to_string()
⋮----
&quot;Acción Inmediata: Forzar el reseteo de contraseña para los usuarios expuestos y priorizar el aislamiento de los hosts infectados.&quot;.to_string()
⋮----
&quot;CRÍTICO: Patrón Corporativo Detectado&quot;.to_string()
⋮----
format!(&quot;Se encontraron &lt;span class=\&quot;text-white font-bold\&quot;&gt;{}&lt;/span&gt; identidades usando variaciones del nombre de la empresa en sus contraseñas.&quot;, count)
⋮----
&quot;Panorama de Riesgo: Fugas de Credenciales en Código&quot;.to_string()
⋮----
&quot;Exposición de Datos Sensibles&quot;.to_string()
⋮----
&quot;Fugas en Código Fuente&quot;.to_string()
⋮----
&quot;Credenciales (Infostealer)&quot;.to_string()
⋮----
format!(&quot;Análisis de {} secretos expuestos públicamente&quot;, count)
⋮----
&quot;Secretos Totales Expuestos&quot;.to_string()
⋮----
&quot;Repositorios Públicos Únicos&quot;.to_string()
⋮----
&quot;Secretos de Producción&quot;.to_string()
⋮----
&quot;Acción Inmediata: Rotar las claves de &apos;Producción&apos; y las Claves de API inmediatamente. Implementar un escáner de secretos en el pipeline de CI/CD.&quot;.to_string()
⋮----
&quot;Incidentes por Tipo&quot;.to_string()
⋮----
format!(&quot;Se crearon un total de &lt;strong&gt;{}&lt;/strong&gt; incidentes. Este gráfico detalla la relación entre detecciones brutas e incidentes confirmados.&quot;, total)
⋮----
&quot;solicitudes de takedown&quot;.to_string()
⋮----
&quot;El Panorama de Riesgo Digital&quot;.to_string()
⋮----
&quot;El monitoreo de riesgos digitales es esencial en el mundo interconectado de hoy. Esta sección ofrece una visión general de las amenazas detectadas en la web abierta, profunda y oscura. Al identificar estos riesgos temprano, permitimos estrategias de mitigación proactivas para proteger la reputación de su marca y sus activos digitales.&quot;.to_string()
⋮----
&quot;Entendiendo los Infostealers&quot;.to_string()
⋮----
&quot;Los Infostealers son malware diseñado para recolectar información sensible de dispositivos infectados. Roban credenciales de inicio de sesión, cookies y detalles del sistema, que a menudo se venden en mercados de la dark web. Detectar estos registros nos permite identificar cuentas de empleados o clientes comprometidas antes de que sean utilizadas para accesos no autorizados.&quot;.to_string()
⋮----
&quot;El Peligro de Secretos Expuestos&quot;.to_string()
⋮----
&quot;Los desarrolladores a veces publican inadvertidamente claves, tokens o credenciales sensibles en repositorios públicos. Estos &apos;secretos&apos; pueden dar a los atacantes acceso a infraestructura en la nube, bases de datos o servicios internos. El monitoreo continuo de repositorios de código público es crucial para detectar y revocar estas claves de inmediato.&quot;.to_string()
⋮----
&quot;El Proceso de Takedown&quot;.to_string()
⋮----
&quot;El Takedown es el proceso de eliminación de contenido malicioso o infractor de internet. Cuando se confirma una amenaza, nuestros sistemas automatizados y equipo legal interactúan con proveedores de alojamiento, registradores y plataformas de redes sociales para forzar su eliminación, neutralizando la amenaza en su origen.&quot;.to_string()
⋮----
&quot;tasa de éxito&quot;.to_string()
⋮----
&quot;tiempo medio para&lt;br&gt;1ª notificación&quot;.to_string()
⋮----
&quot;uptime medio&quot;.to_string()
⋮----
&quot;Estado de takedown&quot;.to_string()
⋮----
&quot;Resuelto&quot;.to_string()
⋮----
&quot;En progreso&quot;.to_string()
⋮----
&quot;Interrumpido&quot;.to_string()
⋮----
&quot;No resuelto&quot;.to_string()
⋮----
&quot;Eficiencia Operativa&quot;.to_string()
⋮----
format!(&quot;Para analizar manualmente las amenazas procesadas por Axur, su equipo habría necesitado &lt;strong&gt;{} horas&lt;/strong&gt;. Esto equivale a &lt;strong&gt;{:.1} analistas a tiempo completo&lt;/strong&gt; dedicados solo a la detección.&quot;, hours, analysts)
⋮----
&quot;La gestión de amenazas con Axur fue &lt;strong&gt;180 veces más rápida&lt;/strong&gt; que el promedio de la industria. Mientras un humano tarda ~30 mins por alerta, nuestra IA correlaciona amenazas en segundos.&quot;.to_string()
⋮----
&quot;Phishing y Abuso de Marca&quot;.to_string()
⋮----
&quot;El phishing moderno evita los filtros tradicionales. Intentar cubrir el volumen de 40 millones de URLs nuevas diariamente es humanamente imposible.&quot;.to_string()
⋮----
&quot;Nuestra IA inspecciona visualmente cada sitio (Computer Vision), detectando fraudes incluso sin menciones explícitas de la marca. No solo detectamos; eliminamos en menos de 4 minutos.&quot;.to_string()
⋮----
&quot;Las credenciales robadas de dispositivos infectados (Infostealers) permiten a los atacantes eludir el MFA imitando la huella digital del usuario.&quot;.to_string()
⋮----
&quot;Buscar manualmente en la Deep Web es ineficiente. Axur escanea 42 mil millones de credenciales para encontrar solo aquellas que representan un riesgo real para sus sesiones activas.&quot;.to_string()
⋮----
&quot;Gestionar takedowns en diferentes plataformas requiere manejar burocracia interminable y formularios específicos para cada proveedor.&quot;.to_string()
⋮----
&quot;Axur tiene integraciones de confianza con estas plataformas. Lo que a un abogado le toma días, nosotros lo solicitamos masivamente con una tasa de éxito del 98.9%.&quot;.to_string()
⋮----
&quot;Línea de Tiempo vs. Capacidad Humana&quot;.to_string()
⋮----
format!(&quot;Los ciberdelincuentes no respetan el horario de oficina. El &lt;strong&gt;{}%&lt;/strong&gt; de las amenazas críticas se detectaron fuera del horario laboral. Sin la automatización 24/7, estas habrían permanecido activas durante días.&quot;, percent)
⋮----
&quot;Su Nuevo Equipo Extendido&quot;.to_string()
⋮----
&quot;Adquirir Axur no es solo comprar software; es sumar un ejército de analistas virtuales a su SOC.&quot;.to_string()
⋮----
&quot;Reducción de Fatiga&quot;.to_string()
⋮----
&quot;Eliminamos el ruido para que sus analistas solo vean lo que importa.&quot;.to_string()
⋮----
&quot;Velocidad de Reacción&quot;.to_string()
⋮----
&quot;De días a minutos. Minimizamos drásticamente el tiempo de exposición.&quot;.to_string()
⋮----
&quot;Visibilidad Total&quot;.to_string()
⋮----
&quot;Entregamos el contexto completo: &apos;Quién, Cómo y Metodología&apos;, eliminando falsos positivos para que tu equipo se enfoque solo en amenazas reales.&quot;.to_string()
⋮----
&quot;DEEP WEB &amp; VIRALIDAD&quot;.to_string()
⋮----
format!(&quot;Tu marca fue compartida **{} veces** en {} comunidades de fraude, incluyendo grupos activos como &apos;**{}**&apos;. Este &apos;ruido&apos; suele preceder una ola masiva de ataques.&quot;, share_count, source_count, top_source)
⋮----
&quot;Axur está infiltrado en estos canales cerrados (Telegram, Discord, Dark Web). Detectamos la amenaza en la etapa de *planeación*, antes de que llegue a tus clientes.&quot;.to_string()
⋮----
&quot;Los ataques suelen incubarse silenciosamente en grupos cerrados de Telegram y Dark Web, invisibles para las defensas perimetrales estándar.&quot;.to_string()
⋮----
&quot;Nuestro monitoreo de Deep Web está activo 24/7. En este periodo, **no detectamos campañas virales críticas**, validando que tu marca no es actualmente un &apos;tema de moda&apos; para los defraudadores.&quot;.to_string()
⋮----
&quot;La Velocidad Gana&quot;.to_string()
⋮----
format!(&quot;Dato Real: Tu tiempo mediano de baja fue de **{} minutos**. Esta velocidad neutraliza campañas de phishing antes de que cobren víctimas.&quot;, median_minutes)
⋮----
&quot;Gestionar amenazas con Axur es **180x más rápido** que el promedio. Nuestra IA correlaciona en segundos, reemplazando los 30 min de triaje manual.&quot;.to_string()
⋮----
&quot;Análisis de Intención (AI)&quot;.to_string()
⋮----
format!(&quot;Nuestra IA revela que el **{}%** de los ataques buscan **{}**, indicando una campaña específica contra sus usuarios.&quot;, percent, top_intent)
⋮----
&quot;Los ataques se categorizan por vector técnico. El Phishing sigue siendo el método dominante para iniciar fraudes.&quot;.to_string()
⋮----
&quot;Robo de Credenciales&quot;.to_string()
⋮----
&quot;Infección y Acceso&quot;.to_string()
⋮----
&quot;Fraude y Reputación&quot;.to_string()
⋮----
&quot;Fraude de Marca / Phishing&quot;.to_string()
⋮----
&quot;Dispositivos Comprometidos&quot;.to_string()
⋮----
&quot;Fuga de Datos y Accesos&quot;.to_string()
⋮----
&quot;Protección VIP&quot;.to_string()
⋮----
&quot;Orígenes Globales de Ataque&quot;.to_string()
⋮----
format!(&quot;Detectamos ataques originados en **{} países**. La fuente principal de infraestructura hostil es **{}**.&quot;, count, top_country)
⋮----
&quot;La atribución geográfica revela superposiciones de jurisdicción. Monitorear infraestructura internacional ayuda a predecir futuras campañas.&quot;.to_string()
⋮----
&quot;Principales Países de Origen&quot;.to_string()
⋮----
&quot;Top ISPs (Redes)&quot;.to_string()
⋮----
&quot;¿Por qué es importante esto?&quot;.to_string()
⋮----
&quot;El origen geográfico de los ataques revela la infraestructura global de los ciberdelincuentes. Este dato permite bloqueos estratégicos por región y mejora la atribución, facilitando defensas más efectivas contra amenazas localizadas.&quot;.to_string()
⋮----
&quot;Impacto y ROI&quot;.to_string()
⋮----
&quot;FTEs Ahorrados&quot;.to_string()
⋮----
&quot;Reducción de Riesgo&quot;.to_string()
⋮----
&quot;vs Promedio Industria&quot;.to_string()
⋮----
&quot;Inteligencia Crítica&quot;.to_string()
⋮----
&quot;Password Texto Plano&quot;.to_string()
⋮----
&quot;IMPACTO OPERACIONAL&quot;.to_string()
⋮----
&quot;Tiempo Ahorrado&quot;.to_string()
⋮----
&quot;días persona&quot;.to_string()
⋮----
&quot;horas&quot;.to_string()
⋮----
&quot;Validación&quot;.to_string()
⋮----
&quot;Monitoreo&quot;.to_string()
⋮----
&quot;Capacidad Liberada&quot;.to_string()
⋮----
&quot;tickets procesados&quot;.to_string()
⋮----
&quot;credenciales monitoreadas&quot;.to_string()
⋮----
&quot;Tiempo de Respuesta&quot;.to_string()
⋮----
&quot;Tiempo mediano desde detección hasta la primera notificación al proveedor.&quot;.to_string()
⋮----
&quot;Tasa de éxito&quot;.to_string()
⋮----
&quot;Takedowns realizados&quot;.to_string()
⋮----
&quot;Takedowns Resueltos: Ejemplos&quot;.to_string()
⋮----
&quot;Ejemplos de Amenazas Detectadas&quot;.to_string()
⋮----
&quot;Tipo:&quot;.to_string()
⋮----
&quot;Fecha:&quot;.to_string()
⋮----
&quot;Imagen no disponible&quot;.to_string()
⋮----
&quot;No se encontraron ejemplos de evidencia en el período seleccionado.&quot;.to_string()
⋮----
&quot;Protege lo que más importa&quot;.to_string()
⋮----
&quot;Activar Entorno de Producción&quot;.to_string()
⋮----
&quot;Transición fluida de PoC a protección total.&quot;.to_string()
⋮----
&quot;Reunirse con Customer Success&quot;.to_string()
⋮----
&quot;Onboarding personalizado y planificación estratégica.&quot;.to_string()
⋮----
&quot;🔍 Resumen Ejecutivo de Amenazas&quot;.to_string()
⋮----
&quot;Insights avanzados computados a partir de tus datos de amenazas&quot;.to_string()
⋮----
&quot;Insights de Fugas de Código&quot;.to_string()
⋮----
format!(&quot;{} repositorios únicos analizados&quot;, count)
⋮----
&quot;Insights de Credenciales&quot;.to_string()
⋮----
format!(&quot;{} credenciales analizadas&quot;, count)
⋮----
&quot;Eficiencia de Takedowns&quot;.to_string()
⋮----
format!(&quot;{} takedowns por plataforma&quot;, count)
⋮----
&quot;Historia del Incidente&quot;.to_string()
⋮----
format!(&quot;Línea de tiempo de {} incidentes relacionados&quot;, count)
⋮----
impl Dictionary for Portuguese {
⋮----
&quot;Bem-vindo ao Axur CLI&quot;.to_string()
⋮----
&quot;E-mail&quot;.to_string()
⋮----
&quot;Axur. Digital experiences made safe. Todos os direitos reservados.&quot;.to_string()
⋮----
&quot;PARCEIRO&quot;.to_string()
⋮----
&quot;Relatório de&lt;br&gt;Monitoramento Digital&lt;br&gt;&quot;.to_string()
⋮----
&quot;Relatório de Resultados&lt;br&gt;Prova de Conceito&lt;br&gt;&quot;.to_string()
⋮----
&quot;Proteção Digital: Da Detecção à Resolução&quot;.to_string()
⋮----
&quot;Este relatório detalha os resultados do monitoramento contínuo da sua marca, demonstrando a capacidade da Axur de oferecer visibilidade completa e resposta eficaz aos riscos digitais.&quot;.to_string()
⋮----
&quot;Este relatório detalha os resultados da nossa Prova de Conceito (PoC), demonstrando a capacidade da Axur de oferecer visibilidade completa e resposta eficaz aos riscos digitais.&quot;.to_string()
⋮----
&quot;As páginas a seguir apresentam uma análise detalhada das ameaças detectadas, ações tomadas e o valor tangível que nossa plataforma traz para a segurança e integridade da sua marca.&quot;.to_string()
⋮----
&quot;Plataforma Completa para sua Proteção Digital&quot;.to_string()
⋮----
&quot;A Axur oferece uma solução completa para a gestão dos seus riscos digitais.&quot;.to_string()
⋮----
&quot;Da detecção à remoção (takedown), nossa plataforma automatiza todo o processo.&quot;.to_string()
⋮----
&quot;Proteção de Marca&quot;.to_string()
⋮----
&quot;Inteligência de Ameaças&quot;.to_string()
⋮----
&quot;Índice de Conteúdos&quot;.to_string()
⋮----
&quot;Escopo do Monitoramento&quot;.to_string()
⋮----
&quot;Ativos Monitorados&quot;.to_string()
⋮----
&quot;Marcas Monitoradas&quot;.to_string()
⋮----
&quot;Executivos&quot;.to_string()
⋮----
&quot;Domínios&quot;.to_string()
⋮----
&quot;Período de Análise&quot;.to_string()
⋮----
&quot;Últimos dias até hoje&quot;.to_string()
⋮----
&quot;Duração da PoC&quot;.to_string()
⋮----
&quot;Início&quot;.to_string()
⋮----
&quot;Fim&quot;.to_string()
⋮----
&quot;Métricas Gerais&quot;.to_string()
⋮----
&quot;Total de Tickets (Detecções Brutas)&quot;.to_string()
⋮----
&quot;Ameaças Detectadas&quot;.to_string()
⋮----
&quot;Economia de Tempo na Validação&quot;.to_string()
⋮----
&quot;O número total de sinais que a plataforma coletou.&quot;.to_string()
⋮----
&quot;Sinais que, após análise e validação, foram confirmados como riscos reais.&quot;.to_string()
⋮----
&quot;Tempo estimado que sua equipe teria gasto coletando e validando manualmente essas mesmas ameaças.&quot;.to_string()
⋮----
&quot;Ameaças Potenciais&quot;.to_string()
⋮----
format!(&quot;Foram detectadas um total de &lt;strong&gt;{}&lt;/strong&gt; ameaças. O gráfico mostra as principais categorias, destacando os vetores de ataque mais frequentes contra sua marca.&quot;, total)
⋮----
&quot;Cenário de Risco: Credenciais por Infostealer&quot;.to_string()
⋮----
format!(&quot;Análise de {} credenciais detectadas&quot;, count)
⋮----
&quot;Credenciais Totais&quot;.to_string()
⋮----
&quot;Usuários de Alto Risco&quot;.to_string()
⋮----
&quot;Ação Imediata: Forçar a redefinição de senha para usuários expostos e priorizar o isolamento de hosts infectados.&quot;.to_string()
⋮----
&quot;CRÍTICO: Padrão Corporativo Detectado&quot;.to_string()
⋮----
format!(&quot;Foram encontradas &lt;span class=\&quot;text-white font-bold\&quot;&gt;{}&lt;/span&gt; identidades usando variações do nome da empresa em suas senhas.&quot;, count)
⋮----
&quot;Panorama de Risco: Vazamento de Credenciais em Código&quot;.to_string()
⋮----
&quot;Exposição de Dados Sensíveis&quot;.to_string()
⋮----
&quot;Vazamentos em Código Fonte&quot;.to_string()
⋮----
&quot;Credenciais (Infostealer)&quot;.to_string()
⋮----
format!(&quot;Análise de {} segredos expostos publicamente&quot;, count)
⋮----
&quot;Segredos Totais Expostos&quot;.to_string()
⋮----
&quot;Repositórios Públicos Únicos&quot;.to_string()
⋮----
&quot;Segredos de Produção&quot;.to_string()
⋮----
&quot;Ação Imediata: Rotacionar chaves de &apos;Produção&apos; e chaves de API imediatamente. Implementar scanner de segredos no pipeline CI/CD.&quot;.to_string()
⋮----
format!(&quot;Foram criados um total de &lt;strong&gt;{}&lt;/strong&gt; incidentes. Este gráfico detalha a relação entre detecções brutas e incidentes confirmados.&quot;, total)
⋮----
&quot;takedowns solicitados&quot;.to_string()
⋮----
&quot;taxa de sucesso&quot;.to_string()
⋮----
&quot;tempo médio para&lt;br&gt;1ª notificação&quot;.to_string()
⋮----
&quot;uptime médio&quot;.to_string()
⋮----
&quot;Status do takedown&quot;.to_string()
⋮----
&quot;Resolvido&quot;.to_string()
⋮----
&quot;Em progresso&quot;.to_string()
⋮----
&quot;Interrompido&quot;.to_string()
⋮----
&quot;Não resolvido&quot;.to_string()
⋮----
&quot;Impacto e ROI&quot;.to_string()
⋮----
&quot;Eficiência Operacional&quot;.to_string()
⋮----
&quot;FTEs Economizados&quot;.to_string()
⋮----
&quot;Redução de Risco&quot;.to_string()
⋮----
&quot;vs Média de Mercado&quot;.to_string()
⋮----
format!(&quot;Tempo de Detecção Axur ({}) vs 48h (Manual).&quot;, notify_time)
⋮----
&quot;Inteligência Crítica&quot;.to_string()
⋮----
&quot;Senhas em Texto Plano&quot;.to_string()
⋮----
&quot;Tempo Economizado&quot;.to_string()
⋮----
&quot;dias pessoa&quot;.to_string()
⋮----
&quot;Validação&quot;.to_string()
⋮----
&quot;Monitoramento&quot;.to_string()
⋮----
&quot;Capacidade Liberada&quot;.to_string()
⋮----
&quot;Capacidade equivalente de analistas de segurança que a Axur libera para tarefas estratégicas.&quot;.to_string()
⋮----
&quot;tickets processados&quot;.to_string()
⋮----
&quot;credenciais monitoradas&quot;.to_string()
⋮----
&quot;Tempo de Resposta&quot;.to_string()
⋮----
&quot;Tempo mediano desde detecção até a primeira notificação ao provedor.&quot;.to_string()
⋮----
&quot;Taxa de sucesso&quot;.to_string()
⋮----
&quot;Takedowns Resolvidos: Exemplos&quot;.to_string()
⋮----
&quot;Exemplos de Ameaças Detectadas&quot;.to_string()
⋮----
&quot;Data:&quot;.to_string()
⋮----
&quot;Imagem indisponível&quot;.to_string()
⋮----
&quot;Nenhum exemplo de evidência encontrado no período selecionado.&quot;.to_string()
⋮----
&quot;Proteja o que mais importa&quot;.to_string()
⋮----
&quot;Ativar Ambiente de Produção&quot;.to_string()
⋮----
&quot;Transição fluida da PoC para proteção total.&quot;.to_string()
⋮----
&quot;Falar com Customer Success&quot;.to_string()
⋮----
&quot;Onboarding personalizado e planejamento estratégico.&quot;.to_string()
⋮----
&quot;🔍 Resumo Executivo de Ameaças&quot;.to_string()
⋮----
&quot;Insights avançados computados a partir dos seus dados de ameaças&quot;.to_string()
⋮----
&quot;Insights de Vazamento de Código&quot;.to_string()
⋮----
format!(&quot;{} repositórios únicos analisados&quot;, count)
⋮----
&quot;Insights de Credenciais&quot;.to_string()
⋮----
format!(&quot;{} credenciais analisadas&quot;, count)
⋮----
&quot;Eficiência de Takedowns&quot;.to_string()
⋮----
&quot;Histórico do Incidente&quot;.to_string()
⋮----
format!(&quot;Linha do tempo de {} incidentes relacionados&quot;, count)
⋮----
&quot;O Panorama de Risco Digital&quot;.to_string()
⋮----
&quot;O monitoramento de riscos digitais é essencial no mundo interconectado de hoje. Esta seção oferece uma visão geral das ameaças detectadas na web aberta, profunda e dark. Ao identificar esses riscos antecipadamente, possibilitamos estratégias de mitigação proativas para proteger a reputação da sua marca e seus ativos digitais.&quot;.to_string()
⋮----
&quot;Entendendo os Infostealers&quot;.to_string()
⋮----
&quot;Infostealers são malwares projetados para coletar informações sensíveis de dispositivos infectados. Eles roubam credenciais de login, cookies e detalhes do sistema, frequentemente vendidos em mercados da dark web. Detectar esses registros nos permite identificar contas de funcionários ou clientes comprometidas antes que sejam usadas para acessos não autorizados.&quot;.to_string()
⋮----
&quot;O Perigo de Segredos Expostos&quot;.to_string()
⋮----
&quot;Desenvolvedores às vezes publicam inadvertidamente chaves, tokens ou credenciais sensíveis em repositórios públicos. Esses &apos;segredos&apos; podem dar aos atacantes acesso à infraestrutura em nuvem, banco de dados ou serviços internos. O monitoramento contínuo de repositórios de código público é crucial para detectar e revogar essas chaves imediatamente.&quot;.to_string()
⋮----
&quot;O Processo de Takedown&quot;.to_string()
⋮----
&quot;Takedown é o processo de remoção de conteúdo malicioso ou infrator da internet. Quando uma ameaça é confirmada, nossos sistemas automatizados e equipe jurídica interagem com provedores de hospedagem, registradores e plataformas de redes sociais para forçar a remoção, neutralizando a ameaça em sua origem.&quot;.to_string()
⋮----
format!(&quot;Para analisar manualmente as ameaças processadas pela Axur, sua equipe precisaria dedicar &lt;strong&gt;{} horas&lt;/strong&gt;. Isso equivale a &lt;strong&gt;{:.1} analistas em tempo integral&lt;/strong&gt; dedicados apenas à detecção.&quot;, hours, analysts)
⋮----
&quot;A gestão de ameaças com a Axur foi &lt;strong&gt;180x mais rápida&lt;/strong&gt; que a média da indústria. Enquanto um humano leva ~30 min por alerta, nossa IA correlaciona ameaças em segundos.&quot;.to_string()
⋮----
&quot;Phishing &amp; Abuso de Marca&quot;.to_string()
⋮----
&quot;O phishing moderno evita filtros tradicionais. Tentar cobrir o volume de 40 milhões de novas URLs diariamente é humanamente impossível.&quot;.to_string()
⋮----
&quot;Nossa IA inspeciona visualmente cada site (Visão Computacional), detectando fraudes mesmo sem menções explícitas à marca. Não apenas detectamos; removemos em menos de 4 minutos.&quot;.to_string()
⋮----
&quot;Credenciais roubadas de dispositivos infectados (Infostealers) permitem que atacantes ignorem o MFA imitando a impressão digital do usuário.&quot;.to_string()
⋮----
&quot;Buscar manualmente na Deep Web é ineficiente. A Axur escaneia 42 bilhões de credenciais para encontrar apenas aquelas que representam risco real para suas sessões ativas.&quot;.to_string()
⋮----
&quot;Gerenciar takedowns em diferentes plataformas exige lidar com burocracia sem fim e formulários específicos para cada provedor.&quot;.to_string()
⋮----
&quot;A Axur possui integrações confiáveis com essas plataformas. O que leva dias para um advogado, solicitamos em massa com uma taxa de sucesso de 98,9%.&quot;.to_string()
⋮----
&quot;Linha do Tempo de Ataques vs. Capacidade Humana&quot;.to_string()
⋮----
format!(&quot;Cibercriminosos não respeitam horário comercial. &lt;strong&gt;{}%&lt;/strong&gt; das ameaças críticas foram detectadas fora do expediente. Sem a automação 24/7, elas permaneceriam ativas por dias.&quot;, percent)
⋮----
&quot;Sua Nova Equipe Estendida&quot;.to_string()
⋮----
&quot;Adquirir a Axur não é apenas comprar software; é adicionar um exército de analistas virtuais ao seu SOC.&quot;.to_string()
⋮----
&quot;Redução de Fadiga&quot;.to_string()
⋮----
&quot;Eliminamos o ruído para que seus analistas vejam apenas o que importa.&quot;.to_string()
⋮----
&quot;Velocidade de Reação&quot;.to_string()
⋮----
&quot;De dias para minutos. Minimizamos drasticamente o tempo de exposição.&quot;.to_string()
⋮----
&quot;Visibilidade Total&quot;.to_string()
⋮----
&quot;Entregamos contexto completo: &apos;Quem, Como e Metodologia&apos;, eliminando falsos positivos para que seu time foque apenas em ameaças reais.&quot;.to_string()
⋮----
&quot;DEEP WEB &amp; VIRALIDADE&quot;.to_string()
⋮----
format!(&quot;Sua marca foi compartilhada **{} vezes** em {} comunidades de fraude, incluindo grupos como &apos;**{}**&apos;. Esse &apos;ruído&apos; geralmente precede uma onda massiva de ataques.&quot;, share_count, source_count, top_source)
⋮----
&quot;A Axur está infiltrada nesses canais fechados (Telegram, Discord, Dark Web). Detectamos a ameaça no estágio de *planejamento*, antes que atinja seus clientes.&quot;.to_string()
⋮----
&quot;Ataques costumam ser incubados silenciosamente em grupos fechados do Telegram e Dark Web, invisíveis para defesas de perímetro padrão.&quot;.to_string()
⋮----
&quot;Nosso monitoramento de Deep Web está ativo 24/7. Neste período, **não detectamos campanhas virais críticas**, validando que sua marca não é atualmente um &apos;tópico de tendência&apos; para fraudadores.&quot;.to_string()
⋮----
&quot;Velocidade é Segurança&quot;.to_string()
⋮----
format!(&quot;Dado Real: Seu tempo mediano de takedown foi de **{} minutos**. Essa velocidade neutraliza campanhas de phishing antes de fazerem vítimas.&quot;, median_minutes)
⋮----
&quot;Gerenciar ameaças com a Axur é **180x mais rápido** que a média. Nossa IA correlaciona em segundos, substituindo 30 min de triagem manual.&quot;.to_string()
⋮----
&quot;Análise de Intenção (IA)&quot;.to_string()
⋮----
format!(&quot;Nossa IA revela que **{}%** dos ataques visam **{}**, indicando uma campanha específica contra sua base.&quot;, percent, top_intent)
⋮----
&quot;Ataques são categorizados por vetor técnico. Phishing continua sendo o método dominante para iniciar fraudes.&quot;.to_string()
⋮----
&quot;Roubo de Credenciais&quot;.to_string()
⋮----
&quot;Infecção e Acesso&quot;.to_string()
⋮----
&quot;Fraude e Reputação&quot;.to_string()
⋮----
&quot;Proteção de Marca e Clientes&quot;.to_string()
⋮----
&quot;Fuga de Dados e Acessos&quot;.to_string()
⋮----
&quot;Proteção VIP&quot;.to_string()
⋮----
&quot;Origens Globais de Ataque&quot;.to_string()
⋮----
format!(&quot;Detectamos ataques originados em **{} países**. A principal fonte de infraestrutura hostil é **{}**.&quot;, count, top_country)
⋮----
&quot;A atribuição geográfica revela sobreposições de jurisdição. Monitorar infraestrutura internacional ajuda a prever campanhas futuras.&quot;.to_string()
⋮----
&quot;Principais Países de Origem&quot;.to_string()
⋮----
&quot;Por que isso é importante?&quot;.to_string()
⋮----
&quot;A origem geográfica dos ataques revela a infraestrutura global usada por cibercriminosos. Esses dados permitem bloqueio geográfico estratégico e auxiliam na atribuição, permitindo defesas mais eficazes contra ameaças regionais.&quot;.to_string()
⋮----
pub fn get_dictionary(lang: Language) -&gt; Box&lt;dyn Dictionary&gt; {</file><file path="crates/core/src/plugins/builtin/closing.rs">use super::helpers::footer_dark;
⋮----
pub struct ClosingSlidePlugin;
⋮----
impl SlidePlugin for ClosingSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let html = format!(
⋮----
.replace(&quot;from-orange-500&quot;, &quot;from-[var(--color-primary)]&quot;)
.replace(&quot;to-red-500&quot;, &quot;to-red-600&quot;)
.replace(&quot;shadow-orange-500&quot;, &quot;shadow-[var(--color-primary)]&quot;)
.replace(&quot;text-orange-400&quot;, &quot;text-brand-primary&quot;)
.replace(&quot;hover:ring-orange-500&quot;, &quot;hover:ring-brand-primary&quot;);
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/cover.rs">use super::theme;
⋮----
const COVER_IMAGE_BASE64: &amp;str = include_str!(&quot;../../../assets/cover_image_base64.txt&quot;);
⋮----
pub struct CoverSlidePlugin;
⋮----
impl SlidePlugin for CoverSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let partner_html = data.partner_name.as_ref().map(|p| format!(
⋮----
)).unwrap_or_default();
⋮----
t.get(&quot;cover_title_dynamic&quot;)
⋮----
t.get(&quot;cover_title_static&quot;)
⋮----
let date_range = format!(&quot;{} — {}&quot;, data.start_date, data.end_date);
⋮----
let html = format!(
⋮----
.replace(&quot;#FF671F&quot;, &quot;var(--color-primary)&quot;)
.replace(&quot;bg-[#FF671F]&quot;, &quot;bg-brand-primary&quot;)
.replace(&quot;text-[#FF671F]&quot;, &quot;text-brand-primary&quot;)
.replace(&quot;border-[#FF671F]&quot;, &quot;border-brand-primary&quot;);
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/examples.rs">use super::helpers::footer_dark;
⋮----
pub struct TakedownExamplesSlidePlugin;
⋮----
impl SlidePlugin for TakedownExamplesSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.takedown_examples.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let examples_html: String = data.takedown_examples.iter().take(4).map(|ex| {
let status_color = match ex.status.to_lowercase().as_str() {
s if s.contains(&quot;solv&quot;) || s.contains(&quot;remov&quot;) || s.contains(&quot;success&quot;) =&gt; &quot;text-emerald-400 bg-emerald-400/10 border-emerald-400/20&quot;,
s if s.contains(&quot;pending&quot;) || s.contains(&quot;progr&quot;) =&gt; &quot;text-amber-400 bg-amber-400/10 border-amber-400/20&quot;,
⋮----
format!(
⋮----
}).collect();
⋮----
let html = format!(
⋮----
vec![SlideOutput {
⋮----
pub struct PocExamplesSlidePlugin;
⋮----
impl SlidePlugin for PocExamplesSlidePlugin {
⋮----
!ctx.data.poc_examples.is_empty()
⋮----
let total_examples = data.poc_examples.len();
let total_available = data.total_threats.max(total_examples as u64) as usize;
⋮----
.iter()
.filter(|ex| ex.risk_score.unwrap_or(0.0) &gt;= 0.6)
.count();
⋮----
.filter_map(|ex| ex.detection_minutes)
.collect();
let avg_detection_mins = if !detection_times.is_empty() {
detection_times.iter().sum::&lt;i64&gt;() / detection_times.len() as i64
⋮----
let examples_html: String = data.poc_examples.iter().take(4).map(|ex| {
⋮----
let img_html = ex.screenshot_url.as_ref().map(|url| {
format!(r#&quot;&lt;div class=&quot;relative overflow-hidden rounded-t-lg&quot;&gt;&lt;img src=&quot;{}&quot; class=&quot;w-full h-28 object-cover&quot; alt=&quot;screenshot&quot;/&gt;&lt;div class=&quot;absolute inset-0 bg-gradient-to-t from-black/80 to-transparent&quot;&gt;&lt;/div&gt;&lt;/div&gt;&quot;#, url)
}).unwrap_or_else(|| r#&quot;&lt;div class=&quot;w-full h-28 bg-gradient-to-br from-zinc-800 to-zinc-900 rounded-t-lg flex items-center justify-center&quot;&gt;&lt;svg class=&quot;w-10 h-10 text-zinc-600&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; viewBox=&quot;0 0 24 24&quot;&gt;&lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;1.5&quot; d=&quot;M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&quot;#.to_string());
⋮----
// Risk badge with visual indicator (🔴/🟠/🟡)
let risk = ex.risk_score.unwrap_or(0.5);
⋮----
let risk_label = t.get(risk_key);
⋮----
let detection_mins = ex.detection_minutes.unwrap_or(4);
let detection_badge = format!(&quot;&lt;{} min&quot;, detection_mins);
⋮----
let impact_html = if ex.has_login_form.unwrap_or(false) {
format!(r#&quot;&lt;div class=&quot;flex items-center gap-1 mt-1&quot;&gt;&lt;svg class=&quot;w-3 h-3 text-red-400&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&lt;path d=&quot;M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 016 0v2h2V7a5 5 0 00-5-5z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span class=&quot;text-xs text-red-400&quot;&gt;{}&lt;/span&gt;&lt;/div&gt;&quot;#, t.get(&quot;evidence_credential_capture&quot;))
⋮----
&quot;&quot;.to_string()
⋮----
let no_data_html = if data.poc_examples.is_empty() {</file><file path="crates/core/src/plugins/builtin/geospatial.rs">use super::helpers::footer_dark;
⋮----
use std::collections::HashMap;
⋮----
pub struct GeospatialSlidePlugin;
⋮----
impl SlidePlugin for GeospatialSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.deep_investigations.is_empty()
|| !ctx.data.latest_incidents.is_empty()
|| !ctx.data.resolved_takedowns.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
if !country.is_empty() {
*countries.entry(country.clone()).or_insert(0) += 1;
⋮----
if !hosting.is_empty() {
*isps.entry(hosting.clone()).or_insert(0) += 1;
⋮----
total_unique_ips.insert(ip.clone());
⋮----
if !inv.threat_type.is_empty() {
*threat_types.entry(inv.threat_type.clone()).or_insert(0) += 1;
⋮----
if !inv.target.is_empty() {
total_unique_hosts.insert(inv.target.clone());
⋮----
if !reg.is_empty() {
*registrars.entry(reg.clone()).or_insert(0) += 1;
⋮----
if !inc.country.is_empty() {
*countries.entry(inc.country.clone()).or_insert(0) += 1;
⋮----
if !inc.isp.is_empty() {
*isps.entry(inc.isp.clone()).or_insert(0) += 1;
⋮----
if !inc.ip.is_empty() {
total_unique_ips.insert(inc.ip.clone());
⋮----
if !inc.host.is_empty() {
total_unique_hosts.insert(inc.host.clone());
⋮----
if !inc.ticket_type.is_empty() {
*threat_types.entry(inc.ticket_type.clone()).or_insert(0) += 1;
⋮----
if !td.country.is_empty() {
*countries.entry(td.country.clone()).or_insert(0) += 1;
⋮----
if !isp.is_empty() {
*isps.entry(isp.clone()).or_insert(0) += 1;
⋮----
if !td.ip.is_empty() {
total_unique_ips.insert(td.ip.clone());
⋮----
if !td.host.is_empty() {
total_unique_hosts.insert(td.host.clone());
⋮----
if !td.ticket_type.is_empty() {
*threat_types.entry(td.ticket_type.clone()).or_insert(0) += 1;
⋮----
let mut sorted: Vec&lt;_&gt; = map.into_iter().collect();
sorted.sort_by(|a, b| b.1.cmp(&amp;a.1));
sorted.into_iter().take(limit).collect()
⋮----
let top_countries = sort_top(countries, 5);
let top_isps = sort_top(isps, 4);
let top_registrars = sort_top(registrars, 3);
let top_threats = sort_top(threat_types, 4);
let ip_count = total_unique_ips.len();
let host_count = total_unique_hosts.len();
⋮----
if items.is_empty() {
⋮----
.to_string();
⋮----
let total: u32 = items.iter().map(|(_, c)| *c).sum();
items.iter().map(|(name, count)| {
⋮----
format!(
⋮----
}).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;&quot;)
⋮----
// ─── Threat type badges ───
let threat_badges_html = if top_threats.is_empty() {
⋮----
top_threats.iter().map(|(tt, count)| {
let (label, badge_color) = match tt.as_str() {
⋮----
_ =&gt; (tt.as_str(), &quot;zinc&quot;),
⋮----
}).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot; &quot;)
⋮----
// ─── Top country flag-style badges ───
let country_badges_html = if top_countries.is_empty() {
r#&quot;&lt;div class=&quot;text-zinc-600 text-sm italic&quot;&gt;Sin datos geográficos&lt;/div&gt;&quot;#.to_string()
⋮----
top_countries.iter().map(|(country, count)| {
⋮----
// Header
⋮----
&amp;t.get(&quot;geo_title&quot;),
Some(&quot;Perfil forense agregado del atacante basado en infraestructura, registradores y patrones de hosting.&quot;),
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/intro.rs">pub struct IntroSlidePlugin;
⋮----
impl SlidePlugin for IntroSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
t.get(&quot;intro_text_dynamic&quot;)
⋮----
t.get(&quot;intro_text_static&quot;)
⋮----
let html = format!(
⋮----
.replace(&quot;#FF671F&quot;, &quot;var(--color-primary)&quot;)
⋮----
.replace(&quot;bg-orange-500&quot;, &quot;bg-brand-primary&quot;)
.replace(&quot;text-orange-500&quot;, &quot;text-brand-primary&quot;);
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/mod.rs">pub mod ai_intent;
pub mod closing;
pub mod comparative;
pub mod cover;
pub mod credentials;
pub mod data_exposure;
pub mod examples;
pub mod geospatial;
pub mod google_slides;
pub mod heatmap;
pub mod helpers;
pub mod incidents;
pub mod insights;
pub mod intro;
pub mod kill_chain;
pub mod metrics;
pub mod poc_data;
pub mod radar;
pub mod roi;
pub mod solutions;
pub mod style_showcase;
pub mod takedowns;
pub mod theme;
pub mod threat_intel;
pub mod threats;
pub mod timeline;
pub mod toc;
pub mod velocity;
pub mod virality;
⋮----
pub use ai_intent::AiIntentSlidePlugin;
pub use closing::ClosingSlidePlugin;
pub use comparative::ComparativeSlidePlugin;
pub use cover::CoverSlidePlugin;
pub use credentials::CredentialsSlidePlugin;
pub use data_exposure::DataExposureSlidePlugin;
⋮----
pub use geospatial::GeospatialSlidePlugin;
pub use heatmap::HeatmapSlidePlugin;
pub use incidents::IncidentsSlidePlugin;
pub use insights::InsightsSlidePlugin;
pub use intro::IntroSlidePlugin;
pub use kill_chain::KillChainSlidePlugin;
pub use metrics::MetricsSlidePlugin;
pub use poc_data::PocDataSlidePlugin;
pub use radar::RadarSlidePlugin;
pub use roi::RoiSlidePlugin;
pub use solutions::SolutionsSlidePlugin;
pub use style_showcase::StyleShowcasePlugin;
pub use takedowns::TakedownsSlidePlugin;
pub use threat_intel::ThreatIntelSlidePlugin;
pub use threats::ThreatsSlidePlugin;
pub use timeline::TimelineSlidePlugin;
pub use toc::TocSlidePlugin;
pub use velocity::VelocitySlidePlugin;
pub use virality::ViralitySlidePlugin;</file><file path="crates/core/src/plugins/builtin/roi.rs">use super::helpers::footer_dark;
⋮----
pub struct RoiSlidePlugin;
⋮----
impl SlidePlugin for RoiSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
format!(&quot;{:.1}&quot;, metrics.analysts_equivalent_monthly)
⋮----
format!(&quot;{:.0}%&quot;, metrics.analysts_equivalent_monthly * 100.0)
⋮----
Some(&quot;Más allá de la protección, Axur devuelve recursos críticos a su organización. Transformamos el gasto en seguridad en eficiencia operativa.&quot;)
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/virality.rs">use super::helpers::footer_dark;
⋮----
pub struct ViralitySlidePlugin;
⋮----
impl SlidePlugin for ViralitySlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
.iter()
.map(|p| {
format!(
⋮----
.join(&quot;&quot;);
⋮----
// Generate Dynamic Insights (Storytelling)
// This is where we translate raw data into business intelligence
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/report/mod.rs">pub mod html;
pub mod language_switcher;
pub mod template_renderer;
⋮----
pub struct OfflineAssets {
⋮----
impl OfflineAssets {
⋮----
pub fn load_embedded() -&gt; Self {
⋮----
tailwind_js: include_str!(&quot;../../assets/tailwind.js&quot;).to_string(),
chart_js: include_str!(&quot;../../assets/chart.min.js&quot;).to_string(),
fabric_js: include_str!(&quot;../../assets/fabric.min.js&quot;).to_string(),
office_image_base64: include_str!(&quot;../../assets/cover_image_base64.txt&quot;).to_string(),
⋮----
mod tests {
⋮----
fn test_offline_assets_embedded() {
⋮----
assert!(
⋮----
assert!(!assets.chart_js.is_empty(), &quot;Chart JS should not be empty&quot;);</file><file path="crates/core/src/lib.rs">pub mod api;
pub mod editor;
pub mod error_codes;
pub mod errors;
pub mod i18n;
pub mod plugins;
pub mod pptx_mapper;
pub mod report;
⋮----
pub mod templates;</file><file path="crates/core/src/plugins/builtin/data_exposure.rs">pub struct DataExposureSlidePlugin;
⋮----
impl SlidePlugin for DataExposureSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
((secrets_count as f64 * 10.0 + creds_count as f64 * 0.5) as u32).min(100);
⋮----
let html = format!(
⋮----
// COGNITIVE EMPTYING HEADER
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/insights.rs">pub struct InsightsSlidePlugin;
⋮----
impl SlidePlugin for InsightsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
ctx.data.total_tickets &gt;= 5 &amp;&amp; ctx.config.is_plugin_enabled(self.id())
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let insights = generate_insights(data);
⋮----
let title = t.get(&quot;insights_title&quot;);
⋮----
.iter()
.map(render_insight_card)
⋮----
.join(&quot;\n&quot;);
⋮----
let html = format!(
⋮----
vec![SlideOutput {
⋮----
impl InsightsSlidePlugin {
fn render_footer(footer_text: String) -&gt; String {
format!(
⋮----
/// Insight with priority and recommendation
struct Insight {
⋮----
struct Insight {
⋮----
enum Priority {
⋮----
impl Priority {
fn label(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn generate_insights(data: &amp;crate::api::report::PocReportData) -&gt; Vec&lt;Insight&gt; {
⋮----
insights.push(Insight {
⋮----
title: &quot;Exposición de Credenciales Elevada&quot;.to_string(),
description: format!(
⋮----
action: &quot;Activar MFA y revisar políticas de contraseñas&quot;.to_string(),
⋮----
title: &quot;Tasa de Takedown Baja&quot;.to_string(),
⋮----
action: &quot;Escalar con proveedores y revisar SLAs&quot;.to_string(),
⋮----
title: &quot;Secretos en Código Expuestos&quot;.to_string(),
⋮----
action: &quot;Rotar credenciales y auditar repositorios&quot;.to_string(),
⋮----
.filter(|t| t.threat_type.to_lowercase().contains(&quot;phishing&quot;))
.map(|t| t.count)
.sum();
⋮----
title: &quot;Campañas de Phishing Activas&quot;.to_string(),
⋮----
action: &quot;Alertar a clientes y reforzar awareness&quot;.to_string(),
⋮----
.filter(|t| {
t.threat_type.to_lowercase().contains(&quot;social&quot;)
|| t.threat_type.to_lowercase().contains(&quot;fake&quot;)
⋮----
title: &quot;Suplantación en Redes Sociales&quot;.to_string(),
description: format!(&quot;{} perfiles falsos identificados.&quot;, social_count),
⋮----
action: &quot;Reportar a plataformas y monitorear VIPs&quot;.to_string(),
⋮----
title: &quot;Excelente Tasa de Resolución&quot;.to_string(),
⋮----
action: &quot;Mantener el proceso actual y documentar&quot;.to_string(),
⋮----
title: &quot;Volumen de Amenazas Elevado&quot;.to_string(),
⋮----
action: &quot;Evaluar automatización y priorización&quot;.to_string(),
⋮----
if insights.is_empty() {
⋮----
title: &quot;Postura de Seguridad Estable&quot;.to_string(),
description: &quot;No se detectaron anomalías críticas en el período.&quot;.to_string(),
⋮----
action: &quot;Continuar monitoreo proactivo&quot;.to_string(),
⋮----
insights.sort_by_key(|i| match i.priority {
⋮----
insights.truncate(6);
⋮----
fn render_insight_card(insight: &amp;Insight) -&gt; String {
⋮----
insight.priority.label(),
&amp;format!(&quot;{} {}&quot;, insight.icon, insight.title),
⋮----
fn generate_action_summary(insights: &amp;[Insight]) -&gt; String {
⋮----
.filter(|i| matches!(i.priority, Priority::Critical))
.count();
⋮----
.filter(|i| matches!(i.priority, Priority::High))
⋮----
&quot;La postura de seguridad es estable. Continuar con monitoreo proactivo.&quot;.to_string()
⋮----
mod tests {
⋮----
fn test_priority_labels() {
assert_eq!(Priority::Critical.label(), &quot;CRÍTICA&quot;);
assert_eq!(Priority::Low.label(), &quot;BAJA&quot;);
⋮----
fn test_plugin_metadata() {
⋮----
assert_eq!(plugin.id(), &quot;builtin.insights&quot;);
assert_eq!(plugin.priority(), 25);</file><file path="crates/core/src/plugins/builtin/metrics.rs">pub struct MetricsSlidePlugin;
⋮----
impl SlidePlugin for MetricsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
format!(&quot;{:.1}&quot;, analysts_saved)
⋮----
format!(&quot;{:.0}%&quot;, analysts_saved * 100.0)
⋮----
Some(&quot;Cada incidente procesado manualmente consume tiempo que su equipo podría dedicar a decisiones estratégicas. Esta es la diferencia medida.&quot;)
⋮----
let html = format!(
⋮----
.replace(&quot;text-orange-500&quot;, &quot;text-brand-primary&quot;)
.replace(&quot;bg-orange-500&quot;, &quot;bg-brand-primary&quot;)
.replace(&quot;ring-orange-500&quot;, &quot;ring-brand-primary&quot;)
.replace(
⋮----
.replace(&quot;from-orange-500&quot;, &quot;from-[var(--color-primary)]&quot;);
⋮----
vec![SlideOutput {
⋮----
mod tests {
⋮----
fn test_format_number() {
assert_eq!(format_number(0), &quot;0&quot;);
assert_eq!(format_number(100), &quot;100&quot;);
assert_eq!(format_number(1234), &quot;1,234&quot;);
assert_eq!(format_number(1234567), &quot;1,234,567&quot;);
⋮----
fn test_plugin_metadata() {
⋮----
assert_eq!(plugin.id(), &quot;builtin.metrics&quot;);
assert_eq!(plugin.name(), &quot;General Metrics&quot;);
assert_eq!(plugin.priority(), 90);</file><file path="crates/core/src/plugins/builtin/takedowns.rs">pub struct TakedownsSlidePlugin;
⋮----
impl SlidePlugin for TakedownsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let resolved_pct = calc_pct(data.takedown_resolved);
let pending_pct = calc_pct(data.takedown_pending);
let aborted_pct = calc_pct(data.takedown_aborted);
let unresolved_pct = calc_pct(data.takedown_unresolved);
⋮----
Some(&quot;Axur eliminó amenazas activas en nombre de su organización. Cada takedown representa un riesgo que ya no existe.&quot;)
⋮----
let html = format!(
⋮----
// Left Column
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/timeline.rs">use super::helpers::footer_dark;
⋮----
pub struct TimelineSlidePlugin;
⋮----
impl SlidePlugin for TimelineSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.story_tickets.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let total_events = data.story_tickets.len();
⋮----
.iter()
.filter(|t| t.status == &quot;closed&quot;)
.count();
⋮----
.filter(|t| t.status == &quot;incident&quot;)
⋮----
let _active_count = total_events.saturating_sub(closed_count + incident_count);
⋮----
.entry(ticket.threat_type.as_str())
.or_insert(0) += 1;
⋮----
.max_by_key(|(_, c)| *c)
.map(|(k, _)| *k)
.unwrap_or(&quot;N/A&quot;);
⋮----
.take(6)
.map(|ticket| {
let severity = match ticket.status.as_str() {
⋮----
.collect();
⋮----
let html = format!(
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/toc.rs">pub struct TocSlidePlugin;
⋮----
impl SlidePlugin for TocSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
struct TocChapter {
⋮----
let total_threats: u64 = data.threats_by_type.iter().map(|t| t.count).sum();
⋮----
kpi_value: format_number(total_threats),
⋮----
enabled: !data.threats_by_type.is_empty(),
⋮----
kpi_value: format_number(data.credentials_total + data.secrets_total),
⋮----
kpi_value: format_number(data.incidents_by_type.iter().map(|i| i.incidents).sum()),
⋮----
enabled: !data.incidents_by_type.is_empty(),
⋮----
kpi_value: format!(&quot;{:.0}%&quot;, data.takedown_success_rate),
⋮----
kpi_value: data.takedown_median_uptime.clone(),
⋮----
.iter()
.any(|td| td.request_date.is_some() &amp;&amp; td.resolution_date.is_some()),
⋮----
kpi_value: format!(&quot;{}&quot;, data.total_tickets),
⋮----
kpi_value: &quot;ROI&quot;.to_string(),
⋮----
let enabled: Vec&lt;&amp;TocChapter&gt; = chapters.iter().filter(|c| c.enabled).collect();
⋮----
.enumerate()
.map(|(idx, ch)| {
⋮----
format!(
⋮----
.collect();
⋮----
// ─── Summary stats bar (top-level numbers) ───
let stats_html = format!(
⋮----
// ─── Chapter count ──
let chapter_count = enabled.len();
⋮----
let html = format!(
⋮----
.replace(
⋮----
.replace(&quot;bg-orange-500/40&quot;, &quot;bg-[rgba(255,103,31,0.4)]&quot;);
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/registry.rs">use crate::api::report::PocReportData;
⋮----
pub struct PluginRegistry {
⋮----
impl Default for PluginRegistry {
fn default() -&gt; Self {
⋮----
impl PluginRegistry {
⋮----
pub fn new() -&gt; Self {
⋮----
pub fn with_builtins() -&gt; Self {
⋮----
registry.register_slide(Box::new(CoverSlidePlugin));
registry.register_slide(Box::new(IntroSlidePlugin));
registry.register_slide(Box::new(SolutionsSlidePlugin));
registry.register_slide(Box::new(TocSlidePlugin));
registry.register_slide(Box::new(PocDataSlidePlugin));
registry.register_slide(Box::new(MetricsSlidePlugin));
registry.register_slide(Box::new(ComparativeSlidePlugin));
registry.register_slide(Box::new(TimelineSlidePlugin));
registry.register_slide(Box::new(ThreatsSlidePlugin));
registry.register_slide(Box::new(ViralitySlidePlugin));
registry.register_slide(Box::new(AiIntentSlidePlugin));
registry.register_slide(Box::new(DataExposureSlidePlugin));
registry.register_slide(Box::new(GeospatialSlidePlugin));
registry.register_slide(Box::new(HeatmapSlidePlugin));
registry.register_slide(Box::new(RadarSlidePlugin));
registry.register_slide(Box::new(IncidentsSlidePlugin));
registry.register_slide(Box::new(TakedownsSlidePlugin));
registry.register_slide(Box::new(KillChainSlidePlugin));
registry.register_slide(Box::new(VelocitySlidePlugin));
registry.register_slide(Box::new(CredentialsSlidePlugin));
registry.register_slide(Box::new(RoiSlidePlugin));
registry.register_slide(Box::new(ThreatIntelSlidePlugin));
registry.register_slide(Box::new(TakedownExamplesSlidePlugin));
registry.register_slide(Box::new(PocExamplesSlidePlugin));
registry.register_slide(Box::new(InsightsSlidePlugin));
registry.register_slide(Box::new(StyleShowcasePlugin));
registry.register_slide(Box::new(ClosingSlidePlugin));
⋮----
pub fn register_slide(&amp;mut self, plugin: Box&lt;dyn SlidePlugin&gt;) {
self.slide_plugins.push(plugin);
⋮----
self.slide_plugins.sort_by_key(|p| -p.priority());
⋮----
pub fn register_data(&amp;mut self, plugin: Box&lt;dyn DataPlugin&gt;) {
self.data_plugins.push(plugin);
self.data_plugins.sort_by_key(|p| -p.priority());
⋮----
pub fn register_export(&amp;mut self, plugin: Box&lt;dyn ExportPlugin&gt;) {
self.export_plugins.push(plugin);
⋮----
pub fn register_cloud_export(&amp;mut self, plugin: Box&lt;dyn CloudExportPlugin&gt;) {
self.cloud_export_plugins.push(plugin);
⋮----
pub fn slide_plugins(&amp;self) -&gt; &amp;[Box&lt;dyn SlidePlugin&gt;] {
⋮----
pub fn data_plugins(&amp;self) -&gt; &amp;[Box&lt;dyn DataPlugin&gt;] {
⋮----
pub fn export_plugin(&amp;self, format: &amp;str) -&gt; Option&lt;&amp;Box&lt;dyn ExportPlugin&gt;&gt; {
self.export_plugins.iter().find(|p| p.format() == format)
⋮----
pub fn cloud_export_plugin(&amp;self, provider: &amp;str) -&gt; Option&lt;&amp;Box&lt;dyn CloudExportPlugin&gt;&gt; {
⋮----
.iter()
.find(|p| p.provider() == provider)
⋮----
pub fn available_cloud_providers(&amp;self) -&gt; Vec&lt;(&amp;&apos;static str, &amp;&apos;static str)&gt; {
⋮----
.map(|p| (p.provider(), p.display_name()))
.collect()
⋮----
pub fn transform_data(&amp;self, data: &amp;mut PocReportData) {
⋮----
plugin.transform(data);
⋮----
pub fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
.filter(|p| p.is_enabled(ctx))
.flat_map(|p| p.generate_slides(ctx))
⋮----
pub fn stats(&amp;self) -&gt; RegistryStats {
⋮----
slide_plugins: self.slide_plugins.len(),
data_plugins: self.data_plugins.len(),
export_plugins: self.export_plugins.len(),
cloud_export_plugins: self.cloud_export_plugins.len(),
⋮----
pub struct RegistryStats {
⋮----
mod tests {
⋮----
fn test_empty_registry() {
⋮----
let stats = registry.stats();
assert_eq!(stats.slide_plugins, 0);
assert_eq!(stats.data_plugins, 0);
assert_eq!(stats.export_plugins, 0);
⋮----
fn test_registry_with_builtins() {
⋮----
assert_eq!(registry.slide_plugins().len(), 27);
⋮----
assert_eq!(registry.slide_plugins()[0].id(), &quot;builtin.style_showcase&quot;);
assert_eq!(registry.slide_plugins()[1].id(), &quot;builtin.cover&quot;);
assert_eq!(registry.slide_plugins()[26].id(), &quot;builtin.closing&quot;);</file><file path="crates/core/src/plugins/builtin/heatmap.rs">use super::helpers::footer_dark;
⋮----
pub struct HeatmapSlidePlugin;
⋮----
impl SlidePlugin for HeatmapSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
ctx.data.total_tickets &gt;= 10 &amp;&amp; ctx.config.is_plugin_enabled(self.id())
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let heatmap = generate_simulated_heatmap(data.total_tickets);
⋮----
let max_val = heatmap.iter().flatten().copied().max().unwrap_or(1);
⋮----
let title = t.get(&quot;heatmap_title&quot;);
⋮----
for (day_idx, day_data) in heatmap.iter().enumerate() {
for (hour, &amp;count) in day_data.iter().enumerate() {
⋮----
let bg_color = intensity_to_color(intensity);
⋮----
cells_html.push_str(&amp;format!(
⋮----
// Hour labels (0-23)
⋮----
hour_labels.push_str(&amp;format!(
⋮----
hour_labels.push_str(r#&quot;&lt;span&gt;&lt;/span&gt;&quot;#);
⋮----
// Day labels
⋮----
day_labels.push_str(&amp;format!(
⋮----
// Peak hours analysis
let (peak_day, peak_hour, peak_count) = find_peak(&amp;heatmap);
let peak_text = format!(
⋮----
// Premium Header
⋮----
&amp;if title.is_empty() {
&quot;Mapa de Calor de Ataques&quot;.to_string()
⋮----
Some(&amp;t.get(&quot;heatmap_desc&quot;)),
⋮----
let html = format!(
⋮----
let html = html.replace(&quot;ring-orange-500&quot;, &quot;ring-brand-primary&quot;);
⋮----
vec![SlideOutput {
⋮----
fn generate_simulated_heatmap(total_tickets: u64) -&gt; [[u32; 24]; 7] {
⋮----
for (day, day_row) in heatmap.iter_mut().enumerate() {
⋮----
for (hour, cell) in day_row.iter_mut().enumerate() {
⋮----
*cell = value.max(if total_tickets &gt; 100 { 1 } else { 0 });
⋮----
fn intensity_to_color(intensity: u32) -&gt; String {
⋮----
&quot;rgba(39, 39, 42, 0.5)&quot;.to_string()
⋮----
format!(&quot;rgba(255, 103, 31, {:.2})&quot;, alpha.min(1.0).max(0.1))
⋮----
fn find_peak(heatmap: &amp;[[u32; 24]; 7]) -&gt; (usize, usize, u32) {
⋮----
for (day, day_data) in heatmap.iter().enumerate() {
⋮----
mod tests {
⋮----
fn test_generate_heatmap() {
let heatmap = generate_simulated_heatmap(1000);
let total: u32 = heatmap.iter().flatten().sum();
assert!(total &gt; 0);
⋮----
fn test_intensity_to_color() {
assert!(intensity_to_color(0).contains(&quot;39, 39, 42&quot;));
assert!(intensity_to_color(50).contains(&quot;255, 75, 0&quot;));
assert!(intensity_to_color(100).contains(&quot;255, 75, 0&quot;));
⋮----
fn test_plugin_metadata() {
⋮----
assert_eq!(plugin.id(), &quot;builtin.heatmap&quot;);
assert_eq!(plugin.priority(), 60);</file><file path="crates/core/src/plugins/builtin/radar.rs">use super::helpers::footer_dark;
⋮----
pub struct RadarSlidePlugin;
⋮----
impl SlidePlugin for RadarSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
⋮----
ctx.data.total_tickets &gt;= 5 &amp;&amp; ctx.config.is_plugin_enabled(self.id())
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let dimensions = calculate_dimensions(data);
⋮----
let svg = generate_radar_svg(&amp;dimensions);
⋮----
let title = t.get(&quot;radar_title&quot;);
⋮----
let total_score: u32 = dimensions.iter().map(|d| d.score).sum();
let avg_score = total_score / dimensions.len().max(1) as u32;
⋮----
let html = format!(
⋮----
.replace(&quot;#FF671F&quot;, &quot;var(--color-primary)&quot;)
.replace(&quot;bg-orange-500&quot;, &quot;bg-brand-primary&quot;)
.replace(&quot;text-orange-400&quot;, &quot;text-brand-primary&quot;)
.replace(&quot;border-orange-500&quot;, &quot;border-brand-primary&quot;);
⋮----
vec![SlideOutput {
⋮----
struct ThreatDimension {
⋮----
/// Calculate threat dimension scores from report data
fn calculate_dimensions(data: &amp;crate::api::report::PocReportData) -&gt; Vec&lt;ThreatDimension&gt; {
⋮----
fn calculate_dimensions(data: &amp;crate::api::report::PocReportData) -&gt; Vec&lt;ThreatDimension&gt; {
// Phishing score based on threats
⋮----
.iter()
.filter(|t| t.threat_type.to_lowercase().contains(&quot;phishing&quot;))
.map(|t| t.count)
⋮----
let phishing_score = normalize_score(phishing_count, 100);
⋮----
// Credentials exposure
let creds_score = normalize_score(data.credentials_total, 500);
⋮----
// Code leaks
let leaks_score = normalize_score(data.secrets_total, 50);
⋮----
// Social media threats
⋮----
.filter(|t| {
t.threat_type.to_lowercase().contains(&quot;social&quot;)
|| t.threat_type.to_lowercase().contains(&quot;fake&quot;)
⋮----
let social_score = normalize_score(social_count, 50);
⋮----
// Brand abuse
⋮----
t.threat_type.to_lowercase().contains(&quot;brand&quot;)
|| t.threat_type.to_lowercase().contains(&quot;domain&quot;)
⋮----
let brand_score = normalize_score(brand_count, 30);
⋮----
// Takedown efficiency (inverted - high takedowns = lower risk)
⋮----
100 - (data.takedown_resolved * 100 / data.total_tickets.max(1)) as u32
⋮----
vec![
⋮----
/// Normalize a count to a 0-100 score
fn normalize_score(value: u64, max_expected: u64) -&gt; u32 {
⋮----
fn normalize_score(value: u64, max_expected: u64) -&gt; u32 {
((value as f64 / max_expected as f64) * 100.0).min(100.0) as u32
⋮----
/// Generate SVG radar chart with larger viewBox for labels
fn generate_radar_svg(dimensions: &amp;[ThreatDimension]) -&gt; String {
⋮----
fn generate_radar_svg(dimensions: &amp;[ThreatDimension]) -&gt; String {
⋮----
let n = dimensions.len() as f64;
⋮----
// Background circles (concentric rings)
⋮----
for (i, r) in [0.25, 0.5, 0.75, 1.0].iter().enumerate() {
circles.push_str(&amp;format!(
⋮----
// Scale labels on the axis (25, 50, 75, 100)
⋮----
// Axis lines and labels
⋮----
for (i, dim) in dimensions.iter().enumerate() {
⋮----
let x_end = cx + radius * 1.22 * angle.cos();
let y_end = cy + radius * 1.22 * angle.sin();
let x_line = cx + radius * angle.cos();
let y_line = cy + radius * angle.sin();
⋮----
// Axis line
axes.push_str(&amp;format!(
⋮----
// Label with score
⋮----
// Color based on score
⋮----
// Score under label
⋮----
// Data polygon
⋮----
let x = cx + r * angle.cos();
let y = cy + r * angle.sin();
⋮----
points.push(&apos; &apos;);
⋮----
points.push_str(&amp;format!(&quot;{:.1},{:.1}&quot;, x, y));
⋮----
dots.push_str(&amp;format!(
⋮----
format!(
⋮----
/// Generate dimension detail cards — compact 2-column layout
fn generate_dimension_cards(dimensions: &amp;[ThreatDimension]) -&gt; String {
⋮----
fn generate_dimension_cards(dimensions: &amp;[ThreatDimension]) -&gt; String {
dimensions.iter().map(|dim| {
⋮----
}).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;\n&quot;)
⋮----
mod tests {
⋮----
fn test_normalize_score() {
assert_eq!(normalize_score(50, 100), 50);
assert_eq!(normalize_score(200, 100), 100);
assert_eq!(normalize_score(0, 100), 0);
⋮----
fn test_plugin_metadata() {
⋮----
assert_eq!(plugin.id(), &quot;builtin.radar&quot;);
assert_eq!(plugin.priority(), 65);</file><file path="crates/core/src/plugins/builtin/theme.rs">pub mod colors {
⋮----
pub mod typography {
⋮----
/// Generate the Axur logo HTML with proper styling
pub fn axur_logo_styled(size: &amp;str) -&gt; String {
⋮----
pub fn axur_logo_styled(size: &amp;str) -&gt; String {
⋮----
format!(
⋮----
/// Generate a stat card with glow effect - large number Axur.com style
pub fn stat_card_glow(value: &amp;str, label: &amp;str, glow: bool) -&gt; String {
⋮----
pub fn stat_card_glow(value: &amp;str, label: &amp;str, glow: bool) -&gt; String {
⋮----
/// Generate a large stat card (5xl value)
pub fn stat_card_large(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
pub fn stat_card_large(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
.map(|s| format!(r#&quot;&lt;p class=&quot;text-xs text-zinc-500 mt-2&quot;&gt;{}&lt;/p&gt;&quot;#, s))
.unwrap_or_default();
⋮----
/// Generate a pill badge for percentages - Axur.com 200px radius style
pub fn pill_badge(text: &amp;str) -&gt; String {
⋮----
pub fn pill_badge(text: &amp;str) -&gt; String {
⋮----
/// Generate a ghost pill badge
pub fn pill_badge_ghost(text: &amp;str) -&gt; String {
⋮----
pub fn pill_badge_ghost(text: &amp;str) -&gt; String {
⋮----
/// Generate section header with badge
pub fn section_header(badge: &amp;str, title: &amp;str) -&gt; String {
⋮----
pub fn section_header(badge: &amp;str, title: &amp;str) -&gt; String {
⋮----
/// Generate a feature card with icon circle
pub fn feature_card(icon_svg: &amp;str, title: &amp;str, description: &amp;str) -&gt; String {
⋮----
pub fn feature_card(icon_svg: &amp;str, title: &amp;str, description: &amp;str) -&gt; String {
⋮----
/// Generate a threat category tag
pub fn threat_tag(text: &amp;str, orange: bool) -&gt; String {
⋮----
pub fn threat_tag(text: &amp;str, orange: bool) -&gt; String {
⋮----
pub fn progress_bar(percentage: f64, label: Option&lt;&amp;str&gt;) -&gt; String {
progress_bar_colored(percentage, label, &quot;orange&quot;)
⋮----
pub fn progress_bar_colored(percentage: f64, label: Option&lt;&amp;str&gt;, color: &amp;str) -&gt; String {
⋮----
.map(|l| {
⋮----
// ============================================
// PHASE 2: PREMIUM COMPONENT FUNCTIONS
⋮----
/// Hero stat card — massive glowing number with shimmer for highest-impact metrics
pub fn stat_card_hero(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
pub fn stat_card_hero(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
.map(|s| format!(r#&quot;&lt;p class=&quot;metric-context mt-3&quot;&gt;{}&lt;/p&gt;&quot;#, s))
⋮----
/// Hero XL stat card — even larger number for single dominant metrics (cover, ROI)
pub fn stat_card_hero_xl(value: &amp;str, label: &amp;str) -&gt; String {
⋮----
pub fn stat_card_hero_xl(value: &amp;str, label: &amp;str) -&gt; String {
⋮----
/// Critical severity stat card — red-pulsing for urgent/dangerous data
pub fn stat_card_critical(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
pub fn stat_card_critical(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
.map(|s| format!(r#&quot;&lt;p class=&quot;metric-context mt-2&quot;&gt;{}&lt;/p&gt;&quot;#, s))
⋮----
/// Success stat card — green-accented for positive outcomes (takedowns, savings)
pub fn stat_card_success(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
pub fn stat_card_success(value: &amp;str, label: &amp;str, sublabel: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
/// SVG risk gauge (semi-circle) — visual risk indicator 0-100
pub fn risk_gauge_svg(score: u32, label: &amp;str) -&gt; String {
⋮----
pub fn risk_gauge_svg(score: u32, label: &amp;str) -&gt; String {
let clamped = score.min(100);
// Arc calculation: semi-circle from 180° to 0° (left to right)
let angle = 180.0 - (clamped as f64 * 1.8); // 0=left, 100=right
⋮----
let cx = 100.0 + 80.0 * rad.cos();
let cy = 100.0 - 80.0 * rad.sin();
⋮----
// Use loop to find color or just conditions (SVG needs hex or var)
// We can use var(--color-primary) for the orange case.
⋮----
/// Enhanced section header with animated accent line
pub fn section_header_premium(badge: &amp;str, title: &amp;str, subtitle: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
pub fn section_header_premium(badge: &amp;str, title: &amp;str, subtitle: Option&lt;&amp;str&gt;) -&gt; String {
⋮----
.map(|s| {
⋮----
/// Next chapter teaser element (Zeigarnik effect — open loop)
pub fn next_chapter_teaser(label: &amp;str, title: &amp;str) -&gt; String {
⋮----
pub fn next_chapter_teaser(label: &amp;str, title: &amp;str) -&gt; String {
⋮----
// PHASE 3: NEW LAYOUT COMPONENTS (v3.0)
⋮----
/// Before/After comparison card — Anchor Contrast technique (Cialdini)
/// Use for showing improvements, threat reduction, or efficiency gains.
⋮----
/// Use for showing improvements, threat reduction, or efficiency gains.
pub fn comparison_card(
⋮----
pub fn comparison_card(
⋮----
/// Action recommendation card — CTA with priority badge and effort indicator.
/// Use for &quot;Sugerencias de Acción&quot; slides (Act 5: Need-Payoff).
⋮----
/// Use for &quot;Sugerencias de Acción&quot; slides (Act 5: Need-Payoff).
pub fn action_card(priority: &amp;str, title: &amp;str, description: &amp;str, effort: &amp;str) -&gt; String {
⋮----
pub fn action_card(priority: &amp;str, title: &amp;str, description: &amp;str, effort: &amp;str) -&gt; String {
let priority_color = match priority.to_lowercase().as_str() {
⋮----
/// Timeline entry — vertical timeline element for incident chronology.
/// Use for &quot;Incident Timeline&quot; slides (Act 2: Problem).
⋮----
/// Use for &quot;Incident Timeline&quot; slides (Act 2: Problem).
pub fn timeline_entry(date: &amp;str, title: &amp;str, description: &amp;str, severity: &amp;str) -&gt; String {
⋮----
pub fn timeline_entry(date: &amp;str, title: &amp;str, description: &amp;str, severity: &amp;str) -&gt; String {
let (dot_color, line_color) = match severity.to_lowercase().as_str() {</file><file path="crates/core/src/plugins/builtin/incidents.rs">pub struct IncidentsSlidePlugin;
⋮----
impl SlidePlugin for IncidentsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.incidents_by_type.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let total_detections: u64 = data.incidents_by_type.iter().map(|i| i.detections).sum();
⋮----
let mut sorted_incidents = data.incidents_by_type.clone();
sorted_incidents.sort_by(|a, b| b.detections.cmp(&amp;a.detections));
⋮----
.first()
.map(|i| i.detections)
.unwrap_or(1)
.max(1);
⋮----
.iter()
.take(7)
.map(|item| {
⋮----
Some(&amp;format!(
⋮----
.join(&quot;\n&lt;div class=&apos;h-4&apos;&gt;&lt;/div&gt;\n&quot;);
⋮----
&amp;format_number(total_detections),
⋮----
Some(&quot;Ruido Filtrado&quot;),
⋮----
let card_incidents = format!(
⋮----
&amp;format_number(resolved_count),
⋮----
Some(&quot;Protección Activa&quot;),
⋮----
let html = format!(
⋮----
// COGNITIVE EMPTYING: Label the threat category
⋮----
vec![SlideOutput {</file><file path="crates/core/src/plugins/builtin/threats.rs">pub struct ThreatsSlidePlugin;
⋮----
impl SlidePlugin for ThreatsSlidePlugin {
fn id(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn name(&amp;self) -&gt; &amp;&apos;static str {
⋮----
fn priority(&amp;self) -&gt; i32 {
⋮----
fn is_enabled(&amp;self, ctx: &amp;PluginContext) -&gt; bool {
!ctx.data.threats_by_type.is_empty()
⋮----
fn generate_slides(&amp;self, ctx: &amp;PluginContext) -&gt; Vec&lt;SlideOutput&gt; {
⋮----
let total_threats: u64 = data.threats_by_type.iter().map(|t| t.count).sum();
⋮----
.iter()
.map(|t| t.count)
.max()
.unwrap_or(1);
⋮----
let mut sorted_threats = data.threats_by_type.clone();
sorted_threats.sort_by(|a, b| b.count.cmp(&amp;a.count));
⋮----
.take(6)
.map(|threat| {
⋮----
let color = if threat.threat_type.to_lowercase().contains(&quot;phishing&quot;) {
⋮----
} else if threat.threat_type.to_lowercase().contains(&quot;brand&quot;) {
⋮----
Some(&amp;format!(
⋮----
.collect();
⋮----
let top_threat = sorted_threats.first();
let top_name = top_threat.map(|t| t.threat_type.as_str()).unwrap_or(&quot;N/A&quot;);
let top_count = top_threat.map(|t| t.count).unwrap_or(0);
⋮----
let html = format!(
⋮----
// LABELED: Naming the value (Validation) not the metric (Threats)
⋮----
.replace(&quot;#FF671F&quot;, &quot;var(--color-primary)&quot;)
.replace(&quot;bg-[#FF671F]&quot;, &quot;bg-brand-primary&quot;)
.replace(&quot;text-[#FF671F]&quot;, &quot;text-brand-primary&quot;)
.replace(&quot;border-[#FF671F]&quot;, &quot;border-brand-primary&quot;);
⋮----
vec![SlideOutput {</file><file path="crates/core/src/api/report.rs">use crate::api::retry::retry_api_call;
⋮----
use chrono::Local;
use regex::Regex;
⋮----
use std::fs;
use std::io::Write;
⋮----
async fn download_image_as_base64(
⋮----
let resp = retry_api_call(
⋮----
let res = client.get(url).header(&quot;Authorization&quot;, auth).send().await?;
⋮----
if res.status().is_server_error()
|| res.status() == reqwest::StatusCode::TOO_MANY_REQUESTS
⋮----
return Err(anyhow::anyhow!(
⋮----
Ok(res)
⋮----
.ok()?;
⋮----
if !resp.status().is_success() {
⋮----
.headers()
.get(&quot;content-type&quot;)
.and_then(|v| v.to_str().ok())
.unwrap_or_else(|| {
⋮----
if url.ends_with(&quot;.png&quot;) {
⋮----
} else if url.ends_with(&quot;.gif&quot;) {
⋮----
.to_string();
⋮----
let bytes = resp.bytes().await.ok()?;
⋮----
if bytes.len() &gt; 2_000_000 {
⋮----
let base64_str = general_purpose::STANDARD.encode(&amp;bytes);
Some(format!(&quot;data:{};base64,{}&quot;, content_type, base64_str))
⋮----
fn ensure_debug_dir() {
⋮----
fn log_api_call(endpoint_name: &amp;str, url: &amp;str, status: u16, success: bool, body: &amp;str) {
⋮----
if std::env::var(&quot;AXUR_DEBUG&quot;).unwrap_or_default() != &quot;1&quot; {
⋮----
ensure_debug_dir();
⋮----
let timestamp = Local::now().format(&quot;%Y%m%d_%H%M%S&quot;);
let filename = format!(&quot;debug_logs/{}_{}.json&quot;, endpoint_name, timestamp);
⋮----
let _ = file.write_all(body.as_bytes());
⋮----
let log_line = format!(
⋮----
.create(true)
.append(true)
.open(&quot;debug_logs/api_calls.log&quot;)
⋮----
let _ = log_file.write_all(log_line.as_bytes());
⋮----
let url_line = format!(&quot;    URL: {}\n&quot;, url);
let _ = log_file.write_all(url_line.as_bytes());
⋮----
let preview = if body.len() &gt; 500 { &amp;body[..500] } else { body };
let preview_line = format!(&quot;    Response preview: {}\n\n&quot;, preview.replace(&apos;\n&apos;, &quot; &quot;));
let _ = log_file.write_all(preview_line.as_bytes());
⋮----
pub struct TenantInfo {
⋮----
pub async fn fetch_available_tenants(token: &amp;str) -&gt; Result&lt;Vec&lt;TenantInfo&gt;&gt; {
let client = create_client()?;
let auth_header = format!(&quot;Bearer {}&quot;, token);
let url = format!(&quot;{}/customers/customers&quot;, API_URL);
⋮----
.get(&amp;url)
.header(&quot;Authorization&quot;, &amp;auth_header)
.send()
⋮----
return Ok(vec![]);
⋮----
let body = resp.text().await?;
⋮----
.into_iter()
.filter_map(|c| {
⋮----
let name = c.name.unwrap_or_else(|| key.clone());
Some(TenantInfo { key, name })
⋮----
.collect();
return Ok(tenants);
⋮----
Ok(vec![])
⋮----
pub struct IncidentStats {
⋮----
pub struct TicketTypeStat {
⋮----
pub struct MarketSegmentStats {
⋮----
pub struct MonthlyStat {
⋮----
pub struct TakedownStats {
⋮----
pub struct TakedownTotal {
⋮----
pub struct WebComplaintsResponse {
⋮----
pub struct WebComplaint {
⋮----
pub struct CredentialCount {
⋮----
pub struct RiskScore {
⋮----
pub struct PocReportData {
⋮----
impl PocReportData {
pub fn demo() -&gt; Self {
⋮----
company_name: &quot;Acme Corp (Mock)&quot;.to_string(),
partner_name: Some(&quot;Partner Security Ltd&quot;.to_string()),
tlp_level: &quot;AMBER&quot;.to_string(),
start_date: &quot;2024-01-01&quot;.to_string(),
end_date: &quot;2024-01-31&quot;.to_string(),
⋮----
brands: vec![
⋮----
threats_by_type: vec![
⋮----
malware_breakdown: vec![
⋮----
top_services: vec![
⋮----
platform_breakdown: vec![
⋮----
secret_types: vec![
⋮----
sources: vec![
⋮----
top_affected_domains: vec![NameValuePair {
⋮----
incidents_by_type: vec![
⋮----
takedown_median_time_to_notify: &quot;12 min&quot;.to_string(),
takedown_median_uptime: &quot;3.5 horas&quot;.to_string(),
takedowns_by_type: vec![
⋮----
poc_examples: vec![PocEvidence {
⋮----
takedown_examples: vec![TakedownExample {
⋮----
resolved_takedowns: vec![ResolvedTakedown {
⋮----
latest_incidents: vec![IncidentExample {
⋮----
top_repositories: vec![NameValuePair {
⋮----
secret_types_breakdown: vec![NameValuePair {
⋮----
leak_source_breakdown: vec![
⋮----
avg_takedown_time_hours: Some(4.5),
takedowns_by_platform: vec![NameValuePair {
⋮----
median_response_time: &quot;12 min&quot;.to_string(),
median_threat_exposure: &quot;3.5 horas&quot;.to_string(),
⋮----
story_tickets: vec![],
⋮----
deep_investigations: vec![],
credential_exposures: vec![],
critical_credentials: vec![],
⋮----
history: vec![400.0, 420.0, 450.0],
label: &quot;Medium&quot;.to_string(),
color: &quot;#FFA500&quot;.to_string(),
⋮----
comparison: Some(ComparisonData {
period_label: &quot;vs. Last Month&quot;.to_string(),
⋮----
pub struct ComparisonData {
⋮----
pub struct ThreatIntelligence {
⋮----
impl ThreatIntelligence {
⋮----
earliest_dark_web_date: Some(&quot;2024-12-19T14:30:00Z&quot;.to_string()),
dark_web_sources: vec![
⋮----
days_before_public: Some(3),
⋮----
platforms_detected: vec![
⋮----
top_access_urls: vec![
⋮----
ad_platforms: vec![&quot;Facebook&quot;.to_string(), &quot;Instagram&quot;.to_string()],
⋮----
pub struct StoryTicket {
⋮----
pub struct ThreatTypeCount {
⋮----
pub struct IncidentTypeCount {
⋮----
pub struct NameValuePair {
⋮----
pub struct PocEvidence {
⋮----
pub struct TakedownExample {
⋮----
pub struct ResolvedTakedown {
⋮----
pub struct IncidentExample {
⋮----
pub struct DeepInvestigationResult {
⋮----
pub struct InfrastructureInfo {
⋮----
pub struct EnrichedSignalData {
⋮----
pub struct ImpersonatedBrand {
⋮----
pub struct GeoInfo {
⋮----
struct SignalLakeSearchRequest {
⋮----
struct SignalLakeSearchInitResponse {
⋮----
struct SignalLakePollResponse {
⋮----
struct SignalLakePollResult {
⋮----
struct SignalLakeStatus {
⋮----
struct SignalLakeDataItem {
⋮----
struct SignalLakePagination {
⋮----
pub struct ThreatHuntingPreview {
⋮----
impl ThreatHuntingPreview {
pub fn compute_estimated_credits(&amp;mut self) {
⋮----
let pages = |count: u64| -&gt; u64 { count.div_ceil(10) };
self.estimated_credits = pages(self.signal_lake_count)
+ pages(self.credential_count)
+ pages(self.chat_message_count)
+ pages(self.forum_message_count);
⋮----
pub struct ThreatHuntingSamples {
⋮----
pub struct CodeLeaksSummary {
⋮----
pub struct CredentialLeaksSummary {
⋮----
pub struct DeepAnalyticsData {
⋮----
impl DeepAnalyticsData {
pub fn has_any_data(&amp;self) -&gt; bool {
⋮----
pub struct OperationalMetrics {
⋮----
pub type RoiMetrics = OperationalMetrics;
⋮----
impl OperationalMetrics {
⋮----
pub fn compute(data: &amp;PocReportData) -&gt; Self {
⋮----
let avg_response_minutes = parse_duration_to_minutes(&amp;data.takedown_median_time_to_notify);
⋮----
(data.takedown_resolved as f64 / total_takedowns as f64 * 100.0).min(100.0)
⋮----
(INDUSTRY_BENCHMARK_RESPONSE_HOURS / axur_hours).round()
⋮----
median_response_time: data.takedown_median_time_to_notify.clone(),
median_threat_exposure: data.takedown_median_uptime.clone(),
⋮----
pub fn format_hours(hours: f64) -&gt; String {
⋮----
format!(&quot;{:.1} días&quot;, days)
⋮----
format!(&quot;{:.0} horas&quot;, hours)
⋮----
format!(&quot;{:.1} horas&quot;, hours)
⋮----
format!(&quot;{:.0} minutos&quot;, hours * 60.0)
⋮----
pub fn format_analysts(fte: f64) -&gt; String {
⋮----
format!(&quot;{:.1} analistas/mes&quot;, fte)
⋮----
format!(&quot;{:.0}% de 1 analista&quot;, fte * 100.0)
⋮----
format!(
⋮----
fn parse_duration_to_minutes(duration: &amp;str) -&gt; f64 {
⋮----
if let Some(h_pos) = duration.find(&apos;h&apos;) {
if let Ok(hours) = duration[..h_pos].trim().parse::&lt;f64&gt;() {
⋮----
if let Some(m_pos) = duration.find(&apos;m&apos;) {
let start = duration.find(&apos;h&apos;).map(|p| p + 2).unwrap_or(0);
if let Ok(mins) = duration[start..m_pos].trim().parse::&lt;f64&gt;() {
⋮----
if let Some(s_pos) = duration.find(&apos;s&apos;) {
let start = duration.find(&apos;m&apos;).map(|p| p + 2).unwrap_or(0);
if let Ok(secs) = duration[start..s_pos].trim().parse::&lt;f64&gt;() {
⋮----
total_minutes = duration.parse().unwrap_or(0.0);
⋮----
struct CustomerApiResponse {
⋮----
struct CustomerItem {
⋮----
struct AssetItem {
⋮----
struct PropertyItem {
⋮----
struct StatsCountResponse {
⋮----
struct TicketsResponse {
⋮----
struct Pageable {
⋮----
struct TicketItem {
⋮----
struct TicketInfo {
⋮----
struct CurrentInfo {
⋮----
struct DateInfo {
⋮----
struct TakedownInfo {
⋮----
impl CurrentInfo {
fn open_date(&amp;self) -&gt; Option&lt;String&gt; {
self.open.as_ref().and_then(|o| o.date.clone())
⋮----
fn incident_date(&amp;self) -&gt; Option&lt;String&gt; {
self.incident.as_ref().and_then(|i| i.date.clone())
⋮----
fn close_date(&amp;self) -&gt; Option&lt;String&gt; {
self.close.as_ref().and_then(|c| c.date.clone())
⋮----
fn takedown_request_date(&amp;self) -&gt; Option&lt;String&gt; {
⋮----
.as_ref()
.and_then(|t| t.request.as_ref())
.and_then(|r| r.date.clone())
⋮----
fn takedown_resolution_date(&amp;self) -&gt; Option&lt;String&gt; {
⋮----
.and_then(|t| t.done.as_ref())
.and_then(|d| d.date.clone())
⋮----
struct SnapshotItem {
⋮----
struct AttachmentItem {
⋮----
struct CredentialsTotalResponse {
⋮----
struct CredentialsListResponse {
⋮----
struct CredentialDetection {
⋮----
struct CredentialInfo {
⋮----
struct GeoIpResponse {
⋮----
async fn resolve_ip_country(client: &amp;reqwest::Client, ip: &amp;str) -&gt; Option&lt;String&gt; {
let url = format!(&quot;http://ip-api.com/json/{}&quot;, ip);
match client.get(&amp;url).send().await {
⋮----
if resp.status().is_success() {
⋮----
return Some(geo.country);
⋮----
fn clamp_date_range(from: &amp;str, to: &amp;str, max_days: i64) -&gt; (String, String) {
use chrono::NaiveDate;
⋮----
.unwrap_or_else(|_| chrono::Local::now().date_naive());
⋮----
let days_diff = (to_date - from_date).num_days();
⋮----
return (new_from.format(&quot;%Y-%m-%d&quot;).to_string(), to.to_string());
⋮----
(from.to_string(), to.to_string())
⋮----
pub async fn fetch_full_report(
⋮----
use std::fs::OpenOptions;
⋮----
.open(&quot;debug_logs/trace_exec.txt&quot;)
⋮----
let _ = writeln!(file, &quot;fetch_full_report called at {}&quot;, chrono::Local::now());
⋮----
let auth = format!(&quot;Bearer {}&quot;, token);
⋮----
let (ticket_from, ticket_to) = clamp_date_range(from, to, 90);
⋮----
let customer = customer_data.unwrap_or_default();
let threats_map = threats_by_type.unwrap_or_default();
let tk = takedown_stats.unwrap_or(ReportTakedownStats {
⋮----
median_time_to_notify: &quot;N/A&quot;.to_string(),
median_uptime: &quot;N/A&quot;.to_string(),
⋮----
.map(|(k, v)| ThreatTypeCount {
⋮----
threats_vec.sort_by(|a, b| b.count.cmp(&amp;a.count));
⋮----
.iter()
.filter(|t| t.count &gt; 0 &amp;&amp; allowed_types.contains(&amp;t.threat_type.as_str()))
.take(3)
.map(|t| t.threat_type.clone())
⋮----
let evidence = smart_evidence.unwrap_or_default();
let code_summary = code_leaks_summary.unwrap_or(CodeLeaksSummary {
⋮----
exposure_platforms: vec![],
secret_types: vec![],
top_repositories: vec![],
⋮----
let takedown_ex = takedown_examples.unwrap_or_default();
let resolved_td = resolved_takedowns.unwrap_or_default();
let incidents = latest_incidents.unwrap_or_default();
let cred_summary = credential_leaks_summary.unwrap_or(CredentialLeaksSummary {
⋮----
sources: vec![],
⋮----
top_affected_domains: vec![],
⋮----
let open_count = total_open.unwrap_or(0);
let quarantine_count = total_quarantine.unwrap_or(0);
let incident_count = total_incident.unwrap_or(0);
let treatment_count = total_treatment.unwrap_or(0);
let closed_count = total_closed.unwrap_or(0);
let creds_count = credentials_total.unwrap_or(0);
let leaks_count = code_leaks_total.unwrap_or(0);
⋮----
let total_threats: u64 = threats_vec.iter().map(|t| t.count).sum();
⋮----
.take(10)
.map(|t| IncidentTypeCount {
incident_type: t.threat_type.clone(),
⋮----
let mut deep_analytics = compute_deep_analytics(&amp;code_summary, &amp;cred_summary, &amp;resolved_td);
⋮----
deep_analytics.avg_takedown_time_hours = Some(uptime_hours);
⋮----
let manual_sum = (resolved_td.len() as u64) + (incidents.len() as u64);
⋮----
start_date: from.to_string(),
end_date: to.to_string(),
⋮----
malware_breakdown: vec![],
top_services: vec![],
⋮----
takedowns_by_type: vec![],
⋮----
resolved_takedowns: resolved_td.clone(),
⋮----
story_tickets: story_tickets_res.unwrap_or_default(),
⋮----
risk_score: calculate_risk_score_v3(&amp;risk_metrics),
⋮----
.first()
.cloned()
.unwrap_or_else(|| report.company_name.clone());
⋮----
fetch_threat_intelligence(&amp;client, &amp;auth, &amp;query, from, to).await
⋮----
let deep_investigations = if !report.story_tickets.is_empty() &amp;&amp; include_threat_intel {
⋮----
investigate_tagged_tickets(&amp;client, &amp;auth, tenant_id, &amp;report.story_tickets).await
⋮----
vec![]
⋮----
Ok(report_with_roi)
⋮----
fn compute_deep_analytics(
⋮----
analytics.secret_types_breakdown = code_summary.secret_types.clone();
analytics.top_repositories = code_summary.top_repositories.clone();
⋮----
analytics.leak_source_breakdown = cred_summary.sources.clone();
analytics.top_affected_domains = cred_summary.top_affected_domains.clone();
⋮----
if takedowns.len() &gt;= 3 {
⋮----
let hours = (res_dt - req_dt).num_hours() as f64;
⋮----
let platform = match td.host.as_str() {
h if h.contains(&quot;facebook&quot;) =&gt; &quot;Facebook&quot;,
h if h.contains(&quot;instagram&quot;) =&gt; &quot;Instagram&quot;,
h if h.contains(&quot;tiktok&quot;) =&gt; &quot;TikTok&quot;,
h if h.contains(&quot;twitter&quot;) || h.contains(&quot;x.com&quot;) =&gt; &quot;Twitter/X&quot;,
h if h.contains(&quot;linkedin&quot;) =&gt; &quot;LinkedIn&quot;,
h if h.contains(&quot;youtube&quot;) =&gt; &quot;YouTube&quot;,
⋮----
*platform_counts.entry(platform.to_string()).or_insert(0) += 1;
⋮----
analytics.avg_takedown_time_hours = Some(total_hours / count_with_dates as f64);
⋮----
.map(|(name, value)| NameValuePair { name, value })
⋮----
platforms.sort_by(|a, b| b.value.cmp(&amp;a.value));
⋮----
struct CustomerData {
⋮----
async fn fetch_customer_data(
⋮----
let resp = match retry_api_call(
⋮----
.header(&quot;Authorization&quot;, auth)
⋮----
.map_err(|e| anyhow::anyhow!(e))?;
⋮----
return Err(anyhow::anyhow!(&quot;API Error {}&quot;, res.status()));
⋮----
log_api_call(&quot;fetch_customer_data&quot;, &amp;url, 500, false, &amp;e.to_string());
return Ok(CustomerData::default());
⋮----
let status = resp.status().as_u16();
let success = resp.status().is_success();
⋮----
log_api_call(&quot;fetch_customer_data&quot;, &amp;url, status, false, &quot;Request failed&quot;);
⋮----
let text = resp.text().await?;
log_api_call(
⋮----
&amp;format!(&quot;{} bytes received&quot;, text.len()),
⋮----
let customers: Vec&lt;CustomerItem&gt; = serde_json::from_str(&amp;text).unwrap_or_default();
⋮----
.filter_map(|c| c.key.clone())
.take(20)
⋮----
&amp;format!(&quot;Looking for: {}&quot;, tenant_id),
⋮----
&amp;format!(
⋮----
.find(|c| c.key.as_deref() == Some(tenant_id) || c.name.as_deref() == Some(tenant_id));
⋮----
if customer.is_none() {
⋮----
name: customer.name.unwrap_or_default(),
⋮----
brands: vec![],
⋮----
match asset.category.as_deref() {
⋮----
data.brands.push(name.clone());
⋮----
if prop.key.as_deref() == Some(&quot;partner&quot;) {
⋮----
data.partner = val.as_str().map(|s| s.to_string());
⋮----
return Ok(data);
⋮----
Ok(CustomerData::default())
⋮----
async fn fetch_ticket_count(
⋮----
let url = format!(
⋮----
let resp_result = retry_api_call(
⋮----
&amp;format!(&quot;fetch_ticket_count_{}&quot;, status),
⋮----
&amp;format!(&quot;fetch_ticket_count_{}_FAILED&quot;, status),
⋮----
&amp;e.to_string(),
⋮----
return Ok(0);
⋮----
let http_status = resp.status().as_u16();
⋮----
let text = resp.text().await.unwrap_or_default();
⋮----
&amp;format!(&quot;fetch_ticket_count_{}&quot;, http_status),
⋮----
serde_json::from_str(&amp;text).unwrap_or(StatsCountResponse { total: None });
Ok(data.total.unwrap_or(0))
⋮----
async fn fetch_ticket_count_all(
⋮----
&amp;format!(&quot;fetch_ticket_count_all_{}&quot;, status),
⋮----
let total = data.total.unwrap_or(0);
⋮----
Ok(total)
⋮----
async fn fetch_threats_by_type_map(
⋮----
return Ok(HashMap::new());
⋮----
log_api_call(&quot;fetch_threats_by_type_map&quot;, &amp;url, status, true, &amp;text);
⋮----
struct ThreatTypeItem {
⋮----
struct ThreatsResponse {
⋮----
let parsed: ThreatsResponse = serde_json::from_str(&amp;text).unwrap_or(ThreatsResponse {
⋮----
data.insert(item.threat_type, item.total_on_period);
⋮----
Ok(data)
⋮----
async fn fetch_credentials_total_all(
⋮----
log_api_call(&quot;fetch_credentials_total&quot;, &amp;url, status, success, &amp;text);
⋮----
struct CredentialsSearchResponse {
⋮----
serde_json::from_str(&amp;text).unwrap_or(CredentialsSearchResponse { pageable: None });
Ok(data.pageable.and_then(|p| p.total).unwrap_or(0))
⋮----
async fn fetch_code_leaks_count(
⋮----
log_api_call(&quot;fetch_code_leaks_count&quot;, &amp;url, status, true, &amp;text);
⋮----
let data: TicketsResponse = serde_json::from_str(&amp;text).unwrap_or(TicketsResponse {
tickets: vec![],
⋮----
pub struct ReportTakedownStats {
⋮----
async fn fetch_takedown_stats_full(
⋮----
return Ok(ReportTakedownStats {
⋮----
struct TakedownResp {
⋮----
struct TakedownTotals {
⋮----
log_api_call(&quot;fetch_takedown_stats&quot;, &amp;url, status, true, &amp;text);
⋮----
let data: TakedownResp = serde_json::from_str(&amp;text).unwrap_or(TakedownResp { total: None });
⋮----
let t = data.total.unwrap_or(TakedownTotals {
⋮----
.replace(&quot;PT&quot;, &quot;&quot;)
.replace(&quot;H&quot;, &quot;h &quot;)
.replace(&quot;M&quot;, &quot;m &quot;)
.replace(&quot;S&quot;, &quot;s&quot;)
.to_lowercase(),
None =&gt; &quot;N/A&quot;.to_string(),
⋮----
Ok(ReportTakedownStats {
resolved: t.resolved.unwrap_or(0),
pending: t.pending.unwrap_or(0),
aborted: t.aborted.unwrap_or(0),
success_rate: t.success_rate.unwrap_or(0.0),
median_time_to_notify: format_duration(t.median_time_to_first_notification),
median_uptime: format_duration(t.median_uptime),
unresolved: t.unresolved.unwrap_or(0),
⋮----
async fn fetch_evidence_samples(
⋮----
let resp = client.get(&amp;url).header(&quot;Authorization&quot;, auth).send().await;
⋮----
if response.status().is_success() {
⋮----
for ticket in data.tickets.into_iter().take(per_type) {
let ticket_info = ticket.ticket.as_ref();
let current = ticket.current.as_ref();
⋮----
.find(|a| {
⋮----
.map(|n| n.ends_with(&quot;.jpg&quot;) || n.ends_with(&quot;.png&quot;))
.unwrap_or(false)
|| a.type_.as_deref() == Some(&quot;screenshot&quot;)
|| a.type_.as_deref() == Some(&quot;image&quot;)
⋮----
.and_then(|a| a.url.clone());
⋮----
all_evidence.push(PocEvidence {
evidence_type: threat_type.to_string(),
⋮----
.and_then(|t| t.ticket_key.clone())
.unwrap_or_default(),
⋮----
.and_then(|t| t.reference.clone())
⋮----
status: current.and_then(|c| c.status.clone()).unwrap_or_default(),
ip: current.and_then(|c| c.ip.clone()),
isp: current.and_then(|c| c.isp.clone()),
⋮----
.and_then(|c| c.domain.clone())
.or_else(|| current.and_then(|c| c.host.clone())),
⋮----
Ok(all_evidence)
⋮----
async fn fetch_smart_evidence(
⋮----
for threat_type in top_types.iter().take(3) {
⋮----
&amp;format!(&quot;fetch_smart_evidence_{}&quot;, threat_type),
⋮----
let status = response.status().as_u16();
⋮----
if let Ok(text) = response.text().await {
⋮----
for ticket in data.tickets.into_iter().take(examples_per_type) {
⋮----
let url = a.url.as_deref().unwrap_or(&quot;&quot;);
let name = a.name.as_deref().unwrap_or(&quot;&quot;);
url.ends_with(&quot;.png&quot;)
|| url.ends_with(&quot;.jpg&quot;)
|| url.ends_with(&quot;.jpeg&quot;)
|| name.ends_with(&quot;.png&quot;)
|| name.ends_with(&quot;.jpg&quot;)
|| name.ends_with(&quot;.jpeg&quot;)
⋮----
download_image_as_base64(client, auth, img_url).await
⋮----
reported_date: current.and_then(|c| c.open_date()),
⋮----
.and_then(|c| c.prediction_risk.as_ref())
.and_then(|s| s.parse::&lt;f64&gt;().ok()),
⋮----
.and_then(|c| c.prediction_brand_logo.as_ref())
⋮----
has_login_form: current.and_then(|c| {
c.prediction_has_auth_form.as_ref().map(|s| s == &quot;true&quot;)
⋮----
async fn fetch_code_leaks_summary(
⋮----
return Ok(CodeLeaksSummary {
⋮----
log_api_call(&quot;fetch_code_leaks_summary&quot;, &amp;url, status, true, &amp;text);
⋮----
let total = data.pageable.as_ref().and_then(|p| p.total).unwrap_or(0);
⋮----
let api_key_re = Regex::new(r&quot;(?i)api.?key|apikey|token&quot;).unwrap();
let db_pass_re = Regex::new(r&quot;(?i)db|database|sql|postgres|mysql|mongodb|password&quot;).unwrap();
let cloud_re = Regex::new(r&quot;(?i)aws|gcp|azure|cloud|access.?key|secret.?access&quot;).unwrap();
let ssh_re = Regex::new(r&quot;(?i)ssh|private.?key|rsa|ecdsa&quot;).unwrap();
let jwt_re = Regex::new(r&quot;(?i)jwt|oauth|bearer&quot;).unwrap();
⋮----
let url_str = ticket_info.reference.as_deref().unwrap_or(&quot;&quot;);
let platform = hostname_to_platform(url_str);
*platform_counts.entry(platform.clone()).or_insert(0) += 1;
⋮----
// Try to extract repo from URL
if let Some(repo) = extract_repo_from_url(url_str) {
*repo_counts.entry(repo).or_insert(0) += 1;
⋮----
// Classify secret type based on name/fields
⋮----
.unwrap_or_default();
⋮----
let secret_type = if api_key_re.is_match(&amp;name) {
⋮----
} else if db_pass_re.is_match(&amp;name) {
⋮----
} else if cloud_re.is_match(&amp;name) {
⋮----
} else if ssh_re.is_match(&amp;name) {
⋮----
} else if jwt_re.is_match(&amp;name) {
⋮----
.entry(secret_type.to_string())
.or_insert(0) += 1;
⋮----
exposure_platforms.sort_by(|a, b| b.value.cmp(&amp;a.value));
⋮----
secret_types.sort_by(|a, b| b.value.cmp(&amp;a.value));
⋮----
.map(|(name, value)| NameValuePair {
name: name.clone(),
⋮----
top_repositories.sort_by(|a, b| b.value.cmp(&amp;a.value));
top_repositories.truncate(5);
⋮----
Ok(CodeLeaksSummary {
⋮----
unique_repos: repo_counts.len() as u64,
⋮----
fn hostname_to_platform(url: &amp;str) -&gt; String {
let url_lower = url.to_lowercase();
if url_lower.contains(&quot;github.com&quot;) {
&quot;GitHub&quot;.to_string()
} else if url_lower.contains(&quot;gitlab.com&quot;) {
&quot;GitLab&quot;.to_string()
} else if url_lower.contains(&quot;bitbucket.org&quot;) {
&quot;Bitbucket&quot;.to_string()
} else if url_lower.contains(&quot;pastebin.com&quot;) {
&quot;Pastebin&quot;.to_string()
} else if url_lower.contains(&quot;gist.github.com&quot;) {
&quot;GitHub Gist&quot;.to_string()
⋮----
&quot;Other&quot;.to_string()
⋮----
fn extract_repo_from_url(url: &amp;str) -&gt; Option&lt;String&gt; {
⋮----
if url_lower.contains(&quot;github.com&quot;)
|| url_lower.contains(&quot;gitlab.com&quot;)
|| url_lower.contains(&quot;bitbucket.org&quot;)
⋮----
let parts: Vec&lt;&amp;str&gt; = url.split(&apos;/&apos;).filter(|p| !p.is_empty()).collect();
⋮----
if parts.len() &gt;= 4 {
return Some(format!(&quot;{}/{}&quot;, parts[2], parts[3]));
⋮----
async fn fetch_takedown_examples(
⋮----
log_api_call(&quot;fetch_takedown_examples&quot;, &amp;url, status, true, &amp;text);
⋮----
.map(|t| {
let ticket_info = t.ticket.as_ref();
let current = t.current.as_ref();
⋮----
.and_then(|ti| ti.reference.clone())
.unwrap_or_else(|| &quot;N/A&quot;.to_string()),
⋮----
.and_then(|c| c.type_.clone())
.unwrap_or_else(|| &quot;unknown&quot;.to_string()),
⋮----
.and_then(|c| c.status.clone())
⋮----
request_date: current.and_then(|c| c.takedown_request_date()),
⋮----
Ok(examples)
⋮----
async fn fetch_resolved_takedowns(
⋮----
log_api_call(&quot;fetch_resolved_takedowns&quot;, &amp;url, status, true, &amp;text);
⋮----
let snippet: String = text.chars().take(200).collect();
⋮----
let detection = t.detection.as_ref();
⋮----
let mut ip = current.and_then(|c| c.ip.clone()).unwrap_or_default();
if ip.is_empty() {
⋮----
if let Some(val) = d.get(&quot;ip&quot;).and_then(|v| v.as_str()) {
ip = val.to_string();
⋮----
let mut isp = current.and_then(|c| c.isp.clone()).unwrap_or_default();
if isp.is_empty() {
⋮----
if let Some(val) = d.get(&quot;isp&quot;).and_then(|v| v.as_str()) {
isp = val.to_string();
⋮----
if let Some(dom) = d.get(&quot;domain&quot;) {
if let Some(reg) = dom.get(&quot;registrar&quot;).and_then(|r| r.as_str()) {
registrar = Some(reg.to_string());
⋮----
let mut country = current.and_then(|c| c.country.clone()).unwrap_or_default();
if country.is_empty() &amp;&amp; !ip.is_empty() {
if let Some(c) = resolve_ip_country(client, &amp;ip).await {
⋮----
resolved_list.push(ResolvedTakedown {
⋮----
resolution_date: current.and_then(|c| c.takedown_resolution_date()),
host: current.and_then(|c| c.host.clone()).unwrap_or_default(),
⋮----
isp: if isp.is_empty() { None } else { Some(isp) },
⋮----
Ok(resolved_list)
⋮----
async fn fetch_latest_incidents(
⋮----
&amp;format!(&quot;fetch_latest_incidents_{}&quot;, incident_type),
⋮----
for t in data.tickets.into_iter().take(page_size) {
⋮----
if let Some(reg) = dom.get(&quot;registrar&quot;).and_then(|r| r.as_str())
⋮----
current.and_then(|c| c.country.clone()).unwrap_or_default();
⋮----
a.url.as_ref().is_some_and(|u| {
u.ends_with(&quot;.png&quot;)
|| u.ends_with(&quot;.jpg&quot;)
|| u.ends_with(&quot;.jpeg&quot;)
}) || a.name.as_ref().is_some_and(|n| {
n.ends_with(&quot;.png&quot;)
|| n.ends_with(&quot;.jpg&quot;)
|| n.ends_with(&quot;.jpeg&quot;)
⋮----
all_incidents.push(IncidentExample {
⋮----
.and_then(|ti| ti.ticket_key.clone())
⋮----
ticket_type: incident_type.to_string(),
⋮----
.unwrap_or_else(|| &quot;incident&quot;.to_string()),
open_date: current.and_then(|c| c.open_date()),
incident_date: current.and_then(|c| c.incident_date()),
⋮----
Ok(all_incidents)
⋮----
async fn fetch_credential_leaks_summary(
⋮----
return Ok(CredentialLeaksSummary {
⋮----
log_api_call(&quot;fetch_credential_leaks_summary&quot;, &amp;url, status, true, &amp;text);
⋮----
struct CredDetection {
⋮----
struct ExposureResponse {
⋮----
let data: ExposureResponse = serde_json::from_str(&amp;text).unwrap_or(ExposureResponse {
detections: vec![],
⋮----
let sample_size = data.detections.len() as f64;
⋮----
let fmt = d.leak_format.as_deref().unwrap_or(&quot;UNKNOWN&quot;);
*sources_map.entry(fmt.to_string()).or_insert(0) += 1;
⋮----
if fmt.to_uppercase().contains(&quot;STEALER&quot;) {
⋮----
if ptype.to_uppercase() == &quot;PLAIN&quot; {
⋮----
unique_emails.insert(u.to_string());
if let Some(domain) = u.split(&apos;@&apos;).next_back() {
*domain_counts.entry(domain.to_string()).or_insert(0) += 1;
⋮----
(unique_emails.len() as f64 * ratio) as u64,
⋮----
(stealer_count, plain_count, unique_emails.len() as u64)
⋮----
.map(|(k, v)| NameValuePair {
⋮----
sources_vec.sort_by(|a, b| b.value.cmp(&amp;a.value));
⋮----
top_affected_domains.sort_by(|a, b| b.value.cmp(&amp;a.value));
top_affected_domains.truncate(5);
⋮----
Ok(CredentialLeaksSummary {
⋮----
pub struct PocReport {
⋮----
pub struct LegacyIncidentType {
⋮----
pub async fn fetch_report_data(
⋮----
let full = fetch_full_report(token, tenant_id, from, to, None, false).await?;
⋮----
Ok(PocReport {
tenant_id: tenant_id.to_string(),
⋮----
.map(|t| LegacyIncidentType {
⋮----
.collect(),
⋮----
async fn fetch_tagged_tickets(
⋮----
Some(t) if !t.is_empty() =&gt; t,
⋮----
let key = ticket.ticket_key.unwrap_or_default();
⋮----
val.get(flat_field)
.and_then(|v| v.as_str())
.map(|s| s.to_string())
.or_else(|| {
val.get(field)
.and_then(|obj| obj.get(&quot;date&quot;))
⋮----
.get(&quot;creation.date&quot;)
⋮----
.map(|s| s.to_string());
let open_date = extract_date(&amp;detection, &quot;open&quot;, &quot;open.date&quot;);
let incident_date = extract_date(&amp;detection, &quot;incident&quot;, &quot;incident.date&quot;);
let close_date = extract_date(&amp;detection, &quot;close&quot;, &quot;close.date&quot;);
⋮----
.clone()
.or_else(|| open_date.clone())
.unwrap_or_else(|| &quot;N/A&quot;.to_string());
⋮----
let fmt_date = if date.len() &gt;= 10 {
format!(&quot;{}/{}/{}&quot;, &amp;date[8..10], &amp;date[5..7], &amp;date[0..4])
⋮----
let host = detection.get(&quot;host&quot;).and_then(|v| v.as_str());
let domain = detection.get(&quot;domain&quot;).and_then(|v| v.as_str());
⋮----
.or_else(|| domain.map(|s| s.to_string()))
.or(ticket.reference.clone())
.unwrap_or_else(|| &quot;Unknown Target&quot;.to_string());
⋮----
.get(&quot;prediction.risk&quot;)
⋮----
.and_then(|s| s.parse::&lt;f64&gt;().ok());
⋮----
.get(&quot;prediction.brand-logo&quot;)
⋮----
.get(&quot;content&quot;)
.and_then(|c| c.get(&quot;title&quot;))
.and_then(|t| t.as_str())
⋮----
let time_to_incident_hours = compute_hours_between(&amp;creation_date, &amp;incident_date);
let incident_age_hours = incident_date.as_ref().and_then(|d| compute_hours_since(d));
⋮----
.get(&quot;type&quot;)
⋮----
.unwrap_or_default()
⋮----
let desc = format!(&quot;{} on {}&quot;, &amp;threat_type, &amp;target);
⋮----
.get(&quot;isp&quot;)
⋮----
.get(&quot;ip&quot;)
⋮----
.get(&quot;status&quot;)
⋮----
.unwrap_or(&quot;open&quot;)
⋮----
story_tickets.push(StoryTicket {
⋮----
Ok(story_tickets)
⋮----
pub async fn fetch_tagged_tickets_for_preview(
⋮----
if debug_dir.exists() {
let timestamp = chrono::Utc::now().format(&quot;%Y%m%d_%H%M%S&quot;);
let debug_file = debug_dir.join(format!(&quot;fetch_tickets_request_{}.txt&quot;, timestamp));
let content = format!(
⋮----
let tickets = fetch_tagged_tickets(&amp;client, &amp;auth, tenant_id, Some(tag)).await?;
⋮----
let debug_file = debug_dir.join(format!(&quot;fetch_tickets_result_{}.json&quot;, timestamp));
let targets: Vec&lt;_&gt; = tickets.iter().map(|t| &amp;t.target).collect();
⋮----
Ok(tickets)
⋮----
fn compute_hours_between(from: &amp;Option&lt;String&gt;, to: &amp;Option&lt;String&gt;) -&gt; Option&lt;i64&gt; {
let from = from.as_ref()?;
let to = to.as_ref()?;
let from_dt = chrono::DateTime::parse_from_rfc3339(from).ok()?;
let to_dt = chrono::DateTime::parse_from_rfc3339(to).ok()?;
Some((to_dt - from_dt).num_hours())
⋮----
fn compute_hours_since(date: &amp;str) -&gt; Option&lt;i64&gt; {
let dt = chrono::DateTime::parse_from_rfc3339(date).ok()?;
⋮----
Some((now - dt.with_timezone(&amp;chrono::Utc)).num_hours())
⋮----
pub enum ThreatHuntingSource {
⋮----
impl ThreatHuntingSource {
fn as_str(&amp;self) -&gt; &amp;&apos;static str {
⋮----
/// Request body for starting a threat hunting search
#[derive(Debug, Serialize)]
struct ThreatSearchRequest {
⋮----
struct DateRange {
⋮----
/// Response from starting a search
#[derive(Debug, Deserialize)]
struct ThreatSearchStartResponse {
⋮----
id: Option&lt;String&gt;, // Alternative field name
⋮----
impl ThreatSearchStartResponse {
fn get_id(&amp;self) -&gt; Option&lt;&amp;str&gt; {
self.search_id.as_deref().or(self.id.as_deref())
⋮----
/// Response from polling search results
#[derive(Debug, Deserialize)]
struct ThreatSearchResultsResponse {
⋮----
data: Vec&lt;ThreatSearchResult&gt;, // Alternative field name
⋮----
impl ThreatSearchResultsResponse {
fn get_results(&amp;self) -&gt; &amp;[ThreatSearchResult] {
if !self.results.is_empty() {
⋮----
fn is_complete(&amp;self) -&gt; bool {
⋮----
.as_deref()
.map(|s| s.eq_ignore_ascii_case(&quot;COMPLETED&quot;))
⋮----
/// Individual search result
#[derive(Debug, Deserialize, Clone)]
struct ThreatSearchResult {
⋮----
/// Start a threat hunting search (async)
async fn start_threat_search(
⋮----
async fn start_threat_search(
⋮----
let url = format!(&quot;{}/threat-hunting-api/external-search&quot;, API_URL);
⋮----
query: query.to_string(),
source: source.as_str().to_string(),
date_range: Some(DateRange {
from: from.to_string(),
to: to.to_string(),
⋮----
// Est. requests: 1 (with retries)
⋮----
.post(&amp;url)
⋮----
.json(&amp;request)
⋮----
&amp;format!(&quot;start_threat_search_{:?}&quot;, source),
⋮----
return Ok(None);
⋮----
let response: ThreatSearchStartResponse = resp.json().await?;
Ok(response.get_id().map(|s| s.to_string()))
⋮----
/// Poll for search results (async with timeout)
async fn poll_threat_search(
⋮----
async fn poll_threat_search(
⋮----
// Est. requests: 1 per attempt (wrapped in retry for transient network errors)
⋮----
// Note: We don&apos;t retry 404s or 400s here as they might be valid poll responses?
⋮----
if res.status().is_server_error() {
⋮----
&amp;format!(&quot;poll_threat_search_{}&quot;, search_id),
⋮----
let response: ThreatSearchResultsResponse = resp.json().await?;
⋮----
if response.is_complete() {
return Ok(response.get_results().to_vec());
⋮----
pub async fn fetch_threat_intelligence(
⋮----
let mut search_ids: Vec&lt;(ThreatHuntingSource, Option&lt;String&gt;)&gt; = vec![];
⋮----
let id = start_threat_search(client, auth, query, source, from, to)
⋮----
.ok()
.flatten();
search_ids.push((source, id));
⋮----
intel.dark_web_mentions = results.len() as u64;
⋮----
if earliest.as_ref().map(|e| date &lt; e).unwrap_or(true) {
earliest = Some(date.clone());
⋮----
.filter_map(|r| r.source_name.clone().or(r.source.clone()))
⋮----
intel.dark_web_sources = sources.into_iter().collect();
⋮----
intel.chat_group_shares = results.len() as u64;
⋮----
results.iter().filter_map(|r| r.platform.clone()).collect();
intel.platforms_detected.extend(platforms);
⋮----
intel.social_media_mentions = results.len() as u64;
⋮----
intel.total_credentials = results.len() as u64;
⋮----
let format_lower = format.to_lowercase();
if format_lower.contains(&quot;stealer&quot;) {
⋮----
} else if format_lower.contains(&quot;combo&quot;) {
⋮----
let type_lower = pwd_type.to_lowercase();
if type_lower.contains(&quot;plain&quot;) {
⋮----
if intel.top_access_urls.len() &lt; 5 &amp;&amp; !intel.top_access_urls.contains(url) {
intel.top_access_urls.push(url.clone());
⋮----
intel.paid_ads_detected = results.len() as u64;
⋮----
intel.ad_platforms = platforms.into_iter().collect();
⋮----
async fn start_signal_lake_search(
⋮----
query: format!(&quot;domain=\&quot;{}\&quot;&quot;, domain),
source: &quot;signal-lake&quot;.to_string(),
customer: Some(tenant_id.to_string()),
⋮----
let data: SignalLakeSearchInitResponse = resp.json().await?;
⋮----
.ok_or_else(|| anyhow::anyhow!(&quot;No searchId in response&quot;))
⋮----
async fn poll_signal_lake_results(
⋮----
let data: SignalLakePollResponse = resp.json().await?;
⋮----
async fn investigate_ticket(
⋮----
if domain.is_empty() {
⋮----
let search_id = match start_signal_lake_search(client, auth, tenant_id, domain).await {
⋮----
match poll_signal_lake_results(client, auth, &amp;search_id).await {
⋮----
.and_then(|r| r.status.as_ref())
.and_then(|s| s.running)
.unwrap_or(true);
⋮----
total_signals = pagination.total.unwrap_or(0);
⋮----
if !related_urls.contains(url) &amp;&amp; related_urls.len() &lt; 10 {
related_urls.push(url.clone());
⋮----
if !detection_dates.contains(date) {
detection_dates.push(date.clone());
⋮----
related_domains.insert(d.clone());
⋮----
if infra.ip.is_none() {
infra.ip = item.ip.clone();
infra.asn = item.asn.clone();
infra.hosting_provider = item.hosting_provider.clone();
infra.country = item.country.clone();
⋮----
if first_seen.is_none() {
first_seen = item.first_seen.clone();
⋮----
last_seen = item.last_seen.clone().or(last_seen);
⋮----
infra.related_domains = related_domains.into_iter().collect();
⋮----
let is_mass_campaign = infra.related_domains.len() &gt; 5 || total_signals &gt; 20;
⋮----
let enrichment = extract_enrichment_data(&amp;result_data);
⋮----
Some(DeepInvestigationResult {
ticket_key: ticket.ticket_key.clone(),
target: domain.clone(),
status: ticket.status.clone(),
threat_type: ticket.threat_type.clone(),
⋮----
fn extract_enrichment_data(items: &amp;[SignalLakeDataItem]) -&gt; EnrichedSignalData {
⋮----
.find(|item| item.screenshot_url.is_some() || item.ai_content_type.is_some())
.or_else(|| items.first());
⋮----
enrichment.screenshot_url = item.screenshot_url.clone();
⋮----
enrichment.ai_content_type = item.ai_content_type.clone();
enrichment.ai_image_description = item.ai_image_description.clone();
⋮----
.map(|v| v.eq_ignore_ascii_case(&quot;yes&quot;))
.unwrap_or(false);
⋮----
.map(|v| v.eq_ignore_ascii_case(&quot;yes&quot;) || v.eq_ignore_ascii_case(&quot;possibly&quot;))
⋮----
enrichment.predominant_language = item.predominant_language.clone();
enrichment.company_logos = item.company_logos.clone().unwrap_or_default();
⋮----
brands.push(ImpersonatedBrand {
brand: brand.clone(),
level: &quot;high&quot;.to_string(),
⋮----
level: &quot;medium&quot;.to_string(),
⋮----
level: &quot;low&quot;.to_string(),
⋮----
if item.country_codes.is_some() || item.isps.is_some() {
enrichment.geolocation = Some(GeoInfo {
ip: item.ip.clone(),
country_code: item.country_codes.as_ref().and_then(|v| v.first().cloned()),
country_name: item.country_names.as_ref().and_then(|v| v.first().cloned()),
isp: item.isps.as_ref().and_then(|v| v.first().cloned()),
⋮----
enrichment.detection_date = Some(format_unix_timestamp_ms(ts));
⋮----
enrichment.domain_created = Some(format_unix_timestamp_ms(ts));
⋮----
enrichment.registrar = item.registrar_name.clone();
⋮----
fn format_unix_timestamp_ms(timestamp_ms: i64) -&gt; String {
⋮----
match Utc.timestamp_opt(secs, 0) {
chrono::LocalResult::Single(dt) =&gt; dt.format(&quot;%b %d, %Y&quot;).to_string(),
_ =&gt; &quot;N/A&quot;.to_string(),
⋮----
pub async fn investigate_tagged_tickets(
⋮----
let tickets_to_process = tickets.iter().take(MAX_TICKETS_TO_INVESTIGATE);
⋮----
if let Some(result) = investigate_ticket(client, auth, tenant_id, ticket).await {
results.push(result);
⋮----
if let Some(base64) = download_image_as_base64(client, auth, screenshot_url).await {
result.enrichment.screenshot_base64 = Some(base64);
⋮----
pub struct CredentialExposure {
⋮----
struct CredentialSearchResponse {
⋮----
struct CredentialPageable {
⋮----
pub async fn fetch_tagged_credentials(
⋮----
if tag.is_empty() {
⋮----
let resp = match client.get(&amp;url).header(&quot;Authorization&quot;, auth).send().await {
⋮----
let count = body.pageable.as_ref().and_then(|p| p.total).unwrap_or(0);
⋮----
body.detections.unwrap_or_default()
⋮----
pub async fn fetch_critical_credentials(
⋮----
if tenant_id.is_empty() || tenant_id.eq_ignore_ascii_case(&quot;default&quot;) {
⋮----
async fn start_threat_hunting_search(
⋮----
customer: customer.map(|s| s.to_string()),
⋮----
let req_file = debug_dir.join(format!(
⋮----
let status = resp.status();
let resp_text = resp.text().await?;
⋮----
let resp_file = debug_dir.join(format!(
⋮----
let log_content = format!(
⋮----
if !status.is_success() {
⋮----
.ok_or_else(|| anyhow::anyhow!(&quot;No searchId in response&quot;));
⋮----
async fn poll_threat_hunting_count(
⋮----
let req_file = debug_dir.join(format!(&quot;th_get_request_{}_{}.txt&quot;, search_id, timestamp));
let req_content = format!(&quot;GET {}\nSearch ID: {}\n&quot;, url, search_id);
⋮----
let status_code = resp.status();
⋮----
if !status_code.is_success() {
⋮----
return Ok((0, vec![]));
⋮----
.get(&quot;result&quot;)
.and_then(|r| r.get(&quot;status&quot;))
.and_then(|s| s.get(&quot;running&quot;))
.and_then(|v| v.as_bool())
⋮----
.and_then(|r| r.get(&quot;pagination&quot;))
.and_then(|p| p.get(&quot;total&quot;))
.and_then(|v| v.as_u64())
.unwrap_or(0);
⋮----
.and_then(|r| r.get(&quot;data&quot;))
.and_then(|d| d.as_array())
.map(|items| {
⋮----
.filter_map(|item| {
item.get(&quot;url&quot;)
⋮----
item.get(&quot;domain&quot;)
⋮----
item.get(&quot;ip&quot;)
⋮----
item.get(&quot;name&quot;)
⋮----
item.get(&quot;accessUrl&quot;)
⋮----
item.get(&quot;access_url&quot;)
⋮----
.collect()
⋮----
return Ok((total, samples));
⋮----
pub async fn preview_threat_hunting(
⋮----
tickets_count: tickets.len().min(MAX_TICKETS_TO_INVESTIGATE),
⋮----
if !story_tag.is_empty() {
⋮----
let customer_param = if tenant_id.is_empty() || tenant_id.eq_ignore_ascii_case(&quot;default&quot;) {
⋮----
format!(&quot;&amp;customer={}&quot;, tenant_id)
⋮----
let exposure_url = format!(
⋮----
.get(&amp;exposure_url)
.header(&quot;Authorization&quot;, &amp;auth)
⋮----
if status.is_success() {
if let Ok(body) = resp.text().await {
⋮----
debug_dir.join(format!(&quot;exposure_credentials_{}.json&quot;, timestamp));
⋮----
json.get(&quot;detections&quot;).and_then(|d| d.as_array())
⋮----
preview.credential_count = detections.len() as u64;
⋮----
if let Some(pageable) = json.get(&quot;pageable&quot;) {
⋮----
pageable.get(&quot;total&quot;).and_then(|t| t.as_u64())
⋮----
for detection in detections.iter().take(5) {
⋮----
.get(&quot;user&quot;)
⋮----
.unwrap_or(&quot;&quot;)
⋮----
.get(&quot;access.url&quot;)
.or_else(|| detection.get(&quot;accessUrl&quot;))
⋮----
.get(&quot;user.emailDomain&quot;)
.or_else(|| detection.get(&quot;access.domain&quot;))
⋮----
.get(&quot;source.name&quot;)
⋮----
// Push a formatted string sample
let sample = if !access_url.is_empty() {
format!(&quot;{} @ {}&quot;, user, access_url)
} else if !domain.is_empty() {
format!(&quot;{} ({})&quot;, user, domain)
⋮----
user.clone()
⋮----
if !sample.is_empty() {
preview.samples.credentials.push(sample);
⋮----
if !ticket.target.is_empty() {
domains.insert(ticket.target.clone());
⋮----
domains.into_iter().take(5).collect()
⋮----
let debug_file = debug_dir.join(format!(&quot;phishing_domains_{}.txt&quot;, timestamp));
⋮----
if unique_domains.is_empty() &amp;&amp; search_ids.is_empty() {
return Ok(preview);
⋮----
Some(tenant_id)
⋮----
let query = format!(&quot;domain=\&quot;{}\&quot;&quot;, domain);
⋮----
match start_threat_hunting_search(
⋮----
search_ids.push((ThreatHuntingSource::SignalLake, id, domain.clone()));
⋮----
match poll_threat_hunting_count(&amp;client, &amp;auth, &amp;search_id).await {
⋮----
if preview.samples.signal_lake.len() &lt; 3 {
preview.samples.signal_lake.extend(
⋮----
.take(3 - preview.samples.signal_lake.len()),
⋮----
preview.compute_estimated_credits();
⋮----
Ok(preview)
⋮----
pub async fn start_and_poll_th_search(
⋮----
let search_id = start_threat_hunting_search(client, auth, customer, query, source).await?;
⋮----
let (count, _samples) = poll_threat_hunting_count(client, auth, &amp;search_id).await?;
⋮----
Ok(count)
⋮----
pub struct TakedownStatsRaw {
⋮----
struct RiskMetricsRaw {
⋮----
async fn fetch_risk_score_metrics(
⋮----
let threats_url = format!(
⋮----
let benchmark_url = format!(
⋮----
let leaks_url = format!(
⋮----
let takedown_url = format!(
⋮----
let complaints_url = format!(
⋮----
async fn fetch_json_metric&lt;T: for&lt;&apos;de&gt; Deserialize&lt;&apos;de&gt;&gt;(
⋮----
match client.get(url).header(&quot;Authorization&quot;, auth).send().await {
⋮----
resp.json::&lt;T&gt;().await.ok()
⋮----
fn calculate_risk_score_v3(data: &amp;RiskMetricsRaw) -&gt; RiskScore {
⋮----
let weight = match t.ticket_type.as_str() {
⋮----
let s1_volume = (threat_score_raw / 100.0).min(1.0) * 10.0;
⋮----
let median_last_month = bench.medians.last().map(|m| m.value).unwrap_or(0.0);
⋮----
.and_then(|s| s.total_by_ticket_type.as_ref())
.map(|v| v.iter().map(|t| t.count).sum())
⋮----
(ratio * 5.0).min(10.0)
⋮----
(leaks.total as f64 / 50.0).min(1.0) * 10.0
⋮----
let success_risk = ((100.0 - td.total.success_rate) / 10.0).max(0.0).min(10.0);
⋮----
let uptime_risk = (uptime_days / 5.0).min(1.0) * 10.0;
⋮----
(complaints.total_elements as f64 / 20.0).min(1.0) * 10.0
⋮----
let final_score = (total_score * 10.0).round();
⋮----
(&quot;Low Risk&quot;.to_string(), &quot;#28a745&quot;.to_string())
⋮----
(&quot;Moderate Risk&quot;.to_string(), &quot;#ffc107&quot;.to_string())
⋮----
(&quot;Critical Risk&quot;.to_string(), &quot;#dc3545&quot;.to_string())
⋮----
history: vec![],</file><file path="crates/core/src/report/html.rs">use super::OfflineAssets;
⋮----
use std::collections::HashMap;
⋮----
fn has_takedown_data(data: &amp;PocReportData) -&gt; bool {
⋮----
pub fn generate_full_report_html(
⋮----
return render_custom_template_report(data, slides, offline_assets, dict);
⋮----
let mut slides = vec![
⋮----
slides.retain(|s| !s.is_empty());
⋮----
if has_takedown_data(data) {
slides.push(render_narrative_slide(
dict.narrative_takedown_title(),
dict.narrative_takedown_pain(),
dict.narrative_takedown_solution(),
⋮----
slides.push(render_takedowns_realizados_slide(data, dict));
slides.push(render_impact_roi_slide(data, dict));
⋮----
if !data.credential_exposures.is_empty() {
slides.push(render_credential_slide(data, dict));
⋮----
if !data.resolved_takedowns.is_empty() {
slides.push(render_takedown_examples_slide(data, dict));
⋮----
slides.push(render_threat_intelligence_slide(data, dict));
⋮----
if !data.deep_investigations.is_empty() {
slides.push(render_deep_investigation_slide(data, &amp;**dict));
⋮----
slides.push(render_closing_full(data, offline_assets, dict));
⋮----
let all_slides = slides.join(&quot;\n&quot;);
⋮----
format!(&quot;&lt;script&gt;{}&lt;/script&gt;&quot;, assets.tailwind_js),
format!(&quot;&lt;script&gt;{}&lt;/script&gt;&quot;, assets.chart_js),
⋮----
&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;&quot;#.to_string(),
⋮----
use super::language_switcher;
⋮----
format!(
⋮----
/// Generate report HTML using the plugin system
///
⋮----
///
/// This is the new modular approach that uses PluginRegistry.
⋮----
/// This is the new modular approach that uses PluginRegistry.
/// It coexists with `generate_full_report_html` for backward compatibility.
⋮----
/// It coexists with `generate_full_report_html` for backward compatibility.
pub fn generate_report_with_plugins(
⋮----
pub fn generate_report_with_plugins(
⋮----
// Create registry with all builtin plugins
⋮----
// Build the plugin context with provided config or default
let plugin_config = config.unwrap_or_default();
⋮----
// Generate all slides from plugins
let slides = registry.generate_slides(&amp;ctx);
⋮----
.iter()
.map(|s| s.html.as_str())
⋮----
.join(&quot;\n&quot;);
⋮----
fn axur_design_system_css() -&gt; &amp;&apos;static str {
⋮----
fn render_custom_template_report(
⋮----
let date_str = data.end_date.clone();
⋮----
for (i, json) in slides.iter().enumerate() {
⋮----
let processed_json = inject_report_data(json, data);
⋮----
let canvas_id = format!(&quot;slide-canvas-{}&quot;, i);
⋮----
slides_html.push_str(&amp;format!(
⋮----
// JS to render this slide
init_scripts.push_str(&amp;format!(
⋮----
format!(&quot;&lt;script&gt;{}&lt;/script&gt;&quot;, assets.fabric_js)
⋮----
r#&quot;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js&quot;&gt;&lt;/script&gt;&quot;#.to_string()
⋮----
// =====================
// EXACT DESIGN SLIDES
⋮----
fn axur_logo() -&gt; &amp;&apos;static str {
⋮----
fn render_context_slide(
⋮----
} // Fallback icon, maybe telephone was wrong copy/paste. Let&apos;s use Code brackets logic or similar
⋮----
// Override leak icon with actual code brackets
⋮----
fn render_narrative_slide(
⋮----
fn render_cover_full(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
let partner_html = data.partner_name.as_ref().map(|p| format!(
⋮----
)).unwrap_or_default();
⋮----
(dict.cover_title_dynamic(), &quot;cover_title_dynamic&quot;)
⋮----
(dict.cover_title_static(), &quot;cover_title_static&quot;)
⋮----
fn render_intro_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
(dict.intro_text_dynamic(), &quot;intro_text_dynamic&quot;)
⋮----
(dict.intro_text_static(), &quot;intro_text_static&quot;)
⋮----
fn render_solutions_slide(dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
// Note: For brevity I only connected a few key titles - ideally ALL would be connected.
// Given complexity, I connected the main ones.
⋮----
fn render_toc_slide(dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
let items = dict.toc_items();
let items_html: String = items.iter().map(|item| format!(
⋮----
)).collect();
⋮----
fn render_poc_data_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
fn render_general_metrics_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
// Logic: 15 mins per ticket manually
⋮----
fn render_ai_intent_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
// 1. Aggregate types into New Categories
⋮----
// Initialize specific categories with 0 to ensure consistent colors/ordering if needed,
// or just let them populate dynamically. Let&apos;s populate dynamically but define order later.
⋮----
intents.insert(cat.to_string(), 0);
⋮----
let intent = map_threat_to_intent(&amp;t.threat_type);
*intents.entry(intent.to_string()).or_insert(0) += t.count;
⋮----
top_intent = k.as_str();
⋮----
&quot;trust&quot; =&gt; dict.intent_cat_trust(),
&quot;chat&quot; =&gt; dict.intent_cat_chat(),
&quot;compromised&quot; =&gt; dict.intent_cat_compromised(),
&quot;data_leak&quot; =&gt; dict.intent_cat_data_leak(),
&quot;vip&quot; =&gt; dict.intent_cat_vip(),
&quot;dark_web&quot; =&gt; dict.intent_cat_dark_web(),
_ =&gt; dict.intent_cat_fraud(),
⋮----
(dict.intent_fmt_primary(&amp;intent_name, percent), true)
⋮----
(dict.intent_fmt_fallback(), false)
⋮----
let mut sorted_intents: Vec&lt;(&amp;String, &amp;u64)&gt; = intents.iter().collect();
sorted_intents.sort_by(|a, b| b.1.cmp(a.1));
⋮----
let label = match k.as_str() {
⋮----
labels.push(label);
values.push(*v);
⋮----
let color = match k.as_str() {
⋮----
colors.push(color);
⋮----
let json_labels = serde_json::to_string(&amp;labels).unwrap_or_default();
let json_data = serde_json::to_string(&amp;values).unwrap_or_default();
let json_colors = serde_json::to_string(&amp;colors).unwrap_or_default();
⋮----
fn render_data_exposure_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
// 1. Infostealer Critical Section
let critical_html = if !data.critical_credentials.is_empty() {
let count = data.critical_credentials.len();
let examples: String = data.critical_credentials.iter().take(3).map(|c| {
let user = c.user.as_deref().unwrap_or(&quot;unknown&quot;);
let pass = c.password.as_deref().unwrap_or(&quot;***&quot;);
let masked_pass = if pass.len() &gt; 4 {
format!(&quot;{}...{}&quot;, &amp;pass[..2], &amp;pass[pass.len()-2..])
⋮----
&quot;***&quot;.to_string()
⋮----
}).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;&quot;);
⋮----
// Code Leak Data
⋮----
// Stealer Data
⋮----
action_stealer = dict.stealer_action(), // Reusing existing action text
⋮----
fn render_infostealer_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
// Generate Critical Section if data exists
⋮----
fn render_code_leak_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
fn render_incidents_chart_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
// Generate scale-agnostic labels
⋮----
.map(|t| t.incident_type.clone())
.collect();
⋮----
.map(|t| t.detections)
⋮----
fn render_takedowns_realizados_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
let donut_data = vec![
⋮----
let donut_json = serde_json::to_string(&amp;donut_data).unwrap_or_default();
let donut_labels = vec![
⋮----
let labels_json = serde_json::to_string(&amp;donut_labels).unwrap_or_default();
⋮----
req = data.total_tickets, // Or calculated requested from takedowns? &quot;takedowns requested&quot; usually resolved+pending+aborted+unresolved
⋮----
fn render_impact_roi_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
format!(&quot;{:.0}&quot;, metrics.person_days_saved)
⋮----
format!(&quot;{:.1}&quot;, metrics.hours_saved_total)
⋮----
dict.op_unit_person_days()
⋮----
dict.op_unit_hours()
⋮----
format!(&quot;{:.1}&quot;, metrics.analysts_equivalent_monthly)
⋮----
format!(&quot;{:.0}%&quot;, metrics.analysts_equivalent_monthly * 100.0)
⋮----
let median_minutes = calculate_median_takedown_minutes(&amp;data.resolved_takedowns);
⋮----
dict.roi_precise_title(),
format!(&quot;{} min&quot;, mins),
dict.roi_precise_text_primary(mins),
⋮----
dict.op_response_title(),
&quot;180x&quot;.to_string(),
dict.roi_precise_text_fallback(),
⋮----
fn map_threat_to_intent(threat_type: &amp;str) -&gt; &amp;&apos;static str {
let t = threat_type.to_lowercase();
⋮----
// 1. Chat Intelligence (Messages &amp; Dark Web Activity)
// Matches: data-sale-message, suspicious-activity-message, dw-activity, etc.
if t.contains(&quot;message&quot;) || t == &quot;dw-activity&quot; {
⋮----
if t.starts_with(&quot;executive-&quot;) {
⋮----
if t == &quot;ransomware-attack&quot; || t == &quot;infrastructure-exposure&quot; || t.contains(&quot;website&quot;) {
⋮----
fn calculate_median_takedown_minutes(takedowns: &amp;[ResolvedTakedown]) -&gt; Option&lt;i64&gt; {
⋮----
.filter_map(|td| {
⋮----
let dur = end.signed_duration_since(start).num_minutes();
⋮----
Some(dur)
⋮----
if durations.is_empty() {
⋮----
durations.sort();
Some(durations[durations.len() / 2])
⋮----
fn render_geospatial_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
if !td.country.is_empty() &amp;&amp; td.country != &quot;-&quot; {
*countries.entry(td.country.clone()).or_insert(0) += 1;
⋮----
if !isp.is_empty() &amp;&amp; isp != &quot;-&quot; {
*isps.entry(isp.clone()).or_insert(0) += 1;
⋮----
if !reg.is_empty() &amp;&amp; reg != &quot;-&quot; {
*registrars.entry(reg.clone()).or_insert(0) += 1;
⋮----
if !inc.isp.is_empty() &amp;&amp; inc.isp != &quot;-&quot; {
*isps.entry(inc.isp.clone()).or_insert(0) += 1;
⋮----
if !inc.country.is_empty() &amp;&amp; inc.country != &quot;-&quot; {
*countries.entry(inc.country.clone()).or_insert(0) += 1;
⋮----
if !c.is_empty() &amp;&amp; c != &quot;-&quot; {
*countries.entry(c.clone()).or_insert(0) += 1;
⋮----
let mut sorted_countries: Vec&lt;(&amp;String, &amp;u64)&gt; = countries.iter().collect();
sorted_countries.sort_by(|a, b| b.1.cmp(a.1));
let top_countries: Vec&lt;(&amp;String, &amp;u64)&gt; = sorted_countries.into_iter().take(10).collect();
⋮----
let mut sorted_isps: Vec&lt;(&amp;String, &amp;u64)&gt; = isps.iter().collect();
sorted_isps.sort_by(|a, b| b.1.cmp(a.1));
let top_isps: Vec&lt;(&amp;String, &amp;u64)&gt; = sorted_isps.iter().take(6).copied().collect();
⋮----
let mut sorted_registrars: Vec&lt;(&amp;String, &amp;u64)&gt; = registrars.iter().collect();
sorted_registrars.sort_by(|a, b| b.1.cmp(a.1));
let top_registrars: Vec&lt;(&amp;String, &amp;u64)&gt; = sorted_registrars.iter().take(6).copied().collect();
⋮----
if top_countries.is_empty() &amp;&amp; top_isps.is_empty() &amp;&amp; top_registrars.is_empty() {
⋮----
&quot;#.to_string();
⋮----
// Narrative
let total_countries = countries.len();
⋮----
let top_country = if !top_countries.is_empty() {
top_countries[0].0.as_str()
⋮----
(dict.geo_fmt_primary(total_countries, top_country), true)
⋮----
(dict.geo_fmt_fallback(), false)
⋮----
.map(|(k, _)| {
let flag = country_to_flag(k);
format!(&quot;{} {}&quot;, flag, k)
⋮----
let values: Vec&lt;u64&gt; = top_countries.iter().map(|(_, v)| **v).collect();
⋮----
isp_html.push_str(&amp;format!(
⋮----
// Registrars List HTML (Jurisdiction)
⋮----
registrar_html.push_str(&amp;format!(
⋮----
fn render_takedown_examples_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
let example_count = data.resolved_takedowns.len().min(3);
⋮----
for ex in data.resolved_takedowns.iter().take(3) {
⋮----
let date = ex.resolution_date.as_deref().unwrap_or(&quot;-&quot;);
⋮----
examples_html.push_str(&amp;format!(r#&quot;&lt;div class=&quot;bg-white p-6 rounded-lg shadow-md border border-zinc-200&quot;&gt;&lt;div class=&quot;mb-4&quot;&gt;{}&lt;/div&gt;&lt;div class=&quot;space-y-2&quot;&gt;&lt;p class=&quot;font-bold text-zinc-800 text-lg line-clamp-1&quot;&gt;{}&lt;/p&gt;&lt;p class=&quot;text-xs text-zinc-500&quot;&gt;&lt;span class=&quot;font-bold&quot;&gt;{}&lt;/span&gt; {}&lt;/p&gt;&lt;p class=&quot;text-xs text-zinc-500&quot;&gt;&lt;span class=&quot;font-bold&quot;&gt;{}&lt;/span&gt; {}&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&quot;#,
⋮----
examples_html = format!(
⋮----
fn render_poc_examples_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
// Group by type and show first few examples
let examples_html: String = if data.poc_examples.is_empty() {
⋮----
data.poc_examples.iter().take(6).map(|ex| {
let domain = ex.domain.as_deref().unwrap_or(&quot;N/A&quot;);
let status_color = match ex.status.as_str() {
⋮----
Some(url) if !url.is_empty() =&gt; format!(
⋮----
_ =&gt; format!(r#&quot;&lt;div class=&quot;w-full h-32 bg-zinc-100 rounded-lg overflow-hidden mb-3 flex items-center justify-center text-zinc-400 text-xs&quot;&gt;{}&lt;/div&gt;&quot;#, dict.example_no_image())
⋮----
format!(r#&quot;&lt;div class=&quot;bg-white p-4 rounded-xl shadow-lg border border-zinc-200&quot;&gt;{screenshot}&lt;div class=&quot;flex justify-between items-start mb-2&quot;&gt;&lt;span class=&quot;font-bold text-zinc-800&quot;&gt;{ticket}&lt;/span&gt;&lt;span class=&quot;text-xs px-2 py-1 rounded {status_color}&quot;&gt;{status}&lt;/span&gt;&lt;/div&gt;&lt;p class=&quot;text-sm text-zinc-600 mb-2&quot;&gt;{type_name}&lt;/p&gt;&lt;p class=&quot;text-xs text-blue-500 truncate&quot;&gt;{domain}&lt;/p&gt;&lt;/div&gt;&quot;#,
⋮----
}).collect()
⋮----
// CAMPAIGN DETECTION
⋮----
/// Campaign detection result
struct CampaignInfo {
⋮----
struct CampaignInfo {
⋮----
tickets: Vec&lt;usize&gt;, // Indices into original tickets
⋮----
date_range: (String, String), // Start, End
⋮----
/// Detect campaigns by grouping incidents with shared infrastructure or timing
fn detect_campaign(tickets: &amp;[crate::api::report::StoryTicket]) -&gt; Option&lt;CampaignInfo&gt; {
⋮----
fn detect_campaign(tickets: &amp;[crate::api::report::StoryTicket]) -&gt; Option&lt;CampaignInfo&gt; {
if tickets.len() &lt; 3 {
⋮----
// Strategy 1: Group by threat_type + ISP
⋮----
for (i, ticket) in tickets.iter().enumerate() {
⋮----
ticket.threat_type.clone(),
ticket.isp.clone().unwrap_or_default(),
⋮----
isp_groups.entry(key).or_default().push(i);
⋮----
// Find largest group with at least 3 tickets and known ISP
⋮----
.filter(|((_, isp), indices)| !isp.is_empty() &amp;&amp; indices.len() &gt;= 3)
.max_by_key(|(_, indices)| indices.len());
⋮----
// Extract date range
⋮----
.filter_map(|&amp;i| {
⋮----
.as_deref()
.or(tickets[i].open_date.as_deref())
⋮----
let start = dates.iter().min().unwrap_or(&amp;&quot;Unknown&quot;).to_string();
let end = dates.iter().max().unwrap_or(&amp;&quot;Unknown&quot;).to_string();
⋮----
.get(*indices.first().unwrap_or(&amp;0))
.and_then(|t| t.ip.as_ref())
.and_then(|ip| {
let parts: Vec&lt;&amp;str&gt; = ip.split(&apos;.&apos;).collect();
if parts.len() &gt;= 2 {
Some(format!(&quot;{}.{}.*.*&quot;, parts[0], parts[1]))
⋮----
let threat_label = match threat_type.as_str() {
⋮----
let name = format!(&quot;{} Campaign via {}&quot;, threat_label, isp);
⋮----
return Some(CampaignInfo {
⋮----
threat_type: threat_type.clone(),
tickets: indices.clone(),
common_isp: Some(isp.clone()),
⋮----
.entry(ticket.threat_type.clone())
.or_default()
.push(i);
⋮----
.max_by_key(|(_, indices)| indices.len())?;
⋮----
if dominant.1.len() &gt;= 3 {
⋮----
let threat_label = match dominant.0.as_str() {
⋮----
name: format!(&quot;{} Cluster ({} incidents)&quot;, threat_label, dominant.1.len()),
threat_type: dominant.0.clone(),
tickets: dominant.1.clone(),
⋮----
fn render_incident_story_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
if data.story_tickets.is_empty() {
⋮----
let campaign = detect_campaign(&amp;data.story_tickets);
⋮----
.filter_map(|&amp;i| data.story_tickets.get(i))
⋮----
let ip_str = c.common_ip_prefix.as_deref().unwrap_or(&quot;*.*&quot;);
⋮----
format!(&quot;🎯 {}&quot;, c.name),
format!(&quot;{} coordinated incidents detected&quot;, c.tickets.len()),
⋮----
data.story_tickets.iter().collect(),
dict.story_title(),
dict.story_subtitle(data.story_tickets.len()),
⋮----
.or(ticket.open_date.as_deref())
.map(|d| if d.len() &gt;= 10 { &amp;d[0..10] } else { d })
.unwrap_or(&quot;Unknown&quot;);
⋮----
*timeline.entry(date_str.to_string()).or_insert(0) += 1;
⋮----
let dates: Vec&lt;String&gt; = timeline.keys().cloned().collect();
let counts: Vec&lt;u64&gt; = timeline.values().cloned().collect();
let json_dates = serde_json::to_string(&amp;dates).unwrap_or_default();
let json_counts = serde_json::to_string(&amp;counts).unwrap_or_default();
⋮----
for ticket in filtered_tickets.iter().take(3) {
⋮----
.find(|inv| inv.ticket_key == ticket.ticket_key)
.map(|inv| &amp;inv.enrichment);
⋮----
&lt;/div&gt;&quot;#.to_string()
⋮----
// Status badge color
let status_color = match ticket.status.to_lowercase().as_str() {
⋮----
.as_ref()
.or(ticket.open_date.as_ref())
.map(|d| {
if d.len() &gt;= 10 {
format!(&quot;{}/{}/{}&quot;, &amp;d[8..10], &amp;d[5..7], &amp;d[0..4])
⋮----
d.clone()
⋮----
.unwrap_or_else(|| &quot;N/A&quot;.to_string());
⋮----
cards_html.push_str(&amp;format!(
⋮----
/// Render the Threat Intelligence slide with 4 dimensions
fn render_threat_intelligence_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
fn render_threat_intelligence_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
// Skip if no data available
⋮----
let dark_web_html = format!(r#&quot;
⋮----
// === Dimension 2: Virality ===
let virality_html = format!(r#&quot;
⋮----
// === Dimension 3: Credential Quality ===
⋮----
let cred_html = format!(
⋮----
// === Dimension 4: Attacker Investment ===
let ads_html = format!(r#&quot;
⋮----
// Combine into full slide
⋮----
/// Render the Timeline Deep Investigation slide with enriched data
fn render_deep_investigation_slide(data: &amp;PocReportData, _dict: &amp;dyn Dictionary) -&gt; String {
⋮----
fn render_deep_investigation_slide(data: &amp;PocReportData, _dict: &amp;dyn Dictionary) -&gt; String {
if data.deep_investigations.is_empty() {
⋮----
// Build timeline cards for each investigation with enrichment
let investigation_cards: Vec&lt;String&gt; = data.deep_investigations.iter().take(6).map(|inv| {
⋮----
// Screenshot HTML - use base64 if available, otherwise placeholder
⋮----
// AI Impersonation badges
let impersonation_html = if !inv.enrichment.impersonated_brands.is_empty() {
let badges: Vec&lt;String&gt; = inv.enrichment.impersonated_brands.iter().take(2).map(|b| {
let (color, icon) = match b.level.as_str() {
⋮----
}).collect();
format!(r#&quot;&lt;div class=&quot;flex flex-wrap gap-1 mb-2&quot;&gt;{}&lt;/div&gt;&quot;#, badges.join(&quot;&quot;))
⋮----
// Credential/Payment warning badges
⋮----
badges.push(r#&quot;&lt;span class=&quot;text-[0.55rem] bg-orange-900/50 text-orange-300 px-1.5 py-0.5 rounded&quot;&gt;🔓 Credenciales&lt;/span&gt;&quot;#);
⋮----
badges.push(r#&quot;&lt;span class=&quot;text-[0.55rem] bg-red-900/50 text-red-300 px-1.5 py-0.5 rounded&quot;&gt;💳 Pagos&lt;/span&gt;&quot;#);
⋮----
if !badges.is_empty() {
format!(r#&quot;&lt;div class=&quot;flex gap-1 mb-2&quot;&gt;{}&lt;/div&gt;&quot;#, badges.join(&quot;&quot;))
⋮----
// Geolocation with country flag
⋮----
let country_flag = geo.country_code.as_ref().map(|cc| {
// Convert country code to flag emoji
cc.chars().filter(|c| c.is_alphabetic())
.map(|c| char::from_u32(0x1F1E6 + c.to_ascii_uppercase() as u32 - &apos;A&apos; as u32).unwrap_or(&apos;🏳&apos;))
⋮----
}).unwrap_or_else(|| &quot;🌐&quot;.to_string());
⋮----
let country = geo.country_name.as_deref().unwrap_or(&quot;--&quot;);
let isp = geo.isp.as_deref().unwrap_or(&quot;--&quot;);
⋮----
// Detection date (use enrichment date if available, fallback to first_seen)
let detection_date = inv.enrichment.detection_date.as_ref()
.or(inv.first_seen.as_ref())
.map(|d| format!(r#&quot;&lt;span class=&quot;text-purple-400&quot;&gt;{}&lt;/span&gt;&quot;#, d))
.unwrap_or_else(|| r#&quot;&lt;span class=&quot;text-zinc-600&quot;&gt;N/A&lt;/span&gt;&quot;#.to_string());
⋮----
// Domain created date
let domain_created = inv.enrichment.domain_created.as_ref()
.map(|d| format!(r#&quot;&lt;div class=&quot;text-[0.55rem] text-zinc-500&quot;&gt;📆 Dominio: {}&lt;/div&gt;&quot;#, d))
.unwrap_or_default();
⋮----
// AI content type badge
let content_type_badge = inv.enrichment.ai_content_type.as_ref()
.map(|ct| format!(
⋮----
// HTTP status indicator
let http_status = inv.enrichment.http_status.map(|s| {
⋮----
format!(r#&quot;&lt;span class=&quot;{} text-[0.6rem]&quot;&gt;{} {}&lt;/span&gt;&quot;#, color, icon, s)
}).unwrap_or_default();
⋮----
format!(r#&quot;
⋮----
// Summary stats
let total = data.deep_investigations.len();
⋮----
.filter(|i| i.is_mass_campaign)
.count();
⋮----
.map(|i| i.signal_count)
.sum();
⋮----
fn render_credential_slide(data: &amp;PocReportData, _dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
// Create rows for table
for cred in data.credential_exposures.iter().take(8) {
let user = cred.user.as_deref().unwrap_or(&quot;N/A&quot;);
let source_date = cred.leak_date.clone().unwrap_or_else(|| &quot;N/A&quot;.to_string());
⋮----
let leak_name = cred.leak_name.clone().unwrap_or_default();
let short_leak = if leak_name.len() &gt; 30 {
format!(&quot;{}...&quot;, &amp;leak_name[0..27])
⋮----
.or(cred.access_domain.as_deref())
.unwrap_or(&quot;-&quot;);
let short_url = if url.len() &gt; 40 {
format!(&quot;{}...&quot;, &amp;url[0..37])
⋮----
url.to_string()
⋮----
let date_display = if source_date.len() &gt;= 10 {
⋮----
rows.push_str(&amp;format!(
⋮----
// Fill empty rows if less than 8
let count = data.credential_exposures.len();
⋮----
rows.push_str(r#&quot;&lt;tr class=&quot;border-b border-zinc-900/50 text-sm&quot;&gt;&lt;td class=&quot;py-3 pl-4&quot;&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&quot;#);
⋮----
// Abstract geometric pattern (CSS only) - Refined for &quot;Thrive&quot; theme
⋮----
// Choose image source (URL or Base64)
⋮----
format!(&quot;data:image/jpeg;base64,{}&quot;, assets.office_image_base64)
⋮----
// HELPER FUNCTIONS
⋮----
fn country_to_flag(country: &amp;str) -&gt; String {
let country_lower = country.to_lowercase();
match country_lower.as_str() {
// Names
&quot;brazil&quot; | &quot;brasil&quot; =&gt; &quot;🇧🇷&quot;.to_string(),
&quot;united states&quot; | &quot;usa&quot; | &quot;us&quot; | &quot;estados unidos&quot; =&gt; &quot;🇺🇸&quot;.to_string(),
&quot;china&quot; =&gt; &quot;🇨🇳&quot;.to_string(),
&quot;russia&quot; =&gt; &quot;🇷🇺&quot;.to_string(),
&quot;germany&quot; | &quot;alemanha&quot; =&gt; &quot;🇩🇪&quot;.to_string(),
&quot;france&quot; | &quot;frança&quot; =&gt; &quot;🇫🇷&quot;.to_string(),
&quot;uk&quot; | &quot;united kingdom&quot; | &quot;reino unido&quot; =&gt; &quot;🇬🇧&quot;.to_string(),
&quot;india&quot; =&gt; &quot;🇮🇳&quot;.to_string(),
&quot;japan&quot; | &quot;japão&quot; =&gt; &quot;🇯🇵&quot;.to_string(),
&quot;canada&quot; =&gt; &quot;🇨🇦&quot;.to_string(),
&quot;australia&quot; =&gt; &quot;🇦🇺&quot;.to_string(),
&quot;netherlands&quot; | &quot;holanda&quot; =&gt; &quot;🇳🇱&quot;.to_string(),
&quot;singapore&quot; | &quot;singapura&quot; =&gt; &quot;🇸🇬&quot;.to_string(),
⋮----
if country.len() == 2 &amp;&amp; country.chars().all(|c| c.is_alphabetic()) {
⋮----
.chars()
.filter(|c| c.is_alphabetic())
.map(|c| {
char::from_u32(0x1F1E6 + c.to_ascii_uppercase() as u32 - &apos;A&apos; as u32)
.unwrap_or(&apos;🏳&apos;)
⋮----
.collect()
⋮----
&quot;🌐&quot;.to_string()
⋮----
fn format_date(date: &amp;str) -&gt; String {
⋮----
if date.len() == 10 &amp;&amp; date.contains(&apos;-&apos;) {
let parts: Vec&lt;&amp;str&gt; = date.split(&apos;-&apos;).collect();
if parts.len() == 3 {
return format!(&quot;{}/{}/{}&quot;, parts[2], parts[1], parts[0]);
⋮----
date.to_string()
⋮----
fn format_number(n: u64) -&gt; String {
⋮----
let s = n.to_string();
⋮----
for (i, c) in s.chars().rev().enumerate() {
⋮----
result.push(&apos;.&apos;);
⋮----
result.push(c);
⋮----
result.chars().rev().collect()
⋮----
pub fn generate_html(report: &amp;PocReport) -&gt; String {
let cover_slide = render_cover_slide(report);
let summary_slide = render_summary_slide(report);
let incidents_slide = render_incidents_slide(report);
let takedowns_slide = render_takedowns_slide(report);
let closing_slide = render_closing_slide(report);
⋮----
fn render_cover_slide(report: &amp;PocReport) -&gt; String {
⋮----
fn render_summary_slide(report: &amp;PocReport) -&gt; String {
⋮----
fn render_incidents_slide(report: &amp;PocReport) -&gt; String {
⋮----
if rows.is_empty() {
⋮----
fn render_takedowns_slide(report: &amp;PocReport) -&gt; String {
⋮----
fn render_closing_slide(report: &amp;PocReport) -&gt; String {
⋮----
/// Render Deep Analytics slide with conditional sections based on available data
fn render_deep_analytics_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
fn render_deep_analytics_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
// Section 1: Code Leak Insights
if analytics.has_code_leak_insights &amp;&amp; !analytics.secret_types_breakdown.is_empty() {
⋮----
for item in analytics.secret_types_breakdown.iter().take(5) {
⋮----
sections.push(format!(
⋮----
// Section 2: Credential Insights
if analytics.has_credential_insights &amp;&amp; !analytics.leak_source_breakdown.is_empty() {
⋮----
let color = if item.name.contains(&quot;STEALER&quot;) {
⋮----
// Section 3: Takedown Efficiency
if analytics.has_takedown_insights &amp;&amp; !analytics.takedowns_by_platform.is_empty() {
⋮----
for item in analytics.takedowns_by_platform.iter().take(5) {
⋮----
// If no sections, return empty (slide will be skipped)
if sections.is_empty() {
⋮----
// Determine grid columns based on number of sections
let grid_cols = match sections.len() {
⋮----
fn render_timeline_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
let mut hour_counts = vec![0u64; 24];
⋮----
let hour = dt.hour() as usize;
⋮----
let is_weekend = dt.weekday().number_from_monday() &gt;= 6;
if is_weekend || !(8..19).contains(&amp;hour) {
⋮----
if !(8..19).contains(&amp;h) {
background_colors.push(&quot;#ef4444&quot;);
⋮----
background_colors.push(&quot;#e4e4e7&quot;);
⋮----
.map(|h| format!(&quot;{:02}h&quot;, h))
⋮----
let json_data = serde_json::to_string(&amp;hour_counts).unwrap_or_default();
let json_colors = serde_json::to_string(&amp;background_colors).unwrap_or_default();
⋮----
// ... (existing mapped args)
⋮----
fn render_virality_slide(data: &amp;PocReportData, dict: &amp;Box&lt;dyn Dictionary&gt;) -&gt; String {
⋮----
// Choose Primary or Fallback
⋮----
let source_count = if !data.threat_intelligence.dark_web_sources.is_empty() {
data.threat_intelligence.dark_web_sources.len()
⋮----
// Safely extract top source
⋮----
.first()
.map(|s| s.as_str())
.unwrap_or(&quot;Telegram Fraud Groups&quot;);
⋮----
dict.narrative_virality_pain_primary(viral_count, source_count, top_source),
dict.narrative_virality_solution_primary(),
⋮----
dict.narrative_virality_pain_fallback(),
dict.narrative_virality_solution_fallback(),
⋮----
render_narrative_slide(
dict.narrative_virality_title(),
⋮----
mod tests {
⋮----
use crate::i18n::Language;
use std::fs::File;
use std::io::Write;
⋮----
fn test_generate_report_html_output() {
⋮----
company_name: &quot;Test Company&quot;.to_string(),
start_date: &quot;2023-01-01&quot;.to_string(),
end_date: &quot;2023-01-31&quot;.to_string(),
⋮----
tlp_level: &quot;AMBER&quot;.to_string(),
⋮----
brands: vec![&quot;TestBrand&quot;.to_string()],
⋮----
malware_breakdown: vec![],
top_services: vec![],
⋮----
platform_breakdown: vec![],
secret_types: vec![],
⋮----
sources: vec![],
⋮----
top_affected_domains: vec![],
⋮----
incidents_by_type: vec![IncidentTypeCount {
⋮----
takedown_median_time_to_notify: &quot;10 min&quot;.to_string(),
takedown_median_uptime: &quot;2 hrs&quot;.to_string(),
takedowns_by_type: vec![],
⋮----
threats_by_type: vec![
⋮----
poc_examples: vec![PocEvidence {
⋮----
takedown_examples: vec![],
⋮----
resolved_takedowns: vec![
⋮----
latest_incidents: vec![IncidentExample {
⋮----
story_tickets: vec![
⋮----
deep_investigations: vec![],
credential_exposures: vec![],
critical_credentials: vec![
⋮----
let html = generate_full_report_html(&amp;data, None, None, &amp;dict);
⋮----
let mut file = File::create(path).expect(&quot;Could not create debug file&quot;);
file.write_all(html.as_bytes())
.expect(&quot;Could not write to file&quot;);
⋮----
fn inject_report_data(json: &amp;str, data: &amp;PocReportData) -&gt; String {
let mut processed = json.to_string();
⋮----
.replace(&quot;{{company_name}}&quot;, &amp;data.company_name)
.replace(&quot;{{date}}&quot;, &amp;data.end_date)
.replace(&quot;{{total_incidents}}&quot;, &amp;data.total_threats.to_string())
.replace(&quot;{{total_takedowns}}&quot;, &amp;data.takedown_resolved.to_string())
.replace(
⋮----
&amp;format!(
⋮----
.replace(&quot;{{risk_score}}&quot;, &amp;format!(&quot;{:.1}&quot;, data.risk_score.current))
⋮----
.replace(&quot;{{signals}}&quot;, &amp;data.total_tickets.to_string())
.replace(&quot;{{incidents}}&quot;, &amp;data.total_threats.to_string())
⋮----
.saturating_sub(data.takedown_resolved)
.to_string(),
⋮----
.replace(&quot;{{credentials}}&quot;, &amp;data.credentials_total.to_string())
.replace(&quot;{{takedowns}}&quot;, &amp;data.takedown_resolved.to_string())
.replace(&quot;{{code_leaks}}&quot;, &amp;data.secrets_total.to_string());
⋮----
.replace(&quot;{{risk_label}}&quot;, risk_label)
.replace(&quot;{{risk_color}}&quot;, risk_color);
⋮----
processed = processed.replace(&quot;{{campaign_summary}}&quot;, &quot;No active campaigns detected&quot;);</file></files><git_diffs><git_diff_work_tree></git_diff_work_tree><git_diff_staged></git_diff_staged></git_diffs><instruction># Project Context &amp; Directives (Persistent)

You are analyzing the **Antigravity / Axur-Web** project.
This context is automatically injected by Repomix to ensure consistency across all AI sessions.

## 1. 🛡️ The &quot;No Panic&quot; Doctrine (CRITICAL)
-   **NEVER** use `unwrap()` in production code.
-   **ALWAYS** handle errors gracefully using `Result&lt;T, E&gt;` or `Option&lt;T&gt;`.
-   **EXCEPTION:** Use `expect(&quot;reason&quot;)` ONLY during initialization/startup where failure is unrecoverable.
-   **Drafting:** If prototyping, add `// TODO: remove unwrap` comments.

## 2. 🏗️ Architecture &amp; Stack
-   **Workspace:** Rust Workspace with multiple crates.
    -   `crates/backend`: Axum server (REST API). Runs on Google Cloud Run.
    -   `crates/frontend`: Leptos (WASM). Runs on Cloudflare Pages.
    -   `crates/core`: Shared logic, types, and domain models.
-   **Database:** Firestore (NoSQL).
-   **Environment:**
    -   **Host:** Windows 11.
    -   **Execution:** WSL 2 (Ubuntu). All `cargo` and `npm` commands run here.

## 3. 🚀 Deployment Constraints
-   **Backend:** Dockerized (Distroless/Debian Slim). Stateless.
-   **Frontend:** Static Asset (WASM + HTML/JS/CSS).
-   **Secrets:** Managed via Google Secret Manager (Runtime) and `.env` (Local).

## 4. 🧠 Agent Memory
-   Artifacts are stored in `.agent/` or `brain/`.
-   Use `task.md` to track progress.
-   Respect `.gitignore` and `repomix.config.json` filters.

## 5. 🤖 Interaction Guidelines
-   When proposing changes, always consider the **System Safety** (No Panic).
-   Prefer **Incremental Changes** over massive rewrites.
-   If you see `unwrap()`, flag it as a violation.
</instruction></repomix>